#=++

Copyright (C) 2024 3MF Consortium (Original Author)

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.1-develop.

Abstract: This is an autogenerated Julia file in order to allow an easy
 use of the 3MF Library

Interface version: 2.5.0

=#

module Lib3MF
using Libdl
if !@isdefined(Cbool)
	const Cbool = UInt8
end

struct ELib3MFException <: Exception
	code::Int32
	message::String
end
Base.showerror(io::IO, e::ELib3MFException) = print(io, "Lib3MFException ", e.code, e.message == "" ? "" : " : " * e.message)

@enum ErrorCodes::Int32 begin
	SUCCESS = 0
	NOTIMPLEMENTED = 1
	INVALIDPARAM = 2
	INVALIDCAST = 3
	BUFFERTOOSMALL = 4
	GENERICEXCEPTION = 5
	COULDNOTLOADLIBRARY = 6
	COULDNOTFINDLIBRARYEXPORT = 7
	INCOMPATIBLEBINARYVERSION = 8
	CALCULATIONABORTED = 10
	SHOULDNOTBECALLED = 11
	READERCLASSUNKNOWN = 100
	WRITERCLASSUNKNOWN = 101
	ITERATORINVALIDINDEX = 102
	INVALIDMODELRESOURCE = 103
	RESOURCENOTFOUND = 104
	INVALIDMODEL = 105
	INVALIDOBJECT = 106
	INVALIDMESHOBJECT = 107
	INVALIDCOMPONENTSOBJECT = 108
	INVALIDCOMPONENT = 109
	INVALIDBUILDITEM = 110
	INVALIDBASEMATERIALGROUP = 111
	INVALIDSLICESTACKRESOURCE = 112
	INVALIDTEXTURERESOURCE = 113
	INVALIDCOLORGROUP = 114
	INVALIDTEXTURE2DGROUP = 115
	INVALIDCOMPOSITEMATERIALS = 116
	INVALIDMULTIPROPERTYGROUP = 117
	INVALIDRESOURCEINDEX = 120
	ATTACHMENTNOTFOUND = 121
	FORBIDDENCYCLICREFERENCE = 130
	INVALIDATTACHMENTSTREAM = 131
	INVALIDPROPERTYCOUNT = 132
	UNKOWNPROGRESSIDENTIFIER = 140
	ELEMENTCOUNTEXCEEDSLIMIT = 141
	INVALIDRESOURCE = 142
	INVALIDLEVELSET = 143
	COULDNOTFINDTRIANGLESET = 144
	INVALIDTRIANGLESETINDEX = 145
	BEAMLATTICE_INVALID_OBJECTTYPE = 2000
	INVALIDKEYSTORE = 3000
	INVALIDKEYSTORECONSUMER = 3001
	KEYSTORECONSUMERNOTFOUND = 3002
	KEYSTORERESOURCEDATANOTFOUND = 3003
	SECURECONTEXTNOTREGISTERED = 3004
	INVALIDKEYSIZE = 3005
	INCOMPATIBLEPORTTYPES = 4000
	GRAPHISCYCLIC = 4001
	INPUTNOTSET = 4002
	INVALIDNODECONFIGURATION = 4003
end

const BINDING_VERSION_MAJOR = 2
const BINDING_VERSION_MINOR = 5
const BINDING_VERSION_MICRO = 0

# Enums
@enum ePropertyType::Int32 begin
	NoPropertyType = 0
	BaseMaterial = 1
	TexCoord = 2
	Colors = 3
	Composite = 4
	Multi = 5
end
@enum eSlicesMeshResolution::Int32 begin
	Fullres = 0
	Lowres = 1
end
@enum eModelUnit::Int32 begin
	MicroMeter = 0
	MilliMeter = 1
	CentiMeter = 2
	Inch = 3
	Foot = 4
	Meter = 5
end
@enum eObjectType::Int32 begin
	Other = 0
	Model = 1
	Support = 2
	SolidSupport = 3
	Surface = 4
end
@enum eTextureType::Int32 begin
	Unknown = 0
	PNG = 1
	JPEG = 2
end
@enum eTextureTileStyle::Int32 begin
	Wrap = 0
	Mirror = 1
	Clamp = 2
	NoTileStyle = 3
end
@enum eTextureFilter::Int32 begin
	Auto = 0
	Linear = 1
	Nearest = 2
end
@enum eBeamLatticeCapMode::Int32 begin
	Sphere = 0
	HemiSphere = 1
	Butt = 2
end
@enum eBeamLatticeClipMode::Int32 begin
	NoClipMode = 0
	Inside = 1
	Outside = 2
end
@enum eBeamLatticeBallMode::Int32 begin
	BeamLatticeBallModeNone = 0
	Mixed = 1
	All = 2
end
@enum eProgressIdentifier::Int32 begin
	QUERYCANCELED = 0
	DONE = 1
	CLEANUP = 2
	READSTREAM = 3
	EXTRACTOPCPACKAGE = 4
	READNONROOTMODELS = 5
	READROOTMODEL = 6
	READRESOURCES = 7
	READMESH = 8
	READSLICES = 9
	READBUILD = 10
	READCUSTOMATTACHMENT = 11
	READTEXTURETACHMENTS = 12
	CREATEOPCPACKAGE = 13
	WRITEMODELSTOSTREAM = 14
	WRITEROOTMODEL = 15
	WRITENONROOTMODELS = 16
	WRITEATTACHMENTS = 17
	WRITECONTENTTYPES = 18
	WRITENOBJECTS = 19
	WRITENODES = 20
	WRITETRIANGLES = 21
	WRITESLICES = 22
	WRITEKEYSTORE = 23
end
@enum eBlendMethod::Int32 begin
	NoBlendMethod = 0
	Mix = 1
	Multiply = 2
end
@enum eChannelName::Int32 begin
	Red = 0
	Green = 1
	Blue = 2
	Alpha = 3
end
@enum eCompositionMethod::Int32 begin
	WeightedSum = 0
	Multiply = 1
	Min = 2
	Max = 3
	Mask = 4
end
@enum eCompositionSpace::Int32 begin
	Raw = 0
	LinearColor = 1
end
@enum eImplicitNodeType::Int32 begin
	Addition = 0
	Subtraction = 1
	Multiplication = 2
	Division = 3
	Constant = 4
	ConstVec = 5
	ConstMat = 6
	ComposeVector = 7
	DecomposeVector = 8
	ComposeMatrix = 9
	MatrixFromColumns = 10
	MatrixFromRows = 11
	Dot = 12
	Cross = 13
	MatVecMultiplication = 14
	Transpose = 15
	Inverse = 16
	Sinus = 17
	Cosinus = 18
	Tan = 19
	ArcSin = 20
	ArcCos = 21
	ArcTan = 22
	ArcTan2 = 23
	Min = 24
	Max = 25
	Abs = 26
	Fmod = 27
	Pow = 28
	Sqrt = 29
	Exp = 30
	Log = 31
	Log2 = 32
	Log10 = 33
	Select = 34
	Clamp = 35
	Sinh = 36
	Cosh = 37
	Tanh = 38
	Round = 39
	Ceil = 40
	Floor = 41
	Sign = 42
	Fract = 43
	FunctionCall = 44
	Mesh = 45
	Length = 46
	ConstResourceID = 47
	VectorFromScalar = 48
	UnsignedMesh = 49
	Mod = 50
	BeamLattice = 51
	FunctionGradient = 52
	NormalizeDistance = 53
end
@enum eImplicitPortType::Int32 begin
	Scalar = 0
	Vector = 1
	Matrix = 2
	ResourceID = 3
end
@enum eImplicitNodeConfiguration::Int32 begin
	Default = 0
	ScalarToScalar = 1
	VectorToVector = 2
	MatrixToMatrix = 3
end
@enum eEncryptionAlgorithm::Int32 begin
	AES256_GCM = 1
end
@enum eWrappingAlgorithm::Int32 begin
	RSA_OAEP = 0
end
@enum eMgfAlgorithm::Int32 begin
	MGF1_SHA1 = 160
	MGF1_SHA224 = 224
	MGF1_SHA256 = 256
	MGF1_SHA384 = 384
	MGF1_SHA512 = 512
end
@enum eDigestMethod::Int32 begin
	SHA1 = 160
	SHA256 = 256
end
@enum eCompression::Int32 begin
	NoCompression = 0
	Deflate = 1
end

# Structs
struct sTriangle
	Indices::NTuple{3, UInt32}
end
struct sTriangleProperties
	ResourceID::UInt32
	PropertyIDs::NTuple{3, UInt32}
end
struct sPosition
	Coordinates::NTuple{3, Cfloat}
end
struct sPosition2D
	Coordinates::NTuple{2, Cfloat}
end
struct sCompositeConstituent
	PropertyID::UInt32
	MixingRatio::Cdouble
end
struct sMultiPropertyLayer
	ResourceID::UInt32
	TheBlendMethod::eBlendMethod
end
struct sTex2Coord
	U::Cdouble
	V::Cdouble
end
struct sTransform
	Fields::NTuple{3, NTuple{4, Cfloat}}
end
struct sBox
	MinCoordinate::NTuple{3, Cfloat}
	MaxCoordinate::NTuple{3, Cfloat}
end
struct sColor
	Red::UInt8
	Green::UInt8
	Blue::UInt8
	Alpha::UInt8
end
struct sBeam
	Indices::NTuple{2, UInt32}
	Radii::NTuple{2, Cdouble}
	CapModes::NTuple{2, eBeamLatticeCapMode}
end
struct sBall
	Index::UInt32
	Radius::Cdouble
end
struct sVector
	Coordinates::NTuple{3, Cdouble}
end
struct sMatrix4x4
	Field::NTuple{4, NTuple{4, Cdouble}}
end

abstract type AbstractLib3MFClass end

mutable struct Wrapper
	lib::Ptr{Cvoid}
	funcs::Dict{Symbol, Ptr{Cvoid}}
	injected::Dict{String, Any}
end

function Wrapper(libraryName::Union{Nothing, AbstractString}=nothing; symbolLookupMethodAddress::Ptr{Cvoid}=C_NULL)
	lib = C_NULL
	funcs = Dict{Symbol, Ptr{Cvoid}}()
	injected = Dict{String, Any}()
	if libraryName === nothing && symbolLookupMethodAddress == C_NULL
		libraryName = joinpath(@__DIR__, "lib3mf")
	end
	if libraryName !== nothing
		libpath = String(libraryName) * "." * Libdl.dlext
		try
			lib = Libdl.dlopen(libpath)
		catch err
			throw(ELib3MFException(Int32(COULDNOTLOADLIBRARY), string(err) * " | " * libpath))
		end
		w = Wrapper(lib, funcs, injected)
		_loadFunctionTable!(w)
	elseif symbolLookupMethodAddress != C_NULL
		w = Wrapper(lib, funcs, injected)
		_loadFunctionTableFromMethod!(w, symbolLookupMethodAddress)
	else
		throw(ELib3MFException(Int32(COULDNOTLOADLIBRARY), "Invalid library configuration"))
	end
	_checkBinaryVersion(w)
	return w
end

function _loadFunctionTable!(w::Wrapper)
	w.funcs[:lib3mf_getlibraryversion] = Libdl.dlsym(w.lib, :lib3mf_getlibraryversion)
	w.funcs[:lib3mf_getprereleaseinformation] = Libdl.dlsym(w.lib, :lib3mf_getprereleaseinformation)
	w.funcs[:lib3mf_getbuildinformation] = Libdl.dlsym(w.lib, :lib3mf_getbuildinformation)
	w.funcs[:lib3mf_getspecificationversion] = Libdl.dlsym(w.lib, :lib3mf_getspecificationversion)
	w.funcs[:lib3mf_createmodel] = Libdl.dlsym(w.lib, :lib3mf_createmodel)
	w.funcs[:lib3mf_release] = Libdl.dlsym(w.lib, :lib3mf_release)
	w.funcs[:lib3mf_acquire] = Libdl.dlsym(w.lib, :lib3mf_acquire)
	w.funcs[:lib3mf_setjournal] = Libdl.dlsym(w.lib, :lib3mf_setjournal)
	w.funcs[:lib3mf_getlasterror] = Libdl.dlsym(w.lib, :lib3mf_getlasterror)
	w.funcs[:lib3mf_getsymbollookupmethod] = Libdl.dlsym(w.lib, :lib3mf_getsymbollookupmethod)
	w.funcs[:lib3mf_retrieveprogressmessage] = Libdl.dlsym(w.lib, :lib3mf_retrieveprogressmessage)
	w.funcs[:lib3mf_rgbatocolor] = Libdl.dlsym(w.lib, :lib3mf_rgbatocolor)
	w.funcs[:lib3mf_floatrgbatocolor] = Libdl.dlsym(w.lib, :lib3mf_floatrgbatocolor)
	w.funcs[:lib3mf_colortorgba] = Libdl.dlsym(w.lib, :lib3mf_colortorgba)
	w.funcs[:lib3mf_colortofloatrgba] = Libdl.dlsym(w.lib, :lib3mf_colortofloatrgba)
	w.funcs[:lib3mf_getidentitytransform] = Libdl.dlsym(w.lib, :lib3mf_getidentitytransform)
	w.funcs[:lib3mf_getuniformscaletransform] = Libdl.dlsym(w.lib, :lib3mf_getuniformscaletransform)
	w.funcs[:lib3mf_getscaletransform] = Libdl.dlsym(w.lib, :lib3mf_getscaletransform)
	w.funcs[:lib3mf_gettranslationtransform] = Libdl.dlsym(w.lib, :lib3mf_gettranslationtransform)
	w.funcs[:lib3mf_base_classtypeid] = Libdl.dlsym(w.lib, :lib3mf_base_classtypeid)
	w.funcs[:lib3mf_writer_writetofile] = Libdl.dlsym(w.lib, :lib3mf_writer_writetofile)
	w.funcs[:lib3mf_writer_getstreamsize] = Libdl.dlsym(w.lib, :lib3mf_writer_getstreamsize)
	w.funcs[:lib3mf_writer_writetobuffer] = Libdl.dlsym(w.lib, :lib3mf_writer_writetobuffer)
	w.funcs[:lib3mf_writer_writetocallback] = Libdl.dlsym(w.lib, :lib3mf_writer_writetocallback)
	w.funcs[:lib3mf_writer_setprogresscallback] = Libdl.dlsym(w.lib, :lib3mf_writer_setprogresscallback)
	w.funcs[:lib3mf_writer_getdecimalprecision] = Libdl.dlsym(w.lib, :lib3mf_writer_getdecimalprecision)
	w.funcs[:lib3mf_writer_setdecimalprecision] = Libdl.dlsym(w.lib, :lib3mf_writer_setdecimalprecision)
	w.funcs[:lib3mf_writer_setstrictmodeactive] = Libdl.dlsym(w.lib, :lib3mf_writer_setstrictmodeactive)
	w.funcs[:lib3mf_writer_getstrictmodeactive] = Libdl.dlsym(w.lib, :lib3mf_writer_getstrictmodeactive)
	w.funcs[:lib3mf_writer_getwarning] = Libdl.dlsym(w.lib, :lib3mf_writer_getwarning)
	w.funcs[:lib3mf_writer_getwarningcount] = Libdl.dlsym(w.lib, :lib3mf_writer_getwarningcount)
	w.funcs[:lib3mf_writer_addkeywrappingcallback] = Libdl.dlsym(w.lib, :lib3mf_writer_addkeywrappingcallback)
	w.funcs[:lib3mf_writer_setcontentencryptioncallback] = Libdl.dlsym(w.lib, :lib3mf_writer_setcontentencryptioncallback)
	w.funcs[:lib3mf_reader_readfromfile] = Libdl.dlsym(w.lib, :lib3mf_reader_readfromfile)
	w.funcs[:lib3mf_reader_readfrombuffer] = Libdl.dlsym(w.lib, :lib3mf_reader_readfrombuffer)
	w.funcs[:lib3mf_reader_readfromcallback] = Libdl.dlsym(w.lib, :lib3mf_reader_readfromcallback)
	w.funcs[:lib3mf_reader_setprogresscallback] = Libdl.dlsym(w.lib, :lib3mf_reader_setprogresscallback)
	w.funcs[:lib3mf_reader_addrelationtoread] = Libdl.dlsym(w.lib, :lib3mf_reader_addrelationtoread)
	w.funcs[:lib3mf_reader_removerelationtoread] = Libdl.dlsym(w.lib, :lib3mf_reader_removerelationtoread)
	w.funcs[:lib3mf_reader_setstrictmodeactive] = Libdl.dlsym(w.lib, :lib3mf_reader_setstrictmodeactive)
	w.funcs[:lib3mf_reader_getstrictmodeactive] = Libdl.dlsym(w.lib, :lib3mf_reader_getstrictmodeactive)
	w.funcs[:lib3mf_reader_getwarning] = Libdl.dlsym(w.lib, :lib3mf_reader_getwarning)
	w.funcs[:lib3mf_reader_getwarningcount] = Libdl.dlsym(w.lib, :lib3mf_reader_getwarningcount)
	w.funcs[:lib3mf_reader_addkeywrappingcallback] = Libdl.dlsym(w.lib, :lib3mf_reader_addkeywrappingcallback)
	w.funcs[:lib3mf_reader_setcontentencryptioncallback] = Libdl.dlsym(w.lib, :lib3mf_reader_setcontentencryptioncallback)
	w.funcs[:lib3mf_packagepart_getpath] = Libdl.dlsym(w.lib, :lib3mf_packagepart_getpath)
	w.funcs[:lib3mf_packagepart_setpath] = Libdl.dlsym(w.lib, :lib3mf_packagepart_setpath)
	w.funcs[:lib3mf_resource_getresourceid] = Libdl.dlsym(w.lib, :lib3mf_resource_getresourceid)
	w.funcs[:lib3mf_resource_getuniqueresourceid] = Libdl.dlsym(w.lib, :lib3mf_resource_getuniqueresourceid)
	w.funcs[:lib3mf_resource_packagepart] = Libdl.dlsym(w.lib, :lib3mf_resource_packagepart)
	w.funcs[:lib3mf_resource_setpackagepart] = Libdl.dlsym(w.lib, :lib3mf_resource_setpackagepart)
	w.funcs[:lib3mf_resource_getmodelresourceid] = Libdl.dlsym(w.lib, :lib3mf_resource_getmodelresourceid)
	w.funcs[:lib3mf_resourceiterator_movenext] = Libdl.dlsym(w.lib, :lib3mf_resourceiterator_movenext)
	w.funcs[:lib3mf_resourceiterator_moveprevious] = Libdl.dlsym(w.lib, :lib3mf_resourceiterator_moveprevious)
	w.funcs[:lib3mf_resourceiterator_getcurrent] = Libdl.dlsym(w.lib, :lib3mf_resourceiterator_getcurrent)
	w.funcs[:lib3mf_resourceiterator_clone] = Libdl.dlsym(w.lib, :lib3mf_resourceiterator_clone)
	w.funcs[:lib3mf_resourceiterator_count] = Libdl.dlsym(w.lib, :lib3mf_resourceiterator_count)
	w.funcs[:lib3mf_slicestackiterator_getcurrentslicestack] = Libdl.dlsym(w.lib, :lib3mf_slicestackiterator_getcurrentslicestack)
	w.funcs[:lib3mf_objectiterator_getcurrentobject] = Libdl.dlsym(w.lib, :lib3mf_objectiterator_getcurrentobject)
	w.funcs[:lib3mf_meshobjectiterator_getcurrentmeshobject] = Libdl.dlsym(w.lib, :lib3mf_meshobjectiterator_getcurrentmeshobject)
	w.funcs[:lib3mf_componentsobjectiterator_getcurrentcomponentsobject] = Libdl.dlsym(w.lib, :lib3mf_componentsobjectiterator_getcurrentcomponentsobject)
	w.funcs[:lib3mf_texture2diterator_getcurrenttexture2d] = Libdl.dlsym(w.lib, :lib3mf_texture2diterator_getcurrenttexture2d)
	w.funcs[:lib3mf_basematerialgroupiterator_getcurrentbasematerialgroup] = Libdl.dlsym(w.lib, :lib3mf_basematerialgroupiterator_getcurrentbasematerialgroup)
	w.funcs[:lib3mf_colorgroupiterator_getcurrentcolorgroup] = Libdl.dlsym(w.lib, :lib3mf_colorgroupiterator_getcurrentcolorgroup)
	w.funcs[:lib3mf_texture2dgroupiterator_getcurrenttexture2dgroup] = Libdl.dlsym(w.lib, :lib3mf_texture2dgroupiterator_getcurrenttexture2dgroup)
	w.funcs[:lib3mf_compositematerialsiterator_getcurrentcompositematerials] = Libdl.dlsym(w.lib, :lib3mf_compositematerialsiterator_getcurrentcompositematerials)
	w.funcs[:lib3mf_multipropertygroupiterator_getcurrentmultipropertygroup] = Libdl.dlsym(w.lib, :lib3mf_multipropertygroupiterator_getcurrentmultipropertygroup)
	w.funcs[:lib3mf_image3diterator_getcurrentimage3d] = Libdl.dlsym(w.lib, :lib3mf_image3diterator_getcurrentimage3d)
	w.funcs[:lib3mf_functioniterator_getcurrentfunction] = Libdl.dlsym(w.lib, :lib3mf_functioniterator_getcurrentfunction)
	w.funcs[:lib3mf_levelsetiterator_getcurrentlevelset] = Libdl.dlsym(w.lib, :lib3mf_levelsetiterator_getcurrentlevelset)
	w.funcs[:lib3mf_metadata_getnamespace] = Libdl.dlsym(w.lib, :lib3mf_metadata_getnamespace)
	w.funcs[:lib3mf_metadata_setnamespace] = Libdl.dlsym(w.lib, :lib3mf_metadata_setnamespace)
	w.funcs[:lib3mf_metadata_getname] = Libdl.dlsym(w.lib, :lib3mf_metadata_getname)
	w.funcs[:lib3mf_metadata_setname] = Libdl.dlsym(w.lib, :lib3mf_metadata_setname)
	w.funcs[:lib3mf_metadata_getkey] = Libdl.dlsym(w.lib, :lib3mf_metadata_getkey)
	w.funcs[:lib3mf_metadata_getmustpreserve] = Libdl.dlsym(w.lib, :lib3mf_metadata_getmustpreserve)
	w.funcs[:lib3mf_metadata_setmustpreserve] = Libdl.dlsym(w.lib, :lib3mf_metadata_setmustpreserve)
	w.funcs[:lib3mf_metadata_gettype] = Libdl.dlsym(w.lib, :lib3mf_metadata_gettype)
	w.funcs[:lib3mf_metadata_settype] = Libdl.dlsym(w.lib, :lib3mf_metadata_settype)
	w.funcs[:lib3mf_metadata_getvalue] = Libdl.dlsym(w.lib, :lib3mf_metadata_getvalue)
	w.funcs[:lib3mf_metadata_setvalue] = Libdl.dlsym(w.lib, :lib3mf_metadata_setvalue)
	w.funcs[:lib3mf_metadatagroup_getmetadatacount] = Libdl.dlsym(w.lib, :lib3mf_metadatagroup_getmetadatacount)
	w.funcs[:lib3mf_metadatagroup_getmetadata] = Libdl.dlsym(w.lib, :lib3mf_metadatagroup_getmetadata)
	w.funcs[:lib3mf_metadatagroup_getmetadatabykey] = Libdl.dlsym(w.lib, :lib3mf_metadatagroup_getmetadatabykey)
	w.funcs[:lib3mf_metadatagroup_removemetadatabyindex] = Libdl.dlsym(w.lib, :lib3mf_metadatagroup_removemetadatabyindex)
	w.funcs[:lib3mf_metadatagroup_removemetadata] = Libdl.dlsym(w.lib, :lib3mf_metadatagroup_removemetadata)
	w.funcs[:lib3mf_metadatagroup_addmetadata] = Libdl.dlsym(w.lib, :lib3mf_metadatagroup_addmetadata)
	w.funcs[:lib3mf_triangleset_setname] = Libdl.dlsym(w.lib, :lib3mf_triangleset_setname)
	w.funcs[:lib3mf_triangleset_getname] = Libdl.dlsym(w.lib, :lib3mf_triangleset_getname)
	w.funcs[:lib3mf_triangleset_setidentifier] = Libdl.dlsym(w.lib, :lib3mf_triangleset_setidentifier)
	w.funcs[:lib3mf_triangleset_getidentifier] = Libdl.dlsym(w.lib, :lib3mf_triangleset_getidentifier)
	w.funcs[:lib3mf_triangleset_addtriangle] = Libdl.dlsym(w.lib, :lib3mf_triangleset_addtriangle)
	w.funcs[:lib3mf_triangleset_removetriangle] = Libdl.dlsym(w.lib, :lib3mf_triangleset_removetriangle)
	w.funcs[:lib3mf_triangleset_clear] = Libdl.dlsym(w.lib, :lib3mf_triangleset_clear)
	w.funcs[:lib3mf_triangleset_settrianglelist] = Libdl.dlsym(w.lib, :lib3mf_triangleset_settrianglelist)
	w.funcs[:lib3mf_triangleset_gettrianglelist] = Libdl.dlsym(w.lib, :lib3mf_triangleset_gettrianglelist)
	w.funcs[:lib3mf_triangleset_addtrianglelist] = Libdl.dlsym(w.lib, :lib3mf_triangleset_addtrianglelist)
	w.funcs[:lib3mf_triangleset_merge] = Libdl.dlsym(w.lib, :lib3mf_triangleset_merge)
	w.funcs[:lib3mf_triangleset_deleteset] = Libdl.dlsym(w.lib, :lib3mf_triangleset_deleteset)
	w.funcs[:lib3mf_triangleset_duplicate] = Libdl.dlsym(w.lib, :lib3mf_triangleset_duplicate)
	w.funcs[:lib3mf_object_gettype] = Libdl.dlsym(w.lib, :lib3mf_object_gettype)
	w.funcs[:lib3mf_object_settype] = Libdl.dlsym(w.lib, :lib3mf_object_settype)
	w.funcs[:lib3mf_object_getname] = Libdl.dlsym(w.lib, :lib3mf_object_getname)
	w.funcs[:lib3mf_object_setname] = Libdl.dlsym(w.lib, :lib3mf_object_setname)
	w.funcs[:lib3mf_object_getpartnumber] = Libdl.dlsym(w.lib, :lib3mf_object_getpartnumber)
	w.funcs[:lib3mf_object_setpartnumber] = Libdl.dlsym(w.lib, :lib3mf_object_setpartnumber)
	w.funcs[:lib3mf_object_ismeshobject] = Libdl.dlsym(w.lib, :lib3mf_object_ismeshobject)
	w.funcs[:lib3mf_object_iscomponentsobject] = Libdl.dlsym(w.lib, :lib3mf_object_iscomponentsobject)
	w.funcs[:lib3mf_object_islevelsetobject] = Libdl.dlsym(w.lib, :lib3mf_object_islevelsetobject)
	w.funcs[:lib3mf_object_isvalid] = Libdl.dlsym(w.lib, :lib3mf_object_isvalid)
	w.funcs[:lib3mf_object_setattachmentasthumbnail] = Libdl.dlsym(w.lib, :lib3mf_object_setattachmentasthumbnail)
	w.funcs[:lib3mf_object_getthumbnailattachment] = Libdl.dlsym(w.lib, :lib3mf_object_getthumbnailattachment)
	w.funcs[:lib3mf_object_clearthumbnailattachment] = Libdl.dlsym(w.lib, :lib3mf_object_clearthumbnailattachment)
	w.funcs[:lib3mf_object_getoutbox] = Libdl.dlsym(w.lib, :lib3mf_object_getoutbox)
	w.funcs[:lib3mf_object_getuuid] = Libdl.dlsym(w.lib, :lib3mf_object_getuuid)
	w.funcs[:lib3mf_object_setuuid] = Libdl.dlsym(w.lib, :lib3mf_object_setuuid)
	w.funcs[:lib3mf_object_getmetadatagroup] = Libdl.dlsym(w.lib, :lib3mf_object_getmetadatagroup)
	w.funcs[:lib3mf_object_setslicesmeshresolution] = Libdl.dlsym(w.lib, :lib3mf_object_setslicesmeshresolution)
	w.funcs[:lib3mf_object_getslicesmeshresolution] = Libdl.dlsym(w.lib, :lib3mf_object_getslicesmeshresolution)
	w.funcs[:lib3mf_object_hasslices] = Libdl.dlsym(w.lib, :lib3mf_object_hasslices)
	w.funcs[:lib3mf_object_clearslicestack] = Libdl.dlsym(w.lib, :lib3mf_object_clearslicestack)
	w.funcs[:lib3mf_object_getslicestack] = Libdl.dlsym(w.lib, :lib3mf_object_getslicestack)
	w.funcs[:lib3mf_object_assignslicestack] = Libdl.dlsym(w.lib, :lib3mf_object_assignslicestack)
	w.funcs[:lib3mf_meshobject_getvertexcount] = Libdl.dlsym(w.lib, :lib3mf_meshobject_getvertexcount)
	w.funcs[:lib3mf_meshobject_gettrianglecount] = Libdl.dlsym(w.lib, :lib3mf_meshobject_gettrianglecount)
	w.funcs[:lib3mf_meshobject_getvertex] = Libdl.dlsym(w.lib, :lib3mf_meshobject_getvertex)
	w.funcs[:lib3mf_meshobject_setvertex] = Libdl.dlsym(w.lib, :lib3mf_meshobject_setvertex)
	w.funcs[:lib3mf_meshobject_addvertex] = Libdl.dlsym(w.lib, :lib3mf_meshobject_addvertex)
	w.funcs[:lib3mf_meshobject_getvertices] = Libdl.dlsym(w.lib, :lib3mf_meshobject_getvertices)
	w.funcs[:lib3mf_meshobject_gettriangle] = Libdl.dlsym(w.lib, :lib3mf_meshobject_gettriangle)
	w.funcs[:lib3mf_meshobject_settriangle] = Libdl.dlsym(w.lib, :lib3mf_meshobject_settriangle)
	w.funcs[:lib3mf_meshobject_addtriangle] = Libdl.dlsym(w.lib, :lib3mf_meshobject_addtriangle)
	w.funcs[:lib3mf_meshobject_gettriangleindices] = Libdl.dlsym(w.lib, :lib3mf_meshobject_gettriangleindices)
	w.funcs[:lib3mf_meshobject_setobjectlevelproperty] = Libdl.dlsym(w.lib, :lib3mf_meshobject_setobjectlevelproperty)
	w.funcs[:lib3mf_meshobject_getobjectlevelproperty] = Libdl.dlsym(w.lib, :lib3mf_meshobject_getobjectlevelproperty)
	w.funcs[:lib3mf_meshobject_settriangleproperties] = Libdl.dlsym(w.lib, :lib3mf_meshobject_settriangleproperties)
	w.funcs[:lib3mf_meshobject_gettriangleproperties] = Libdl.dlsym(w.lib, :lib3mf_meshobject_gettriangleproperties)
	w.funcs[:lib3mf_meshobject_setalltriangleproperties] = Libdl.dlsym(w.lib, :lib3mf_meshobject_setalltriangleproperties)
	w.funcs[:lib3mf_meshobject_getalltriangleproperties] = Libdl.dlsym(w.lib, :lib3mf_meshobject_getalltriangleproperties)
	w.funcs[:lib3mf_meshobject_clearallproperties] = Libdl.dlsym(w.lib, :lib3mf_meshobject_clearallproperties)
	w.funcs[:lib3mf_meshobject_setgeometry] = Libdl.dlsym(w.lib, :lib3mf_meshobject_setgeometry)
	w.funcs[:lib3mf_meshobject_ismanifoldandoriented] = Libdl.dlsym(w.lib, :lib3mf_meshobject_ismanifoldandoriented)
	w.funcs[:lib3mf_meshobject_beamlattice] = Libdl.dlsym(w.lib, :lib3mf_meshobject_beamlattice)
	w.funcs[:lib3mf_meshobject_getvolumedata] = Libdl.dlsym(w.lib, :lib3mf_meshobject_getvolumedata)
	w.funcs[:lib3mf_meshobject_setvolumedata] = Libdl.dlsym(w.lib, :lib3mf_meshobject_setvolumedata)
	w.funcs[:lib3mf_meshobject_addtriangleset] = Libdl.dlsym(w.lib, :lib3mf_meshobject_addtriangleset)
	w.funcs[:lib3mf_meshobject_hastriangleset] = Libdl.dlsym(w.lib, :lib3mf_meshobject_hastriangleset)
	w.funcs[:lib3mf_meshobject_findtriangleset] = Libdl.dlsym(w.lib, :lib3mf_meshobject_findtriangleset)
	w.funcs[:lib3mf_meshobject_gettrianglesetcount] = Libdl.dlsym(w.lib, :lib3mf_meshobject_gettrianglesetcount)
	w.funcs[:lib3mf_meshobject_gettriangleset] = Libdl.dlsym(w.lib, :lib3mf_meshobject_gettriangleset)
	w.funcs[:lib3mf_levelset_getfunction] = Libdl.dlsym(w.lib, :lib3mf_levelset_getfunction)
	w.funcs[:lib3mf_levelset_setfunction] = Libdl.dlsym(w.lib, :lib3mf_levelset_setfunction)
	w.funcs[:lib3mf_levelset_gettransform] = Libdl.dlsym(w.lib, :lib3mf_levelset_gettransform)
	w.funcs[:lib3mf_levelset_settransform] = Libdl.dlsym(w.lib, :lib3mf_levelset_settransform)
	w.funcs[:lib3mf_levelset_getchannelname] = Libdl.dlsym(w.lib, :lib3mf_levelset_getchannelname)
	w.funcs[:lib3mf_levelset_setchannelname] = Libdl.dlsym(w.lib, :lib3mf_levelset_setchannelname)
	w.funcs[:lib3mf_levelset_setminfeaturesize] = Libdl.dlsym(w.lib, :lib3mf_levelset_setminfeaturesize)
	w.funcs[:lib3mf_levelset_getminfeaturesize] = Libdl.dlsym(w.lib, :lib3mf_levelset_getminfeaturesize)
	w.funcs[:lib3mf_levelset_setfallbackvalue] = Libdl.dlsym(w.lib, :lib3mf_levelset_setfallbackvalue)
	w.funcs[:lib3mf_levelset_getfallbackvalue] = Libdl.dlsym(w.lib, :lib3mf_levelset_getfallbackvalue)
	w.funcs[:lib3mf_levelset_setmeshbboxonly] = Libdl.dlsym(w.lib, :lib3mf_levelset_setmeshbboxonly)
	w.funcs[:lib3mf_levelset_getmeshbboxonly] = Libdl.dlsym(w.lib, :lib3mf_levelset_getmeshbboxonly)
	w.funcs[:lib3mf_levelset_setmesh] = Libdl.dlsym(w.lib, :lib3mf_levelset_setmesh)
	w.funcs[:lib3mf_levelset_getmesh] = Libdl.dlsym(w.lib, :lib3mf_levelset_getmesh)
	w.funcs[:lib3mf_levelset_getvolumedata] = Libdl.dlsym(w.lib, :lib3mf_levelset_getvolumedata)
	w.funcs[:lib3mf_levelset_setvolumedata] = Libdl.dlsym(w.lib, :lib3mf_levelset_setvolumedata)
	w.funcs[:lib3mf_beamlattice_getminlength] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_getminlength)
	w.funcs[:lib3mf_beamlattice_setminlength] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_setminlength)
	w.funcs[:lib3mf_beamlattice_getclipping] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_getclipping)
	w.funcs[:lib3mf_beamlattice_setclipping] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_setclipping)
	w.funcs[:lib3mf_beamlattice_getrepresentation] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_getrepresentation)
	w.funcs[:lib3mf_beamlattice_setrepresentation] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_setrepresentation)
	w.funcs[:lib3mf_beamlattice_getballoptions] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_getballoptions)
	w.funcs[:lib3mf_beamlattice_setballoptions] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_setballoptions)
	w.funcs[:lib3mf_beamlattice_getbeamcount] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_getbeamcount)
	w.funcs[:lib3mf_beamlattice_getbeam] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_getbeam)
	w.funcs[:lib3mf_beamlattice_addbeam] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_addbeam)
	w.funcs[:lib3mf_beamlattice_setbeam] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_setbeam)
	w.funcs[:lib3mf_beamlattice_setbeams] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_setbeams)
	w.funcs[:lib3mf_beamlattice_getbeams] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_getbeams)
	w.funcs[:lib3mf_beamlattice_getballcount] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_getballcount)
	w.funcs[:lib3mf_beamlattice_getball] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_getball)
	w.funcs[:lib3mf_beamlattice_addball] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_addball)
	w.funcs[:lib3mf_beamlattice_setball] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_setball)
	w.funcs[:lib3mf_beamlattice_setballs] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_setballs)
	w.funcs[:lib3mf_beamlattice_getballs] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_getballs)
	w.funcs[:lib3mf_beamlattice_getbeamsetcount] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_getbeamsetcount)
	w.funcs[:lib3mf_beamlattice_addbeamset] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_addbeamset)
	w.funcs[:lib3mf_beamlattice_getbeamset] = Libdl.dlsym(w.lib, :lib3mf_beamlattice_getbeamset)
	w.funcs[:lib3mf_functionreference_getfunctionresourceid] = Libdl.dlsym(w.lib, :lib3mf_functionreference_getfunctionresourceid)
	w.funcs[:lib3mf_functionreference_setfunctionresourceid] = Libdl.dlsym(w.lib, :lib3mf_functionreference_setfunctionresourceid)
	w.funcs[:lib3mf_functionreference_gettransform] = Libdl.dlsym(w.lib, :lib3mf_functionreference_gettransform)
	w.funcs[:lib3mf_functionreference_settransform] = Libdl.dlsym(w.lib, :lib3mf_functionreference_settransform)
	w.funcs[:lib3mf_functionreference_getchannelname] = Libdl.dlsym(w.lib, :lib3mf_functionreference_getchannelname)
	w.funcs[:lib3mf_functionreference_setchannelname] = Libdl.dlsym(w.lib, :lib3mf_functionreference_setchannelname)
	w.funcs[:lib3mf_functionreference_setminfeaturesize] = Libdl.dlsym(w.lib, :lib3mf_functionreference_setminfeaturesize)
	w.funcs[:lib3mf_functionreference_getminfeaturesize] = Libdl.dlsym(w.lib, :lib3mf_functionreference_getminfeaturesize)
	w.funcs[:lib3mf_functionreference_setfallbackvalue] = Libdl.dlsym(w.lib, :lib3mf_functionreference_setfallbackvalue)
	w.funcs[:lib3mf_functionreference_getfallbackvalue] = Libdl.dlsym(w.lib, :lib3mf_functionreference_getfallbackvalue)
	w.funcs[:lib3mf_volumedatacomposite_getbasematerialgroup] = Libdl.dlsym(w.lib, :lib3mf_volumedatacomposite_getbasematerialgroup)
	w.funcs[:lib3mf_volumedatacomposite_setbasematerialgroup] = Libdl.dlsym(w.lib, :lib3mf_volumedatacomposite_setbasematerialgroup)
	w.funcs[:lib3mf_volumedatacomposite_getmaterialmappingcount] = Libdl.dlsym(w.lib, :lib3mf_volumedatacomposite_getmaterialmappingcount)
	w.funcs[:lib3mf_volumedatacomposite_getmaterialmapping] = Libdl.dlsym(w.lib, :lib3mf_volumedatacomposite_getmaterialmapping)
	w.funcs[:lib3mf_volumedatacomposite_addmaterialmapping] = Libdl.dlsym(w.lib, :lib3mf_volumedatacomposite_addmaterialmapping)
	w.funcs[:lib3mf_volumedatacomposite_removematerialmapping] = Libdl.dlsym(w.lib, :lib3mf_volumedatacomposite_removematerialmapping)
	w.funcs[:lib3mf_volumedataproperty_getname] = Libdl.dlsym(w.lib, :lib3mf_volumedataproperty_getname)
	w.funcs[:lib3mf_volumedataproperty_setisrequired] = Libdl.dlsym(w.lib, :lib3mf_volumedataproperty_setisrequired)
	w.funcs[:lib3mf_volumedataproperty_isrequired] = Libdl.dlsym(w.lib, :lib3mf_volumedataproperty_isrequired)
	w.funcs[:lib3mf_volumedata_getcomposite] = Libdl.dlsym(w.lib, :lib3mf_volumedata_getcomposite)
	w.funcs[:lib3mf_volumedata_createnewcomposite] = Libdl.dlsym(w.lib, :lib3mf_volumedata_createnewcomposite)
	w.funcs[:lib3mf_volumedata_removecomposite] = Libdl.dlsym(w.lib, :lib3mf_volumedata_removecomposite)
	w.funcs[:lib3mf_volumedata_getcolor] = Libdl.dlsym(w.lib, :lib3mf_volumedata_getcolor)
	w.funcs[:lib3mf_volumedata_createnewcolor] = Libdl.dlsym(w.lib, :lib3mf_volumedata_createnewcolor)
	w.funcs[:lib3mf_volumedata_removecolor] = Libdl.dlsym(w.lib, :lib3mf_volumedata_removecolor)
	w.funcs[:lib3mf_volumedata_getpropertycount] = Libdl.dlsym(w.lib, :lib3mf_volumedata_getpropertycount)
	w.funcs[:lib3mf_volumedata_getproperty] = Libdl.dlsym(w.lib, :lib3mf_volumedata_getproperty)
	w.funcs[:lib3mf_volumedata_addpropertyfromfunction] = Libdl.dlsym(w.lib, :lib3mf_volumedata_addpropertyfromfunction)
	w.funcs[:lib3mf_volumedata_removeproperty] = Libdl.dlsym(w.lib, :lib3mf_volumedata_removeproperty)
	w.funcs[:lib3mf_component_getobjectresource] = Libdl.dlsym(w.lib, :lib3mf_component_getobjectresource)
	w.funcs[:lib3mf_component_getobjectresourceid] = Libdl.dlsym(w.lib, :lib3mf_component_getobjectresourceid)
	w.funcs[:lib3mf_component_getuuid] = Libdl.dlsym(w.lib, :lib3mf_component_getuuid)
	w.funcs[:lib3mf_component_setuuid] = Libdl.dlsym(w.lib, :lib3mf_component_setuuid)
	w.funcs[:lib3mf_component_hastransform] = Libdl.dlsym(w.lib, :lib3mf_component_hastransform)
	w.funcs[:lib3mf_component_gettransform] = Libdl.dlsym(w.lib, :lib3mf_component_gettransform)
	w.funcs[:lib3mf_component_settransform] = Libdl.dlsym(w.lib, :lib3mf_component_settransform)
	w.funcs[:lib3mf_componentsobject_addcomponent] = Libdl.dlsym(w.lib, :lib3mf_componentsobject_addcomponent)
	w.funcs[:lib3mf_componentsobject_getcomponent] = Libdl.dlsym(w.lib, :lib3mf_componentsobject_getcomponent)
	w.funcs[:lib3mf_componentsobject_getcomponentcount] = Libdl.dlsym(w.lib, :lib3mf_componentsobject_getcomponentcount)
	w.funcs[:lib3mf_beamset_setname] = Libdl.dlsym(w.lib, :lib3mf_beamset_setname)
	w.funcs[:lib3mf_beamset_getname] = Libdl.dlsym(w.lib, :lib3mf_beamset_getname)
	w.funcs[:lib3mf_beamset_setidentifier] = Libdl.dlsym(w.lib, :lib3mf_beamset_setidentifier)
	w.funcs[:lib3mf_beamset_getidentifier] = Libdl.dlsym(w.lib, :lib3mf_beamset_getidentifier)
	w.funcs[:lib3mf_beamset_getreferencecount] = Libdl.dlsym(w.lib, :lib3mf_beamset_getreferencecount)
	w.funcs[:lib3mf_beamset_setreferences] = Libdl.dlsym(w.lib, :lib3mf_beamset_setreferences)
	w.funcs[:lib3mf_beamset_getreferences] = Libdl.dlsym(w.lib, :lib3mf_beamset_getreferences)
	w.funcs[:lib3mf_beamset_getballreferencecount] = Libdl.dlsym(w.lib, :lib3mf_beamset_getballreferencecount)
	w.funcs[:lib3mf_beamset_setballreferences] = Libdl.dlsym(w.lib, :lib3mf_beamset_setballreferences)
	w.funcs[:lib3mf_beamset_getballreferences] = Libdl.dlsym(w.lib, :lib3mf_beamset_getballreferences)
	w.funcs[:lib3mf_basematerialgroup_getcount] = Libdl.dlsym(w.lib, :lib3mf_basematerialgroup_getcount)
	w.funcs[:lib3mf_basematerialgroup_getallpropertyids] = Libdl.dlsym(w.lib, :lib3mf_basematerialgroup_getallpropertyids)
	w.funcs[:lib3mf_basematerialgroup_addmaterial] = Libdl.dlsym(w.lib, :lib3mf_basematerialgroup_addmaterial)
	w.funcs[:lib3mf_basematerialgroup_removematerial] = Libdl.dlsym(w.lib, :lib3mf_basematerialgroup_removematerial)
	w.funcs[:lib3mf_basematerialgroup_getname] = Libdl.dlsym(w.lib, :lib3mf_basematerialgroup_getname)
	w.funcs[:lib3mf_basematerialgroup_setname] = Libdl.dlsym(w.lib, :lib3mf_basematerialgroup_setname)
	w.funcs[:lib3mf_basematerialgroup_setdisplaycolor] = Libdl.dlsym(w.lib, :lib3mf_basematerialgroup_setdisplaycolor)
	w.funcs[:lib3mf_basematerialgroup_getdisplaycolor] = Libdl.dlsym(w.lib, :lib3mf_basematerialgroup_getdisplaycolor)
	w.funcs[:lib3mf_colorgroup_getcount] = Libdl.dlsym(w.lib, :lib3mf_colorgroup_getcount)
	w.funcs[:lib3mf_colorgroup_getallpropertyids] = Libdl.dlsym(w.lib, :lib3mf_colorgroup_getallpropertyids)
	w.funcs[:lib3mf_colorgroup_addcolor] = Libdl.dlsym(w.lib, :lib3mf_colorgroup_addcolor)
	w.funcs[:lib3mf_colorgroup_removecolor] = Libdl.dlsym(w.lib, :lib3mf_colorgroup_removecolor)
	w.funcs[:lib3mf_colorgroup_setcolor] = Libdl.dlsym(w.lib, :lib3mf_colorgroup_setcolor)
	w.funcs[:lib3mf_colorgroup_getcolor] = Libdl.dlsym(w.lib, :lib3mf_colorgroup_getcolor)
	w.funcs[:lib3mf_texture2dgroup_getcount] = Libdl.dlsym(w.lib, :lib3mf_texture2dgroup_getcount)
	w.funcs[:lib3mf_texture2dgroup_getallpropertyids] = Libdl.dlsym(w.lib, :lib3mf_texture2dgroup_getallpropertyids)
	w.funcs[:lib3mf_texture2dgroup_addtex2coord] = Libdl.dlsym(w.lib, :lib3mf_texture2dgroup_addtex2coord)
	w.funcs[:lib3mf_texture2dgroup_gettex2coord] = Libdl.dlsym(w.lib, :lib3mf_texture2dgroup_gettex2coord)
	w.funcs[:lib3mf_texture2dgroup_removetex2coord] = Libdl.dlsym(w.lib, :lib3mf_texture2dgroup_removetex2coord)
	w.funcs[:lib3mf_texture2dgroup_gettexture2d] = Libdl.dlsym(w.lib, :lib3mf_texture2dgroup_gettexture2d)
	w.funcs[:lib3mf_compositematerials_getcount] = Libdl.dlsym(w.lib, :lib3mf_compositematerials_getcount)
	w.funcs[:lib3mf_compositematerials_getallpropertyids] = Libdl.dlsym(w.lib, :lib3mf_compositematerials_getallpropertyids)
	w.funcs[:lib3mf_compositematerials_getbasematerialgroup] = Libdl.dlsym(w.lib, :lib3mf_compositematerials_getbasematerialgroup)
	w.funcs[:lib3mf_compositematerials_addcomposite] = Libdl.dlsym(w.lib, :lib3mf_compositematerials_addcomposite)
	w.funcs[:lib3mf_compositematerials_removecomposite] = Libdl.dlsym(w.lib, :lib3mf_compositematerials_removecomposite)
	w.funcs[:lib3mf_compositematerials_getcomposite] = Libdl.dlsym(w.lib, :lib3mf_compositematerials_getcomposite)
	w.funcs[:lib3mf_multipropertygroup_getcount] = Libdl.dlsym(w.lib, :lib3mf_multipropertygroup_getcount)
	w.funcs[:lib3mf_multipropertygroup_getallpropertyids] = Libdl.dlsym(w.lib, :lib3mf_multipropertygroup_getallpropertyids)
	w.funcs[:lib3mf_multipropertygroup_addmultiproperty] = Libdl.dlsym(w.lib, :lib3mf_multipropertygroup_addmultiproperty)
	w.funcs[:lib3mf_multipropertygroup_setmultiproperty] = Libdl.dlsym(w.lib, :lib3mf_multipropertygroup_setmultiproperty)
	w.funcs[:lib3mf_multipropertygroup_getmultiproperty] = Libdl.dlsym(w.lib, :lib3mf_multipropertygroup_getmultiproperty)
	w.funcs[:lib3mf_multipropertygroup_removemultiproperty] = Libdl.dlsym(w.lib, :lib3mf_multipropertygroup_removemultiproperty)
	w.funcs[:lib3mf_multipropertygroup_getlayercount] = Libdl.dlsym(w.lib, :lib3mf_multipropertygroup_getlayercount)
	w.funcs[:lib3mf_multipropertygroup_addlayer] = Libdl.dlsym(w.lib, :lib3mf_multipropertygroup_addlayer)
	w.funcs[:lib3mf_multipropertygroup_getlayer] = Libdl.dlsym(w.lib, :lib3mf_multipropertygroup_getlayer)
	w.funcs[:lib3mf_multipropertygroup_removelayer] = Libdl.dlsym(w.lib, :lib3mf_multipropertygroup_removelayer)
	w.funcs[:lib3mf_image3d_getname] = Libdl.dlsym(w.lib, :lib3mf_image3d_getname)
	w.funcs[:lib3mf_image3d_setname] = Libdl.dlsym(w.lib, :lib3mf_image3d_setname)
	w.funcs[:lib3mf_image3d_isimagestack] = Libdl.dlsym(w.lib, :lib3mf_image3d_isimagestack)
	w.funcs[:lib3mf_imagestack_getrowcount] = Libdl.dlsym(w.lib, :lib3mf_imagestack_getrowcount)
	w.funcs[:lib3mf_imagestack_setrowcount] = Libdl.dlsym(w.lib, :lib3mf_imagestack_setrowcount)
	w.funcs[:lib3mf_imagestack_getcolumncount] = Libdl.dlsym(w.lib, :lib3mf_imagestack_getcolumncount)
	w.funcs[:lib3mf_imagestack_setcolumncount] = Libdl.dlsym(w.lib, :lib3mf_imagestack_setcolumncount)
	w.funcs[:lib3mf_imagestack_getsheetcount] = Libdl.dlsym(w.lib, :lib3mf_imagestack_getsheetcount)
	w.funcs[:lib3mf_imagestack_getsheet] = Libdl.dlsym(w.lib, :lib3mf_imagestack_getsheet)
	w.funcs[:lib3mf_imagestack_setsheet] = Libdl.dlsym(w.lib, :lib3mf_imagestack_setsheet)
	w.funcs[:lib3mf_imagestack_createemptysheet] = Libdl.dlsym(w.lib, :lib3mf_imagestack_createemptysheet)
	w.funcs[:lib3mf_imagestack_createsheetfrombuffer] = Libdl.dlsym(w.lib, :lib3mf_imagestack_createsheetfrombuffer)
	w.funcs[:lib3mf_imagestack_createsheetfromfile] = Libdl.dlsym(w.lib, :lib3mf_imagestack_createsheetfromfile)
	w.funcs[:lib3mf_attachment_getpath] = Libdl.dlsym(w.lib, :lib3mf_attachment_getpath)
	w.funcs[:lib3mf_attachment_setpath] = Libdl.dlsym(w.lib, :lib3mf_attachment_setpath)
	w.funcs[:lib3mf_attachment_packagepart] = Libdl.dlsym(w.lib, :lib3mf_attachment_packagepart)
	w.funcs[:lib3mf_attachment_getrelationshiptype] = Libdl.dlsym(w.lib, :lib3mf_attachment_getrelationshiptype)
	w.funcs[:lib3mf_attachment_setrelationshiptype] = Libdl.dlsym(w.lib, :lib3mf_attachment_setrelationshiptype)
	w.funcs[:lib3mf_attachment_writetofile] = Libdl.dlsym(w.lib, :lib3mf_attachment_writetofile)
	w.funcs[:lib3mf_attachment_readfromfile] = Libdl.dlsym(w.lib, :lib3mf_attachment_readfromfile)
	w.funcs[:lib3mf_attachment_readfromcallback] = Libdl.dlsym(w.lib, :lib3mf_attachment_readfromcallback)
	w.funcs[:lib3mf_attachment_getstreamsize] = Libdl.dlsym(w.lib, :lib3mf_attachment_getstreamsize)
	w.funcs[:lib3mf_attachment_writetobuffer] = Libdl.dlsym(w.lib, :lib3mf_attachment_writetobuffer)
	w.funcs[:lib3mf_attachment_readfrombuffer] = Libdl.dlsym(w.lib, :lib3mf_attachment_readfrombuffer)
	w.funcs[:lib3mf_texture2d_getattachment] = Libdl.dlsym(w.lib, :lib3mf_texture2d_getattachment)
	w.funcs[:lib3mf_texture2d_setattachment] = Libdl.dlsym(w.lib, :lib3mf_texture2d_setattachment)
	w.funcs[:lib3mf_texture2d_getcontenttype] = Libdl.dlsym(w.lib, :lib3mf_texture2d_getcontenttype)
	w.funcs[:lib3mf_texture2d_setcontenttype] = Libdl.dlsym(w.lib, :lib3mf_texture2d_setcontenttype)
	w.funcs[:lib3mf_texture2d_gettilestyleuv] = Libdl.dlsym(w.lib, :lib3mf_texture2d_gettilestyleuv)
	w.funcs[:lib3mf_texture2d_settilestyleuv] = Libdl.dlsym(w.lib, :lib3mf_texture2d_settilestyleuv)
	w.funcs[:lib3mf_texture2d_getfilter] = Libdl.dlsym(w.lib, :lib3mf_texture2d_getfilter)
	w.funcs[:lib3mf_texture2d_setfilter] = Libdl.dlsym(w.lib, :lib3mf_texture2d_setfilter)
	w.funcs[:lib3mf_implicitport_getidentifier] = Libdl.dlsym(w.lib, :lib3mf_implicitport_getidentifier)
	w.funcs[:lib3mf_implicitport_setidentifier] = Libdl.dlsym(w.lib, :lib3mf_implicitport_setidentifier)
	w.funcs[:lib3mf_implicitport_getdisplayname] = Libdl.dlsym(w.lib, :lib3mf_implicitport_getdisplayname)
	w.funcs[:lib3mf_implicitport_setdisplayname] = Libdl.dlsym(w.lib, :lib3mf_implicitport_setdisplayname)
	w.funcs[:lib3mf_implicitport_settype] = Libdl.dlsym(w.lib, :lib3mf_implicitport_settype)
	w.funcs[:lib3mf_implicitport_gettype] = Libdl.dlsym(w.lib, :lib3mf_implicitport_gettype)
	w.funcs[:lib3mf_implicitport_getreference] = Libdl.dlsym(w.lib, :lib3mf_implicitport_getreference)
	w.funcs[:lib3mf_implicitport_setreference] = Libdl.dlsym(w.lib, :lib3mf_implicitport_setreference)
	w.funcs[:lib3mf_iterator_movenext] = Libdl.dlsym(w.lib, :lib3mf_iterator_movenext)
	w.funcs[:lib3mf_iterator_moveprevious] = Libdl.dlsym(w.lib, :lib3mf_iterator_moveprevious)
	w.funcs[:lib3mf_iterator_count] = Libdl.dlsym(w.lib, :lib3mf_iterator_count)
	w.funcs[:lib3mf_implicitportiterator_getcurrent] = Libdl.dlsym(w.lib, :lib3mf_implicitportiterator_getcurrent)
	w.funcs[:lib3mf_implicitnode_getidentifier] = Libdl.dlsym(w.lib, :lib3mf_implicitnode_getidentifier)
	w.funcs[:lib3mf_implicitnode_setidentifier] = Libdl.dlsym(w.lib, :lib3mf_implicitnode_setidentifier)
	w.funcs[:lib3mf_implicitnode_getdisplayname] = Libdl.dlsym(w.lib, :lib3mf_implicitnode_getdisplayname)
	w.funcs[:lib3mf_implicitnode_setdisplayname] = Libdl.dlsym(w.lib, :lib3mf_implicitnode_setdisplayname)
	w.funcs[:lib3mf_implicitnode_gettag] = Libdl.dlsym(w.lib, :lib3mf_implicitnode_gettag)
	w.funcs[:lib3mf_implicitnode_settag] = Libdl.dlsym(w.lib, :lib3mf_implicitnode_settag)
	w.funcs[:lib3mf_implicitnode_getnodetype] = Libdl.dlsym(w.lib, :lib3mf_implicitnode_getnodetype)
	w.funcs[:lib3mf_implicitnode_addinput] = Libdl.dlsym(w.lib, :lib3mf_implicitnode_addinput)
	w.funcs[:lib3mf_implicitnode_getinputs] = Libdl.dlsym(w.lib, :lib3mf_implicitnode_getinputs)
	w.funcs[:lib3mf_implicitnode_addoutput] = Libdl.dlsym(w.lib, :lib3mf_implicitnode_addoutput)
	w.funcs[:lib3mf_implicitnode_getoutputs] = Libdl.dlsym(w.lib, :lib3mf_implicitnode_getoutputs)
	w.funcs[:lib3mf_implicitnode_findinput] = Libdl.dlsym(w.lib, :lib3mf_implicitnode_findinput)
	w.funcs[:lib3mf_implicitnode_findoutput] = Libdl.dlsym(w.lib, :lib3mf_implicitnode_findoutput)
	w.funcs[:lib3mf_implicitnode_aretypesvalid] = Libdl.dlsym(w.lib, :lib3mf_implicitnode_aretypesvalid)
	w.funcs[:lib3mf_oneinputnode_getinputa] = Libdl.dlsym(w.lib, :lib3mf_oneinputnode_getinputa)
	w.funcs[:lib3mf_oneinputnode_getoutputresult] = Libdl.dlsym(w.lib, :lib3mf_oneinputnode_getoutputresult)
	w.funcs[:lib3mf_resourceidnode_setresource] = Libdl.dlsym(w.lib, :lib3mf_resourceidnode_setresource)
	w.funcs[:lib3mf_resourceidnode_getresource] = Libdl.dlsym(w.lib, :lib3mf_resourceidnode_getresource)
	w.funcs[:lib3mf_resourceidnode_getoutputvalue] = Libdl.dlsym(w.lib, :lib3mf_resourceidnode_getoutputvalue)
	w.funcs[:lib3mf_twoinputnode_getinputb] = Libdl.dlsym(w.lib, :lib3mf_twoinputnode_getinputb)
	w.funcs[:lib3mf_selectnode_getinputb] = Libdl.dlsym(w.lib, :lib3mf_selectnode_getinputb)
	w.funcs[:lib3mf_selectnode_getinputc] = Libdl.dlsym(w.lib, :lib3mf_selectnode_getinputc)
	w.funcs[:lib3mf_selectnode_getinputd] = Libdl.dlsym(w.lib, :lib3mf_selectnode_getinputd)
	w.funcs[:lib3mf_clampnode_getinputmin] = Libdl.dlsym(w.lib, :lib3mf_clampnode_getinputmin)
	w.funcs[:lib3mf_clampnode_getinputmax] = Libdl.dlsym(w.lib, :lib3mf_clampnode_getinputmax)
	w.funcs[:lib3mf_composevectornode_getinputx] = Libdl.dlsym(w.lib, :lib3mf_composevectornode_getinputx)
	w.funcs[:lib3mf_composevectornode_getinputy] = Libdl.dlsym(w.lib, :lib3mf_composevectornode_getinputy)
	w.funcs[:lib3mf_composevectornode_getinputz] = Libdl.dlsym(w.lib, :lib3mf_composevectornode_getinputz)
	w.funcs[:lib3mf_composevectornode_getoutputresult] = Libdl.dlsym(w.lib, :lib3mf_composevectornode_getoutputresult)
	w.funcs[:lib3mf_decomposevectornode_getinputa] = Libdl.dlsym(w.lib, :lib3mf_decomposevectornode_getinputa)
	w.funcs[:lib3mf_decomposevectornode_getoutputx] = Libdl.dlsym(w.lib, :lib3mf_decomposevectornode_getoutputx)
	w.funcs[:lib3mf_decomposevectornode_getoutputy] = Libdl.dlsym(w.lib, :lib3mf_decomposevectornode_getoutputy)
	w.funcs[:lib3mf_decomposevectornode_getoutputz] = Libdl.dlsym(w.lib, :lib3mf_decomposevectornode_getoutputz)
	w.funcs[:lib3mf_composematrixnode_getinputm00] = Libdl.dlsym(w.lib, :lib3mf_composematrixnode_getinputm00)
	w.funcs[:lib3mf_composematrixnode_getinputm01] = Libdl.dlsym(w.lib, :lib3mf_composematrixnode_getinputm01)
	w.funcs[:lib3mf_composematrixnode_getinputm02] = Libdl.dlsym(w.lib, :lib3mf_composematrixnode_getinputm02)
	w.funcs[:lib3mf_composematrixnode_getinputm03] = Libdl.dlsym(w.lib, :lib3mf_composematrixnode_getinputm03)
	w.funcs[:lib3mf_composematrixnode_getinputm10] = Libdl.dlsym(w.lib, :lib3mf_composematrixnode_getinputm10)
	w.funcs[:lib3mf_composematrixnode_getinputm11] = Libdl.dlsym(w.lib, :lib3mf_composematrixnode_getinputm11)
	w.funcs[:lib3mf_composematrixnode_getinputm12] = Libdl.dlsym(w.lib, :lib3mf_composematrixnode_getinputm12)
	w.funcs[:lib3mf_composematrixnode_getinputm13] = Libdl.dlsym(w.lib, :lib3mf_composematrixnode_getinputm13)
	w.funcs[:lib3mf_composematrixnode_getinputm20] = Libdl.dlsym(w.lib, :lib3mf_composematrixnode_getinputm20)
	w.funcs[:lib3mf_composematrixnode_getinputm21] = Libdl.dlsym(w.lib, :lib3mf_composematrixnode_getinputm21)
	w.funcs[:lib3mf_composematrixnode_getinputm22] = Libdl.dlsym(w.lib, :lib3mf_composematrixnode_getinputm22)
	w.funcs[:lib3mf_composematrixnode_getinputm23] = Libdl.dlsym(w.lib, :lib3mf_composematrixnode_getinputm23)
	w.funcs[:lib3mf_composematrixnode_getinputm30] = Libdl.dlsym(w.lib, :lib3mf_composematrixnode_getinputm30)
	w.funcs[:lib3mf_composematrixnode_getinputm31] = Libdl.dlsym(w.lib, :lib3mf_composematrixnode_getinputm31)
	w.funcs[:lib3mf_composematrixnode_getinputm32] = Libdl.dlsym(w.lib, :lib3mf_composematrixnode_getinputm32)
	w.funcs[:lib3mf_composematrixnode_getinputm33] = Libdl.dlsym(w.lib, :lib3mf_composematrixnode_getinputm33)
	w.funcs[:lib3mf_composematrixnode_getoutputresult] = Libdl.dlsym(w.lib, :lib3mf_composematrixnode_getoutputresult)
	w.funcs[:lib3mf_matrixfromrowsnode_getinputa] = Libdl.dlsym(w.lib, :lib3mf_matrixfromrowsnode_getinputa)
	w.funcs[:lib3mf_matrixfromrowsnode_getinputb] = Libdl.dlsym(w.lib, :lib3mf_matrixfromrowsnode_getinputb)
	w.funcs[:lib3mf_matrixfromrowsnode_getinputc] = Libdl.dlsym(w.lib, :lib3mf_matrixfromrowsnode_getinputc)
	w.funcs[:lib3mf_matrixfromrowsnode_getinputd] = Libdl.dlsym(w.lib, :lib3mf_matrixfromrowsnode_getinputd)
	w.funcs[:lib3mf_matrixfromrowsnode_getoutputresult] = Libdl.dlsym(w.lib, :lib3mf_matrixfromrowsnode_getoutputresult)
	w.funcs[:lib3mf_matrixfromcolumnsnode_getinputa] = Libdl.dlsym(w.lib, :lib3mf_matrixfromcolumnsnode_getinputa)
	w.funcs[:lib3mf_matrixfromcolumnsnode_getinputb] = Libdl.dlsym(w.lib, :lib3mf_matrixfromcolumnsnode_getinputb)
	w.funcs[:lib3mf_matrixfromcolumnsnode_getinputc] = Libdl.dlsym(w.lib, :lib3mf_matrixfromcolumnsnode_getinputc)
	w.funcs[:lib3mf_matrixfromcolumnsnode_getinputd] = Libdl.dlsym(w.lib, :lib3mf_matrixfromcolumnsnode_getinputd)
	w.funcs[:lib3mf_matrixfromcolumnsnode_getoutputresult] = Libdl.dlsym(w.lib, :lib3mf_matrixfromcolumnsnode_getoutputresult)
	w.funcs[:lib3mf_constantnode_setconstant] = Libdl.dlsym(w.lib, :lib3mf_constantnode_setconstant)
	w.funcs[:lib3mf_constantnode_getconstant] = Libdl.dlsym(w.lib, :lib3mf_constantnode_getconstant)
	w.funcs[:lib3mf_constantnode_getoutputvalue] = Libdl.dlsym(w.lib, :lib3mf_constantnode_getoutputvalue)
	w.funcs[:lib3mf_constvecnode_setvector] = Libdl.dlsym(w.lib, :lib3mf_constvecnode_setvector)
	w.funcs[:lib3mf_constvecnode_getvector] = Libdl.dlsym(w.lib, :lib3mf_constvecnode_getvector)
	w.funcs[:lib3mf_constvecnode_getoutputvector] = Libdl.dlsym(w.lib, :lib3mf_constvecnode_getoutputvector)
	w.funcs[:lib3mf_constmatnode_setmatrix] = Libdl.dlsym(w.lib, :lib3mf_constmatnode_setmatrix)
	w.funcs[:lib3mf_constmatnode_getmatrix] = Libdl.dlsym(w.lib, :lib3mf_constmatnode_getmatrix)
	w.funcs[:lib3mf_constmatnode_getoutputmatrix] = Libdl.dlsym(w.lib, :lib3mf_constmatnode_getoutputmatrix)
	w.funcs[:lib3mf_meshnode_getinputmesh] = Libdl.dlsym(w.lib, :lib3mf_meshnode_getinputmesh)
	w.funcs[:lib3mf_meshnode_getinputpos] = Libdl.dlsym(w.lib, :lib3mf_meshnode_getinputpos)
	w.funcs[:lib3mf_meshnode_getoutputdistance] = Libdl.dlsym(w.lib, :lib3mf_meshnode_getoutputdistance)
	w.funcs[:lib3mf_unsignedmeshnode_getinputmesh] = Libdl.dlsym(w.lib, :lib3mf_unsignedmeshnode_getinputmesh)
	w.funcs[:lib3mf_unsignedmeshnode_getinputpos] = Libdl.dlsym(w.lib, :lib3mf_unsignedmeshnode_getinputpos)
	w.funcs[:lib3mf_unsignedmeshnode_getoutputdistance] = Libdl.dlsym(w.lib, :lib3mf_unsignedmeshnode_getoutputdistance)
	w.funcs[:lib3mf_beamlatticenode_getinputbeamlattice] = Libdl.dlsym(w.lib, :lib3mf_beamlatticenode_getinputbeamlattice)
	w.funcs[:lib3mf_beamlatticenode_getinputpos] = Libdl.dlsym(w.lib, :lib3mf_beamlatticenode_getinputpos)
	w.funcs[:lib3mf_beamlatticenode_getoutputdistance] = Libdl.dlsym(w.lib, :lib3mf_beamlatticenode_getoutputdistance)
	w.funcs[:lib3mf_beamlatticenode_setaccuraterange] = Libdl.dlsym(w.lib, :lib3mf_beamlatticenode_setaccuraterange)
	w.funcs[:lib3mf_beamlatticenode_getaccuraterange] = Libdl.dlsym(w.lib, :lib3mf_beamlatticenode_getaccuraterange)
	w.funcs[:lib3mf_functiongradientnode_getinputfunctionid] = Libdl.dlsym(w.lib, :lib3mf_functiongradientnode_getinputfunctionid)
	w.funcs[:lib3mf_functiongradientnode_getinputpos] = Libdl.dlsym(w.lib, :lib3mf_functiongradientnode_getinputpos)
	w.funcs[:lib3mf_functiongradientnode_getinputstep] = Libdl.dlsym(w.lib, :lib3mf_functiongradientnode_getinputstep)
	w.funcs[:lib3mf_functiongradientnode_setscalaroutputname] = Libdl.dlsym(w.lib, :lib3mf_functiongradientnode_setscalaroutputname)
	w.funcs[:lib3mf_functiongradientnode_getscalaroutputname] = Libdl.dlsym(w.lib, :lib3mf_functiongradientnode_getscalaroutputname)
	w.funcs[:lib3mf_functiongradientnode_setvectorinputname] = Libdl.dlsym(w.lib, :lib3mf_functiongradientnode_setvectorinputname)
	w.funcs[:lib3mf_functiongradientnode_getvectorinputname] = Libdl.dlsym(w.lib, :lib3mf_functiongradientnode_getvectorinputname)
	w.funcs[:lib3mf_functiongradientnode_getoutputnormalizedgradient] = Libdl.dlsym(w.lib, :lib3mf_functiongradientnode_getoutputnormalizedgradient)
	w.funcs[:lib3mf_functiongradientnode_getoutputgradient] = Libdl.dlsym(w.lib, :lib3mf_functiongradientnode_getoutputgradient)
	w.funcs[:lib3mf_functiongradientnode_getoutputmagnitude] = Libdl.dlsym(w.lib, :lib3mf_functiongradientnode_getoutputmagnitude)
	w.funcs[:lib3mf_normalizedistancenode_getinputfunctionid] = Libdl.dlsym(w.lib, :lib3mf_normalizedistancenode_getinputfunctionid)
	w.funcs[:lib3mf_normalizedistancenode_getinputpos] = Libdl.dlsym(w.lib, :lib3mf_normalizedistancenode_getinputpos)
	w.funcs[:lib3mf_normalizedistancenode_getinputstep] = Libdl.dlsym(w.lib, :lib3mf_normalizedistancenode_getinputstep)
	w.funcs[:lib3mf_normalizedistancenode_setscalaroutputname] = Libdl.dlsym(w.lib, :lib3mf_normalizedistancenode_setscalaroutputname)
	w.funcs[:lib3mf_normalizedistancenode_getscalaroutputname] = Libdl.dlsym(w.lib, :lib3mf_normalizedistancenode_getscalaroutputname)
	w.funcs[:lib3mf_normalizedistancenode_setvectorinputname] = Libdl.dlsym(w.lib, :lib3mf_normalizedistancenode_setvectorinputname)
	w.funcs[:lib3mf_normalizedistancenode_getvectorinputname] = Libdl.dlsym(w.lib, :lib3mf_normalizedistancenode_getvectorinputname)
	w.funcs[:lib3mf_normalizedistancenode_getoutputresult] = Libdl.dlsym(w.lib, :lib3mf_normalizedistancenode_getoutputresult)
	w.funcs[:lib3mf_functioncallnode_getinputfunctionid] = Libdl.dlsym(w.lib, :lib3mf_functioncallnode_getinputfunctionid)
	w.funcs[:lib3mf_nodeiterator_getcurrent] = Libdl.dlsym(w.lib, :lib3mf_nodeiterator_getcurrent)
	w.funcs[:lib3mf_function_getdisplayname] = Libdl.dlsym(w.lib, :lib3mf_function_getdisplayname)
	w.funcs[:lib3mf_function_setdisplayname] = Libdl.dlsym(w.lib, :lib3mf_function_setdisplayname)
	w.funcs[:lib3mf_function_addinput] = Libdl.dlsym(w.lib, :lib3mf_function_addinput)
	w.funcs[:lib3mf_function_getinputs] = Libdl.dlsym(w.lib, :lib3mf_function_getinputs)
	w.funcs[:lib3mf_function_removeinput] = Libdl.dlsym(w.lib, :lib3mf_function_removeinput)
	w.funcs[:lib3mf_function_addoutput] = Libdl.dlsym(w.lib, :lib3mf_function_addoutput)
	w.funcs[:lib3mf_function_getoutputs] = Libdl.dlsym(w.lib, :lib3mf_function_getoutputs)
	w.funcs[:lib3mf_function_removeoutput] = Libdl.dlsym(w.lib, :lib3mf_function_removeoutput)
	w.funcs[:lib3mf_function_findinput] = Libdl.dlsym(w.lib, :lib3mf_function_findinput)
	w.funcs[:lib3mf_function_findoutput] = Libdl.dlsym(w.lib, :lib3mf_function_findoutput)
	w.funcs[:lib3mf_implicitfunction_getidentifier] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_getidentifier)
	w.funcs[:lib3mf_implicitfunction_setidentifier] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_setidentifier)
	w.funcs[:lib3mf_implicitfunction_addnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addnode)
	w.funcs[:lib3mf_implicitfunction_addsinnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addsinnode)
	w.funcs[:lib3mf_implicitfunction_addcosnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addcosnode)
	w.funcs[:lib3mf_implicitfunction_addtannode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addtannode)
	w.funcs[:lib3mf_implicitfunction_addarcsinnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addarcsinnode)
	w.funcs[:lib3mf_implicitfunction_addarccosnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addarccosnode)
	w.funcs[:lib3mf_implicitfunction_addarctan2node] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addarctan2node)
	w.funcs[:lib3mf_implicitfunction_addsinhnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addsinhnode)
	w.funcs[:lib3mf_implicitfunction_addcoshnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addcoshnode)
	w.funcs[:lib3mf_implicitfunction_addtanhnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addtanhnode)
	w.funcs[:lib3mf_implicitfunction_addroundnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addroundnode)
	w.funcs[:lib3mf_implicitfunction_addceilnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addceilnode)
	w.funcs[:lib3mf_implicitfunction_addfloornode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addfloornode)
	w.funcs[:lib3mf_implicitfunction_addsignnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addsignnode)
	w.funcs[:lib3mf_implicitfunction_addfractnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addfractnode)
	w.funcs[:lib3mf_implicitfunction_addabsnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addabsnode)
	w.funcs[:lib3mf_implicitfunction_addexpnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addexpnode)
	w.funcs[:lib3mf_implicitfunction_addlognode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addlognode)
	w.funcs[:lib3mf_implicitfunction_addlog2node] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addlog2node)
	w.funcs[:lib3mf_implicitfunction_addlog10node] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addlog10node)
	w.funcs[:lib3mf_implicitfunction_addlengthnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addlengthnode)
	w.funcs[:lib3mf_implicitfunction_addtransposenode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addtransposenode)
	w.funcs[:lib3mf_implicitfunction_addinversenode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addinversenode)
	w.funcs[:lib3mf_implicitfunction_addsqrtnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addsqrtnode)
	w.funcs[:lib3mf_implicitfunction_addresourceidnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addresourceidnode)
	w.funcs[:lib3mf_implicitfunction_addadditionnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addadditionnode)
	w.funcs[:lib3mf_implicitfunction_addsubtractionnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addsubtractionnode)
	w.funcs[:lib3mf_implicitfunction_addmultiplicationnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addmultiplicationnode)
	w.funcs[:lib3mf_implicitfunction_adddivisionnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_adddivisionnode)
	w.funcs[:lib3mf_implicitfunction_adddotnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_adddotnode)
	w.funcs[:lib3mf_implicitfunction_addcrossnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addcrossnode)
	w.funcs[:lib3mf_implicitfunction_addmatvecmultiplicationnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addmatvecmultiplicationnode)
	w.funcs[:lib3mf_implicitfunction_addminnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addminnode)
	w.funcs[:lib3mf_implicitfunction_addmaxnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addmaxnode)
	w.funcs[:lib3mf_implicitfunction_addfmodnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addfmodnode)
	w.funcs[:lib3mf_implicitfunction_addpownode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addpownode)
	w.funcs[:lib3mf_implicitfunction_addselectnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addselectnode)
	w.funcs[:lib3mf_implicitfunction_addclampnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addclampnode)
	w.funcs[:lib3mf_implicitfunction_addcomposevectornode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addcomposevectornode)
	w.funcs[:lib3mf_implicitfunction_addvectorfromscalarnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addvectorfromscalarnode)
	w.funcs[:lib3mf_implicitfunction_adddecomposevectornode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_adddecomposevectornode)
	w.funcs[:lib3mf_implicitfunction_addcomposematrixnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addcomposematrixnode)
	w.funcs[:lib3mf_implicitfunction_addmatrixfromrowsnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addmatrixfromrowsnode)
	w.funcs[:lib3mf_implicitfunction_addmatrixfromcolumnsnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addmatrixfromcolumnsnode)
	w.funcs[:lib3mf_implicitfunction_addconstantnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addconstantnode)
	w.funcs[:lib3mf_implicitfunction_addconstvecnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addconstvecnode)
	w.funcs[:lib3mf_implicitfunction_addconstmatnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addconstmatnode)
	w.funcs[:lib3mf_implicitfunction_addmeshnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addmeshnode)
	w.funcs[:lib3mf_implicitfunction_addunsignedmeshnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addunsignedmeshnode)
	w.funcs[:lib3mf_implicitfunction_addbeamlatticenode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addbeamlatticenode)
	w.funcs[:lib3mf_implicitfunction_addfunctiongradientnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addfunctiongradientnode)
	w.funcs[:lib3mf_implicitfunction_addnormalizedistancenode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addnormalizedistancenode)
	w.funcs[:lib3mf_implicitfunction_addfunctioncallnode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addfunctioncallnode)
	w.funcs[:lib3mf_implicitfunction_getnodes] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_getnodes)
	w.funcs[:lib3mf_implicitfunction_removenode] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_removenode)
	w.funcs[:lib3mf_implicitfunction_addlink] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addlink)
	w.funcs[:lib3mf_implicitfunction_addlinkbynames] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_addlinkbynames)
	w.funcs[:lib3mf_implicitfunction_clear] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_clear)
	w.funcs[:lib3mf_implicitfunction_sortnodestopologically] = Libdl.dlsym(w.lib, :lib3mf_implicitfunction_sortnodestopologically)
	w.funcs[:lib3mf_functionfromimage3d_getimage3d] = Libdl.dlsym(w.lib, :lib3mf_functionfromimage3d_getimage3d)
	w.funcs[:lib3mf_functionfromimage3d_setimage3d] = Libdl.dlsym(w.lib, :lib3mf_functionfromimage3d_setimage3d)
	w.funcs[:lib3mf_functionfromimage3d_setfilter] = Libdl.dlsym(w.lib, :lib3mf_functionfromimage3d_setfilter)
	w.funcs[:lib3mf_functionfromimage3d_getfilter] = Libdl.dlsym(w.lib, :lib3mf_functionfromimage3d_getfilter)
	w.funcs[:lib3mf_functionfromimage3d_settilestyles] = Libdl.dlsym(w.lib, :lib3mf_functionfromimage3d_settilestyles)
	w.funcs[:lib3mf_functionfromimage3d_gettilestyles] = Libdl.dlsym(w.lib, :lib3mf_functionfromimage3d_gettilestyles)
	w.funcs[:lib3mf_functionfromimage3d_getoffset] = Libdl.dlsym(w.lib, :lib3mf_functionfromimage3d_getoffset)
	w.funcs[:lib3mf_functionfromimage3d_setoffset] = Libdl.dlsym(w.lib, :lib3mf_functionfromimage3d_setoffset)
	w.funcs[:lib3mf_functionfromimage3d_getscale] = Libdl.dlsym(w.lib, :lib3mf_functionfromimage3d_getscale)
	w.funcs[:lib3mf_functionfromimage3d_setscale] = Libdl.dlsym(w.lib, :lib3mf_functionfromimage3d_setscale)
	w.funcs[:lib3mf_builditem_getobjectresource] = Libdl.dlsym(w.lib, :lib3mf_builditem_getobjectresource)
	w.funcs[:lib3mf_builditem_getuuid] = Libdl.dlsym(w.lib, :lib3mf_builditem_getuuid)
	w.funcs[:lib3mf_builditem_setuuid] = Libdl.dlsym(w.lib, :lib3mf_builditem_setuuid)
	w.funcs[:lib3mf_builditem_getobjectresourceid] = Libdl.dlsym(w.lib, :lib3mf_builditem_getobjectresourceid)
	w.funcs[:lib3mf_builditem_hasobjecttransform] = Libdl.dlsym(w.lib, :lib3mf_builditem_hasobjecttransform)
	w.funcs[:lib3mf_builditem_getobjecttransform] = Libdl.dlsym(w.lib, :lib3mf_builditem_getobjecttransform)
	w.funcs[:lib3mf_builditem_setobjecttransform] = Libdl.dlsym(w.lib, :lib3mf_builditem_setobjecttransform)
	w.funcs[:lib3mf_builditem_getpartnumber] = Libdl.dlsym(w.lib, :lib3mf_builditem_getpartnumber)
	w.funcs[:lib3mf_builditem_setpartnumber] = Libdl.dlsym(w.lib, :lib3mf_builditem_setpartnumber)
	w.funcs[:lib3mf_builditem_getmetadatagroup] = Libdl.dlsym(w.lib, :lib3mf_builditem_getmetadatagroup)
	w.funcs[:lib3mf_builditem_getoutbox] = Libdl.dlsym(w.lib, :lib3mf_builditem_getoutbox)
	w.funcs[:lib3mf_builditemiterator_movenext] = Libdl.dlsym(w.lib, :lib3mf_builditemiterator_movenext)
	w.funcs[:lib3mf_builditemiterator_moveprevious] = Libdl.dlsym(w.lib, :lib3mf_builditemiterator_moveprevious)
	w.funcs[:lib3mf_builditemiterator_getcurrent] = Libdl.dlsym(w.lib, :lib3mf_builditemiterator_getcurrent)
	w.funcs[:lib3mf_builditemiterator_clone] = Libdl.dlsym(w.lib, :lib3mf_builditemiterator_clone)
	w.funcs[:lib3mf_builditemiterator_count] = Libdl.dlsym(w.lib, :lib3mf_builditemiterator_count)
	w.funcs[:lib3mf_slice_setvertices] = Libdl.dlsym(w.lib, :lib3mf_slice_setvertices)
	w.funcs[:lib3mf_slice_getvertices] = Libdl.dlsym(w.lib, :lib3mf_slice_getvertices)
	w.funcs[:lib3mf_slice_getvertexcount] = Libdl.dlsym(w.lib, :lib3mf_slice_getvertexcount)
	w.funcs[:lib3mf_slice_addpolygon] = Libdl.dlsym(w.lib, :lib3mf_slice_addpolygon)
	w.funcs[:lib3mf_slice_getpolygoncount] = Libdl.dlsym(w.lib, :lib3mf_slice_getpolygoncount)
	w.funcs[:lib3mf_slice_setpolygonindices] = Libdl.dlsym(w.lib, :lib3mf_slice_setpolygonindices)
	w.funcs[:lib3mf_slice_getpolygonindices] = Libdl.dlsym(w.lib, :lib3mf_slice_getpolygonindices)
	w.funcs[:lib3mf_slice_getpolygonindexcount] = Libdl.dlsym(w.lib, :lib3mf_slice_getpolygonindexcount)
	w.funcs[:lib3mf_slice_getztop] = Libdl.dlsym(w.lib, :lib3mf_slice_getztop)
	w.funcs[:lib3mf_slicestack_getbottomz] = Libdl.dlsym(w.lib, :lib3mf_slicestack_getbottomz)
	w.funcs[:lib3mf_slicestack_getslicecount] = Libdl.dlsym(w.lib, :lib3mf_slicestack_getslicecount)
	w.funcs[:lib3mf_slicestack_getslice] = Libdl.dlsym(w.lib, :lib3mf_slicestack_getslice)
	w.funcs[:lib3mf_slicestack_addslice] = Libdl.dlsym(w.lib, :lib3mf_slicestack_addslice)
	w.funcs[:lib3mf_slicestack_getslicerefcount] = Libdl.dlsym(w.lib, :lib3mf_slicestack_getslicerefcount)
	w.funcs[:lib3mf_slicestack_addslicestackreference] = Libdl.dlsym(w.lib, :lib3mf_slicestack_addslicestackreference)
	w.funcs[:lib3mf_slicestack_getslicestackreference] = Libdl.dlsym(w.lib, :lib3mf_slicestack_getslicestackreference)
	w.funcs[:lib3mf_slicestack_collapseslicereferences] = Libdl.dlsym(w.lib, :lib3mf_slicestack_collapseslicereferences)
	w.funcs[:lib3mf_slicestack_setownpath] = Libdl.dlsym(w.lib, :lib3mf_slicestack_setownpath)
	w.funcs[:lib3mf_slicestack_getownpath] = Libdl.dlsym(w.lib, :lib3mf_slicestack_getownpath)
	w.funcs[:lib3mf_consumer_getconsumerid] = Libdl.dlsym(w.lib, :lib3mf_consumer_getconsumerid)
	w.funcs[:lib3mf_consumer_getkeyid] = Libdl.dlsym(w.lib, :lib3mf_consumer_getkeyid)
	w.funcs[:lib3mf_consumer_getkeyvalue] = Libdl.dlsym(w.lib, :lib3mf_consumer_getkeyvalue)
	w.funcs[:lib3mf_accessright_getconsumer] = Libdl.dlsym(w.lib, :lib3mf_accessright_getconsumer)
	w.funcs[:lib3mf_accessright_getwrappingalgorithm] = Libdl.dlsym(w.lib, :lib3mf_accessright_getwrappingalgorithm)
	w.funcs[:lib3mf_accessright_getmgfalgorithm] = Libdl.dlsym(w.lib, :lib3mf_accessright_getmgfalgorithm)
	w.funcs[:lib3mf_accessright_getdigestmethod] = Libdl.dlsym(w.lib, :lib3mf_accessright_getdigestmethod)
	w.funcs[:lib3mf_contentencryptionparams_getencryptionalgorithm] = Libdl.dlsym(w.lib, :lib3mf_contentencryptionparams_getencryptionalgorithm)
	w.funcs[:lib3mf_contentencryptionparams_getkey] = Libdl.dlsym(w.lib, :lib3mf_contentencryptionparams_getkey)
	w.funcs[:lib3mf_contentencryptionparams_getinitializationvector] = Libdl.dlsym(w.lib, :lib3mf_contentencryptionparams_getinitializationvector)
	w.funcs[:lib3mf_contentencryptionparams_getauthenticationtag] = Libdl.dlsym(w.lib, :lib3mf_contentencryptionparams_getauthenticationtag)
	w.funcs[:lib3mf_contentencryptionparams_setauthenticationtag] = Libdl.dlsym(w.lib, :lib3mf_contentencryptionparams_setauthenticationtag)
	w.funcs[:lib3mf_contentencryptionparams_getadditionalauthenticationdata] = Libdl.dlsym(w.lib, :lib3mf_contentencryptionparams_getadditionalauthenticationdata)
	w.funcs[:lib3mf_contentencryptionparams_getdescriptor] = Libdl.dlsym(w.lib, :lib3mf_contentencryptionparams_getdescriptor)
	w.funcs[:lib3mf_contentencryptionparams_getkeyuuid] = Libdl.dlsym(w.lib, :lib3mf_contentencryptionparams_getkeyuuid)
	w.funcs[:lib3mf_resourcedata_getpath] = Libdl.dlsym(w.lib, :lib3mf_resourcedata_getpath)
	w.funcs[:lib3mf_resourcedata_getencryptionalgorithm] = Libdl.dlsym(w.lib, :lib3mf_resourcedata_getencryptionalgorithm)
	w.funcs[:lib3mf_resourcedata_getcompression] = Libdl.dlsym(w.lib, :lib3mf_resourcedata_getcompression)
	w.funcs[:lib3mf_resourcedata_getadditionalauthenticationdata] = Libdl.dlsym(w.lib, :lib3mf_resourcedata_getadditionalauthenticationdata)
	w.funcs[:lib3mf_resourcedatagroup_getkeyuuid] = Libdl.dlsym(w.lib, :lib3mf_resourcedatagroup_getkeyuuid)
	w.funcs[:lib3mf_resourcedatagroup_addaccessright] = Libdl.dlsym(w.lib, :lib3mf_resourcedatagroup_addaccessright)
	w.funcs[:lib3mf_resourcedatagroup_findaccessrightbyconsumer] = Libdl.dlsym(w.lib, :lib3mf_resourcedatagroup_findaccessrightbyconsumer)
	w.funcs[:lib3mf_resourcedatagroup_removeaccessright] = Libdl.dlsym(w.lib, :lib3mf_resourcedatagroup_removeaccessright)
	w.funcs[:lib3mf_keystore_addconsumer] = Libdl.dlsym(w.lib, :lib3mf_keystore_addconsumer)
	w.funcs[:lib3mf_keystore_getconsumercount] = Libdl.dlsym(w.lib, :lib3mf_keystore_getconsumercount)
	w.funcs[:lib3mf_keystore_getconsumer] = Libdl.dlsym(w.lib, :lib3mf_keystore_getconsumer)
	w.funcs[:lib3mf_keystore_removeconsumer] = Libdl.dlsym(w.lib, :lib3mf_keystore_removeconsumer)
	w.funcs[:lib3mf_keystore_findconsumer] = Libdl.dlsym(w.lib, :lib3mf_keystore_findconsumer)
	w.funcs[:lib3mf_keystore_getresourcedatagroupcount] = Libdl.dlsym(w.lib, :lib3mf_keystore_getresourcedatagroupcount)
	w.funcs[:lib3mf_keystore_addresourcedatagroup] = Libdl.dlsym(w.lib, :lib3mf_keystore_addresourcedatagroup)
	w.funcs[:lib3mf_keystore_getresourcedatagroup] = Libdl.dlsym(w.lib, :lib3mf_keystore_getresourcedatagroup)
	w.funcs[:lib3mf_keystore_removeresourcedatagroup] = Libdl.dlsym(w.lib, :lib3mf_keystore_removeresourcedatagroup)
	w.funcs[:lib3mf_keystore_findresourcedatagroup] = Libdl.dlsym(w.lib, :lib3mf_keystore_findresourcedatagroup)
	w.funcs[:lib3mf_keystore_addresourcedata] = Libdl.dlsym(w.lib, :lib3mf_keystore_addresourcedata)
	w.funcs[:lib3mf_keystore_removeresourcedata] = Libdl.dlsym(w.lib, :lib3mf_keystore_removeresourcedata)
	w.funcs[:lib3mf_keystore_findresourcedata] = Libdl.dlsym(w.lib, :lib3mf_keystore_findresourcedata)
	w.funcs[:lib3mf_keystore_getresourcedatacount] = Libdl.dlsym(w.lib, :lib3mf_keystore_getresourcedatacount)
	w.funcs[:lib3mf_keystore_getresourcedata] = Libdl.dlsym(w.lib, :lib3mf_keystore_getresourcedata)
	w.funcs[:lib3mf_keystore_getuuid] = Libdl.dlsym(w.lib, :lib3mf_keystore_getuuid)
	w.funcs[:lib3mf_keystore_setuuid] = Libdl.dlsym(w.lib, :lib3mf_keystore_setuuid)
	w.funcs[:lib3mf_model_rootmodelpart] = Libdl.dlsym(w.lib, :lib3mf_model_rootmodelpart)
	w.funcs[:lib3mf_model_findorcreatepackagepart] = Libdl.dlsym(w.lib, :lib3mf_model_findorcreatepackagepart)
	w.funcs[:lib3mf_model_setunit] = Libdl.dlsym(w.lib, :lib3mf_model_setunit)
	w.funcs[:lib3mf_model_getunit] = Libdl.dlsym(w.lib, :lib3mf_model_getunit)
	w.funcs[:lib3mf_model_getlanguage] = Libdl.dlsym(w.lib, :lib3mf_model_getlanguage)
	w.funcs[:lib3mf_model_setlanguage] = Libdl.dlsym(w.lib, :lib3mf_model_setlanguage)
	w.funcs[:lib3mf_model_querywriter] = Libdl.dlsym(w.lib, :lib3mf_model_querywriter)
	w.funcs[:lib3mf_model_queryreader] = Libdl.dlsym(w.lib, :lib3mf_model_queryreader)
	w.funcs[:lib3mf_model_getresourcebyid] = Libdl.dlsym(w.lib, :lib3mf_model_getresourcebyid)
	w.funcs[:lib3mf_model_gettexture2dbyid] = Libdl.dlsym(w.lib, :lib3mf_model_gettexture2dbyid)
	w.funcs[:lib3mf_model_getpropertytypebyid] = Libdl.dlsym(w.lib, :lib3mf_model_getpropertytypebyid)
	w.funcs[:lib3mf_model_getbasematerialgroupbyid] = Libdl.dlsym(w.lib, :lib3mf_model_getbasematerialgroupbyid)
	w.funcs[:lib3mf_model_gettexture2dgroupbyid] = Libdl.dlsym(w.lib, :lib3mf_model_gettexture2dgroupbyid)
	w.funcs[:lib3mf_model_getcompositematerialsbyid] = Libdl.dlsym(w.lib, :lib3mf_model_getcompositematerialsbyid)
	w.funcs[:lib3mf_model_getmultipropertygroupbyid] = Libdl.dlsym(w.lib, :lib3mf_model_getmultipropertygroupbyid)
	w.funcs[:lib3mf_model_getmeshobjectbyid] = Libdl.dlsym(w.lib, :lib3mf_model_getmeshobjectbyid)
	w.funcs[:lib3mf_model_getcomponentsobjectbyid] = Libdl.dlsym(w.lib, :lib3mf_model_getcomponentsobjectbyid)
	w.funcs[:lib3mf_model_getcolorgroupbyid] = Libdl.dlsym(w.lib, :lib3mf_model_getcolorgroupbyid)
	w.funcs[:lib3mf_model_getslicestackbyid] = Libdl.dlsym(w.lib, :lib3mf_model_getslicestackbyid)
	w.funcs[:lib3mf_model_getlevelsetbyid] = Libdl.dlsym(w.lib, :lib3mf_model_getlevelsetbyid)
	w.funcs[:lib3mf_model_getbuilduuid] = Libdl.dlsym(w.lib, :lib3mf_model_getbuilduuid)
	w.funcs[:lib3mf_model_setbuilduuid] = Libdl.dlsym(w.lib, :lib3mf_model_setbuilduuid)
	w.funcs[:lib3mf_model_getbuilditems] = Libdl.dlsym(w.lib, :lib3mf_model_getbuilditems)
	w.funcs[:lib3mf_model_getoutbox] = Libdl.dlsym(w.lib, :lib3mf_model_getoutbox)
	w.funcs[:lib3mf_model_getresources] = Libdl.dlsym(w.lib, :lib3mf_model_getresources)
	w.funcs[:lib3mf_model_getobjects] = Libdl.dlsym(w.lib, :lib3mf_model_getobjects)
	w.funcs[:lib3mf_model_getmeshobjects] = Libdl.dlsym(w.lib, :lib3mf_model_getmeshobjects)
	w.funcs[:lib3mf_model_getcomponentsobjects] = Libdl.dlsym(w.lib, :lib3mf_model_getcomponentsobjects)
	w.funcs[:lib3mf_model_gettexture2ds] = Libdl.dlsym(w.lib, :lib3mf_model_gettexture2ds)
	w.funcs[:lib3mf_model_getbasematerialgroups] = Libdl.dlsym(w.lib, :lib3mf_model_getbasematerialgroups)
	w.funcs[:lib3mf_model_getcolorgroups] = Libdl.dlsym(w.lib, :lib3mf_model_getcolorgroups)
	w.funcs[:lib3mf_model_gettexture2dgroups] = Libdl.dlsym(w.lib, :lib3mf_model_gettexture2dgroups)
	w.funcs[:lib3mf_model_getcompositematerials] = Libdl.dlsym(w.lib, :lib3mf_model_getcompositematerials)
	w.funcs[:lib3mf_model_getmultipropertygroups] = Libdl.dlsym(w.lib, :lib3mf_model_getmultipropertygroups)
	w.funcs[:lib3mf_model_getslicestacks] = Libdl.dlsym(w.lib, :lib3mf_model_getslicestacks)
	w.funcs[:lib3mf_model_getimage3ds] = Libdl.dlsym(w.lib, :lib3mf_model_getimage3ds)
	w.funcs[:lib3mf_model_mergetomodel] = Libdl.dlsym(w.lib, :lib3mf_model_mergetomodel)
	w.funcs[:lib3mf_model_mergefrommodel] = Libdl.dlsym(w.lib, :lib3mf_model_mergefrommodel)
	w.funcs[:lib3mf_model_addmeshobject] = Libdl.dlsym(w.lib, :lib3mf_model_addmeshobject)
	w.funcs[:lib3mf_model_addcomponentsobject] = Libdl.dlsym(w.lib, :lib3mf_model_addcomponentsobject)
	w.funcs[:lib3mf_model_addslicestack] = Libdl.dlsym(w.lib, :lib3mf_model_addslicestack)
	w.funcs[:lib3mf_model_addtexture2dfromattachment] = Libdl.dlsym(w.lib, :lib3mf_model_addtexture2dfromattachment)
	w.funcs[:lib3mf_model_addbasematerialgroup] = Libdl.dlsym(w.lib, :lib3mf_model_addbasematerialgroup)
	w.funcs[:lib3mf_model_addcolorgroup] = Libdl.dlsym(w.lib, :lib3mf_model_addcolorgroup)
	w.funcs[:lib3mf_model_addtexture2dgroup] = Libdl.dlsym(w.lib, :lib3mf_model_addtexture2dgroup)
	w.funcs[:lib3mf_model_addcompositematerials] = Libdl.dlsym(w.lib, :lib3mf_model_addcompositematerials)
	w.funcs[:lib3mf_model_addmultipropertygroup] = Libdl.dlsym(w.lib, :lib3mf_model_addmultipropertygroup)
	w.funcs[:lib3mf_model_addimagestack] = Libdl.dlsym(w.lib, :lib3mf_model_addimagestack)
	w.funcs[:lib3mf_model_getimagestackbyid] = Libdl.dlsym(w.lib, :lib3mf_model_getimagestackbyid)
	w.funcs[:lib3mf_model_addbuilditem] = Libdl.dlsym(w.lib, :lib3mf_model_addbuilditem)
	w.funcs[:lib3mf_model_removebuilditem] = Libdl.dlsym(w.lib, :lib3mf_model_removebuilditem)
	w.funcs[:lib3mf_model_getmetadatagroup] = Libdl.dlsym(w.lib, :lib3mf_model_getmetadatagroup)
	w.funcs[:lib3mf_model_addattachment] = Libdl.dlsym(w.lib, :lib3mf_model_addattachment)
	w.funcs[:lib3mf_model_removeattachment] = Libdl.dlsym(w.lib, :lib3mf_model_removeattachment)
	w.funcs[:lib3mf_model_getattachment] = Libdl.dlsym(w.lib, :lib3mf_model_getattachment)
	w.funcs[:lib3mf_model_findattachment] = Libdl.dlsym(w.lib, :lib3mf_model_findattachment)
	w.funcs[:lib3mf_model_getattachmentcount] = Libdl.dlsym(w.lib, :lib3mf_model_getattachmentcount)
	w.funcs[:lib3mf_model_haspackagethumbnailattachment] = Libdl.dlsym(w.lib, :lib3mf_model_haspackagethumbnailattachment)
	w.funcs[:lib3mf_model_createpackagethumbnailattachment] = Libdl.dlsym(w.lib, :lib3mf_model_createpackagethumbnailattachment)
	w.funcs[:lib3mf_model_getpackagethumbnailattachment] = Libdl.dlsym(w.lib, :lib3mf_model_getpackagethumbnailattachment)
	w.funcs[:lib3mf_model_removepackagethumbnailattachment] = Libdl.dlsym(w.lib, :lib3mf_model_removepackagethumbnailattachment)
	w.funcs[:lib3mf_model_addcustomcontenttype] = Libdl.dlsym(w.lib, :lib3mf_model_addcustomcontenttype)
	w.funcs[:lib3mf_model_removecustomcontenttype] = Libdl.dlsym(w.lib, :lib3mf_model_removecustomcontenttype)
	w.funcs[:lib3mf_model_setrandomnumbercallback] = Libdl.dlsym(w.lib, :lib3mf_model_setrandomnumbercallback)
	w.funcs[:lib3mf_model_getkeystore] = Libdl.dlsym(w.lib, :lib3mf_model_getkeystore)
	w.funcs[:lib3mf_model_getfunctions] = Libdl.dlsym(w.lib, :lib3mf_model_getfunctions)
	w.funcs[:lib3mf_model_addimplicitfunction] = Libdl.dlsym(w.lib, :lib3mf_model_addimplicitfunction)
	w.funcs[:lib3mf_model_addfunctionfromimage3d] = Libdl.dlsym(w.lib, :lib3mf_model_addfunctionfromimage3d)
	w.funcs[:lib3mf_model_addvolumedata] = Libdl.dlsym(w.lib, :lib3mf_model_addvolumedata)
	w.funcs[:lib3mf_model_addlevelset] = Libdl.dlsym(w.lib, :lib3mf_model_addlevelset)
	w.funcs[:lib3mf_model_getlevelsets] = Libdl.dlsym(w.lib, :lib3mf_model_getlevelsets)
	w.funcs[:lib3mf_model_removeresource] = Libdl.dlsym(w.lib, :lib3mf_model_removeresource)
end

function _loadFunctionTableFromMethod!(w::Wrapper, symbolLookupMethodAddress::Ptr{Cvoid})
	for name in (
		"lib3mf_getlibraryversion",
		"lib3mf_getprereleaseinformation",
		"lib3mf_getbuildinformation",
		"lib3mf_getspecificationversion",
		"lib3mf_createmodel",
		"lib3mf_release",
		"lib3mf_acquire",
		"lib3mf_setjournal",
		"lib3mf_getlasterror",
		"lib3mf_getsymbollookupmethod",
		"lib3mf_retrieveprogressmessage",
		"lib3mf_rgbatocolor",
		"lib3mf_floatrgbatocolor",
		"lib3mf_colortorgba",
		"lib3mf_colortofloatrgba",
		"lib3mf_getidentitytransform",
		"lib3mf_getuniformscaletransform",
		"lib3mf_getscaletransform",
		"lib3mf_gettranslationtransform",
		"lib3mf_base_classtypeid",
		"lib3mf_writer_writetofile",
		"lib3mf_writer_getstreamsize",
		"lib3mf_writer_writetobuffer",
		"lib3mf_writer_writetocallback",
		"lib3mf_writer_setprogresscallback",
		"lib3mf_writer_getdecimalprecision",
		"lib3mf_writer_setdecimalprecision",
		"lib3mf_writer_setstrictmodeactive",
		"lib3mf_writer_getstrictmodeactive",
		"lib3mf_writer_getwarning",
		"lib3mf_writer_getwarningcount",
		"lib3mf_writer_addkeywrappingcallback",
		"lib3mf_writer_setcontentencryptioncallback",
		"lib3mf_reader_readfromfile",
		"lib3mf_reader_readfrombuffer",
		"lib3mf_reader_readfromcallback",
		"lib3mf_reader_setprogresscallback",
		"lib3mf_reader_addrelationtoread",
		"lib3mf_reader_removerelationtoread",
		"lib3mf_reader_setstrictmodeactive",
		"lib3mf_reader_getstrictmodeactive",
		"lib3mf_reader_getwarning",
		"lib3mf_reader_getwarningcount",
		"lib3mf_reader_addkeywrappingcallback",
		"lib3mf_reader_setcontentencryptioncallback",
		"lib3mf_packagepart_getpath",
		"lib3mf_packagepart_setpath",
		"lib3mf_resource_getresourceid",
		"lib3mf_resource_getuniqueresourceid",
		"lib3mf_resource_packagepart",
		"lib3mf_resource_setpackagepart",
		"lib3mf_resource_getmodelresourceid",
		"lib3mf_resourceiterator_movenext",
		"lib3mf_resourceiterator_moveprevious",
		"lib3mf_resourceiterator_getcurrent",
		"lib3mf_resourceiterator_clone",
		"lib3mf_resourceiterator_count",
		"lib3mf_slicestackiterator_getcurrentslicestack",
		"lib3mf_objectiterator_getcurrentobject",
		"lib3mf_meshobjectiterator_getcurrentmeshobject",
		"lib3mf_componentsobjectiterator_getcurrentcomponentsobject",
		"lib3mf_texture2diterator_getcurrenttexture2d",
		"lib3mf_basematerialgroupiterator_getcurrentbasematerialgroup",
		"lib3mf_colorgroupiterator_getcurrentcolorgroup",
		"lib3mf_texture2dgroupiterator_getcurrenttexture2dgroup",
		"lib3mf_compositematerialsiterator_getcurrentcompositematerials",
		"lib3mf_multipropertygroupiterator_getcurrentmultipropertygroup",
		"lib3mf_image3diterator_getcurrentimage3d",
		"lib3mf_functioniterator_getcurrentfunction",
		"lib3mf_levelsetiterator_getcurrentlevelset",
		"lib3mf_metadata_getnamespace",
		"lib3mf_metadata_setnamespace",
		"lib3mf_metadata_getname",
		"lib3mf_metadata_setname",
		"lib3mf_metadata_getkey",
		"lib3mf_metadata_getmustpreserve",
		"lib3mf_metadata_setmustpreserve",
		"lib3mf_metadata_gettype",
		"lib3mf_metadata_settype",
		"lib3mf_metadata_getvalue",
		"lib3mf_metadata_setvalue",
		"lib3mf_metadatagroup_getmetadatacount",
		"lib3mf_metadatagroup_getmetadata",
		"lib3mf_metadatagroup_getmetadatabykey",
		"lib3mf_metadatagroup_removemetadatabyindex",
		"lib3mf_metadatagroup_removemetadata",
		"lib3mf_metadatagroup_addmetadata",
		"lib3mf_triangleset_setname",
		"lib3mf_triangleset_getname",
		"lib3mf_triangleset_setidentifier",
		"lib3mf_triangleset_getidentifier",
		"lib3mf_triangleset_addtriangle",
		"lib3mf_triangleset_removetriangle",
		"lib3mf_triangleset_clear",
		"lib3mf_triangleset_settrianglelist",
		"lib3mf_triangleset_gettrianglelist",
		"lib3mf_triangleset_addtrianglelist",
		"lib3mf_triangleset_merge",
		"lib3mf_triangleset_deleteset",
		"lib3mf_triangleset_duplicate",
		"lib3mf_object_gettype",
		"lib3mf_object_settype",
		"lib3mf_object_getname",
		"lib3mf_object_setname",
		"lib3mf_object_getpartnumber",
		"lib3mf_object_setpartnumber",
		"lib3mf_object_ismeshobject",
		"lib3mf_object_iscomponentsobject",
		"lib3mf_object_islevelsetobject",
		"lib3mf_object_isvalid",
		"lib3mf_object_setattachmentasthumbnail",
		"lib3mf_object_getthumbnailattachment",
		"lib3mf_object_clearthumbnailattachment",
		"lib3mf_object_getoutbox",
		"lib3mf_object_getuuid",
		"lib3mf_object_setuuid",
		"lib3mf_object_getmetadatagroup",
		"lib3mf_object_setslicesmeshresolution",
		"lib3mf_object_getslicesmeshresolution",
		"lib3mf_object_hasslices",
		"lib3mf_object_clearslicestack",
		"lib3mf_object_getslicestack",
		"lib3mf_object_assignslicestack",
		"lib3mf_meshobject_getvertexcount",
		"lib3mf_meshobject_gettrianglecount",
		"lib3mf_meshobject_getvertex",
		"lib3mf_meshobject_setvertex",
		"lib3mf_meshobject_addvertex",
		"lib3mf_meshobject_getvertices",
		"lib3mf_meshobject_gettriangle",
		"lib3mf_meshobject_settriangle",
		"lib3mf_meshobject_addtriangle",
		"lib3mf_meshobject_gettriangleindices",
		"lib3mf_meshobject_setobjectlevelproperty",
		"lib3mf_meshobject_getobjectlevelproperty",
		"lib3mf_meshobject_settriangleproperties",
		"lib3mf_meshobject_gettriangleproperties",
		"lib3mf_meshobject_setalltriangleproperties",
		"lib3mf_meshobject_getalltriangleproperties",
		"lib3mf_meshobject_clearallproperties",
		"lib3mf_meshobject_setgeometry",
		"lib3mf_meshobject_ismanifoldandoriented",
		"lib3mf_meshobject_beamlattice",
		"lib3mf_meshobject_getvolumedata",
		"lib3mf_meshobject_setvolumedata",
		"lib3mf_meshobject_addtriangleset",
		"lib3mf_meshobject_hastriangleset",
		"lib3mf_meshobject_findtriangleset",
		"lib3mf_meshobject_gettrianglesetcount",
		"lib3mf_meshobject_gettriangleset",
		"lib3mf_levelset_getfunction",
		"lib3mf_levelset_setfunction",
		"lib3mf_levelset_gettransform",
		"lib3mf_levelset_settransform",
		"lib3mf_levelset_getchannelname",
		"lib3mf_levelset_setchannelname",
		"lib3mf_levelset_setminfeaturesize",
		"lib3mf_levelset_getminfeaturesize",
		"lib3mf_levelset_setfallbackvalue",
		"lib3mf_levelset_getfallbackvalue",
		"lib3mf_levelset_setmeshbboxonly",
		"lib3mf_levelset_getmeshbboxonly",
		"lib3mf_levelset_setmesh",
		"lib3mf_levelset_getmesh",
		"lib3mf_levelset_getvolumedata",
		"lib3mf_levelset_setvolumedata",
		"lib3mf_beamlattice_getminlength",
		"lib3mf_beamlattice_setminlength",
		"lib3mf_beamlattice_getclipping",
		"lib3mf_beamlattice_setclipping",
		"lib3mf_beamlattice_getrepresentation",
		"lib3mf_beamlattice_setrepresentation",
		"lib3mf_beamlattice_getballoptions",
		"lib3mf_beamlattice_setballoptions",
		"lib3mf_beamlattice_getbeamcount",
		"lib3mf_beamlattice_getbeam",
		"lib3mf_beamlattice_addbeam",
		"lib3mf_beamlattice_setbeam",
		"lib3mf_beamlattice_setbeams",
		"lib3mf_beamlattice_getbeams",
		"lib3mf_beamlattice_getballcount",
		"lib3mf_beamlattice_getball",
		"lib3mf_beamlattice_addball",
		"lib3mf_beamlattice_setball",
		"lib3mf_beamlattice_setballs",
		"lib3mf_beamlattice_getballs",
		"lib3mf_beamlattice_getbeamsetcount",
		"lib3mf_beamlattice_addbeamset",
		"lib3mf_beamlattice_getbeamset",
		"lib3mf_functionreference_getfunctionresourceid",
		"lib3mf_functionreference_setfunctionresourceid",
		"lib3mf_functionreference_gettransform",
		"lib3mf_functionreference_settransform",
		"lib3mf_functionreference_getchannelname",
		"lib3mf_functionreference_setchannelname",
		"lib3mf_functionreference_setminfeaturesize",
		"lib3mf_functionreference_getminfeaturesize",
		"lib3mf_functionreference_setfallbackvalue",
		"lib3mf_functionreference_getfallbackvalue",
		"lib3mf_volumedatacomposite_getbasematerialgroup",
		"lib3mf_volumedatacomposite_setbasematerialgroup",
		"lib3mf_volumedatacomposite_getmaterialmappingcount",
		"lib3mf_volumedatacomposite_getmaterialmapping",
		"lib3mf_volumedatacomposite_addmaterialmapping",
		"lib3mf_volumedatacomposite_removematerialmapping",
		"lib3mf_volumedataproperty_getname",
		"lib3mf_volumedataproperty_setisrequired",
		"lib3mf_volumedataproperty_isrequired",
		"lib3mf_volumedata_getcomposite",
		"lib3mf_volumedata_createnewcomposite",
		"lib3mf_volumedata_removecomposite",
		"lib3mf_volumedata_getcolor",
		"lib3mf_volumedata_createnewcolor",
		"lib3mf_volumedata_removecolor",
		"lib3mf_volumedata_getpropertycount",
		"lib3mf_volumedata_getproperty",
		"lib3mf_volumedata_addpropertyfromfunction",
		"lib3mf_volumedata_removeproperty",
		"lib3mf_component_getobjectresource",
		"lib3mf_component_getobjectresourceid",
		"lib3mf_component_getuuid",
		"lib3mf_component_setuuid",
		"lib3mf_component_hastransform",
		"lib3mf_component_gettransform",
		"lib3mf_component_settransform",
		"lib3mf_componentsobject_addcomponent",
		"lib3mf_componentsobject_getcomponent",
		"lib3mf_componentsobject_getcomponentcount",
		"lib3mf_beamset_setname",
		"lib3mf_beamset_getname",
		"lib3mf_beamset_setidentifier",
		"lib3mf_beamset_getidentifier",
		"lib3mf_beamset_getreferencecount",
		"lib3mf_beamset_setreferences",
		"lib3mf_beamset_getreferences",
		"lib3mf_beamset_getballreferencecount",
		"lib3mf_beamset_setballreferences",
		"lib3mf_beamset_getballreferences",
		"lib3mf_basematerialgroup_getcount",
		"lib3mf_basematerialgroup_getallpropertyids",
		"lib3mf_basematerialgroup_addmaterial",
		"lib3mf_basematerialgroup_removematerial",
		"lib3mf_basematerialgroup_getname",
		"lib3mf_basematerialgroup_setname",
		"lib3mf_basematerialgroup_setdisplaycolor",
		"lib3mf_basematerialgroup_getdisplaycolor",
		"lib3mf_colorgroup_getcount",
		"lib3mf_colorgroup_getallpropertyids",
		"lib3mf_colorgroup_addcolor",
		"lib3mf_colorgroup_removecolor",
		"lib3mf_colorgroup_setcolor",
		"lib3mf_colorgroup_getcolor",
		"lib3mf_texture2dgroup_getcount",
		"lib3mf_texture2dgroup_getallpropertyids",
		"lib3mf_texture2dgroup_addtex2coord",
		"lib3mf_texture2dgroup_gettex2coord",
		"lib3mf_texture2dgroup_removetex2coord",
		"lib3mf_texture2dgroup_gettexture2d",
		"lib3mf_compositematerials_getcount",
		"lib3mf_compositematerials_getallpropertyids",
		"lib3mf_compositematerials_getbasematerialgroup",
		"lib3mf_compositematerials_addcomposite",
		"lib3mf_compositematerials_removecomposite",
		"lib3mf_compositematerials_getcomposite",
		"lib3mf_multipropertygroup_getcount",
		"lib3mf_multipropertygroup_getallpropertyids",
		"lib3mf_multipropertygroup_addmultiproperty",
		"lib3mf_multipropertygroup_setmultiproperty",
		"lib3mf_multipropertygroup_getmultiproperty",
		"lib3mf_multipropertygroup_removemultiproperty",
		"lib3mf_multipropertygroup_getlayercount",
		"lib3mf_multipropertygroup_addlayer",
		"lib3mf_multipropertygroup_getlayer",
		"lib3mf_multipropertygroup_removelayer",
		"lib3mf_image3d_getname",
		"lib3mf_image3d_setname",
		"lib3mf_image3d_isimagestack",
		"lib3mf_imagestack_getrowcount",
		"lib3mf_imagestack_setrowcount",
		"lib3mf_imagestack_getcolumncount",
		"lib3mf_imagestack_setcolumncount",
		"lib3mf_imagestack_getsheetcount",
		"lib3mf_imagestack_getsheet",
		"lib3mf_imagestack_setsheet",
		"lib3mf_imagestack_createemptysheet",
		"lib3mf_imagestack_createsheetfrombuffer",
		"lib3mf_imagestack_createsheetfromfile",
		"lib3mf_attachment_getpath",
		"lib3mf_attachment_setpath",
		"lib3mf_attachment_packagepart",
		"lib3mf_attachment_getrelationshiptype",
		"lib3mf_attachment_setrelationshiptype",
		"lib3mf_attachment_writetofile",
		"lib3mf_attachment_readfromfile",
		"lib3mf_attachment_readfromcallback",
		"lib3mf_attachment_getstreamsize",
		"lib3mf_attachment_writetobuffer",
		"lib3mf_attachment_readfrombuffer",
		"lib3mf_texture2d_getattachment",
		"lib3mf_texture2d_setattachment",
		"lib3mf_texture2d_getcontenttype",
		"lib3mf_texture2d_setcontenttype",
		"lib3mf_texture2d_gettilestyleuv",
		"lib3mf_texture2d_settilestyleuv",
		"lib3mf_texture2d_getfilter",
		"lib3mf_texture2d_setfilter",
		"lib3mf_implicitport_getidentifier",
		"lib3mf_implicitport_setidentifier",
		"lib3mf_implicitport_getdisplayname",
		"lib3mf_implicitport_setdisplayname",
		"lib3mf_implicitport_settype",
		"lib3mf_implicitport_gettype",
		"lib3mf_implicitport_getreference",
		"lib3mf_implicitport_setreference",
		"lib3mf_iterator_movenext",
		"lib3mf_iterator_moveprevious",
		"lib3mf_iterator_count",
		"lib3mf_implicitportiterator_getcurrent",
		"lib3mf_implicitnode_getidentifier",
		"lib3mf_implicitnode_setidentifier",
		"lib3mf_implicitnode_getdisplayname",
		"lib3mf_implicitnode_setdisplayname",
		"lib3mf_implicitnode_gettag",
		"lib3mf_implicitnode_settag",
		"lib3mf_implicitnode_getnodetype",
		"lib3mf_implicitnode_addinput",
		"lib3mf_implicitnode_getinputs",
		"lib3mf_implicitnode_addoutput",
		"lib3mf_implicitnode_getoutputs",
		"lib3mf_implicitnode_findinput",
		"lib3mf_implicitnode_findoutput",
		"lib3mf_implicitnode_aretypesvalid",
		"lib3mf_oneinputnode_getinputa",
		"lib3mf_oneinputnode_getoutputresult",
		"lib3mf_resourceidnode_setresource",
		"lib3mf_resourceidnode_getresource",
		"lib3mf_resourceidnode_getoutputvalue",
		"lib3mf_twoinputnode_getinputb",
		"lib3mf_selectnode_getinputb",
		"lib3mf_selectnode_getinputc",
		"lib3mf_selectnode_getinputd",
		"lib3mf_clampnode_getinputmin",
		"lib3mf_clampnode_getinputmax",
		"lib3mf_composevectornode_getinputx",
		"lib3mf_composevectornode_getinputy",
		"lib3mf_composevectornode_getinputz",
		"lib3mf_composevectornode_getoutputresult",
		"lib3mf_decomposevectornode_getinputa",
		"lib3mf_decomposevectornode_getoutputx",
		"lib3mf_decomposevectornode_getoutputy",
		"lib3mf_decomposevectornode_getoutputz",
		"lib3mf_composematrixnode_getinputm00",
		"lib3mf_composematrixnode_getinputm01",
		"lib3mf_composematrixnode_getinputm02",
		"lib3mf_composematrixnode_getinputm03",
		"lib3mf_composematrixnode_getinputm10",
		"lib3mf_composematrixnode_getinputm11",
		"lib3mf_composematrixnode_getinputm12",
		"lib3mf_composematrixnode_getinputm13",
		"lib3mf_composematrixnode_getinputm20",
		"lib3mf_composematrixnode_getinputm21",
		"lib3mf_composematrixnode_getinputm22",
		"lib3mf_composematrixnode_getinputm23",
		"lib3mf_composematrixnode_getinputm30",
		"lib3mf_composematrixnode_getinputm31",
		"lib3mf_composematrixnode_getinputm32",
		"lib3mf_composematrixnode_getinputm33",
		"lib3mf_composematrixnode_getoutputresult",
		"lib3mf_matrixfromrowsnode_getinputa",
		"lib3mf_matrixfromrowsnode_getinputb",
		"lib3mf_matrixfromrowsnode_getinputc",
		"lib3mf_matrixfromrowsnode_getinputd",
		"lib3mf_matrixfromrowsnode_getoutputresult",
		"lib3mf_matrixfromcolumnsnode_getinputa",
		"lib3mf_matrixfromcolumnsnode_getinputb",
		"lib3mf_matrixfromcolumnsnode_getinputc",
		"lib3mf_matrixfromcolumnsnode_getinputd",
		"lib3mf_matrixfromcolumnsnode_getoutputresult",
		"lib3mf_constantnode_setconstant",
		"lib3mf_constantnode_getconstant",
		"lib3mf_constantnode_getoutputvalue",
		"lib3mf_constvecnode_setvector",
		"lib3mf_constvecnode_getvector",
		"lib3mf_constvecnode_getoutputvector",
		"lib3mf_constmatnode_setmatrix",
		"lib3mf_constmatnode_getmatrix",
		"lib3mf_constmatnode_getoutputmatrix",
		"lib3mf_meshnode_getinputmesh",
		"lib3mf_meshnode_getinputpos",
		"lib3mf_meshnode_getoutputdistance",
		"lib3mf_unsignedmeshnode_getinputmesh",
		"lib3mf_unsignedmeshnode_getinputpos",
		"lib3mf_unsignedmeshnode_getoutputdistance",
		"lib3mf_beamlatticenode_getinputbeamlattice",
		"lib3mf_beamlatticenode_getinputpos",
		"lib3mf_beamlatticenode_getoutputdistance",
		"lib3mf_beamlatticenode_setaccuraterange",
		"lib3mf_beamlatticenode_getaccuraterange",
		"lib3mf_functiongradientnode_getinputfunctionid",
		"lib3mf_functiongradientnode_getinputpos",
		"lib3mf_functiongradientnode_getinputstep",
		"lib3mf_functiongradientnode_setscalaroutputname",
		"lib3mf_functiongradientnode_getscalaroutputname",
		"lib3mf_functiongradientnode_setvectorinputname",
		"lib3mf_functiongradientnode_getvectorinputname",
		"lib3mf_functiongradientnode_getoutputnormalizedgradient",
		"lib3mf_functiongradientnode_getoutputgradient",
		"lib3mf_functiongradientnode_getoutputmagnitude",
		"lib3mf_normalizedistancenode_getinputfunctionid",
		"lib3mf_normalizedistancenode_getinputpos",
		"lib3mf_normalizedistancenode_getinputstep",
		"lib3mf_normalizedistancenode_setscalaroutputname",
		"lib3mf_normalizedistancenode_getscalaroutputname",
		"lib3mf_normalizedistancenode_setvectorinputname",
		"lib3mf_normalizedistancenode_getvectorinputname",
		"lib3mf_normalizedistancenode_getoutputresult",
		"lib3mf_functioncallnode_getinputfunctionid",
		"lib3mf_nodeiterator_getcurrent",
		"lib3mf_function_getdisplayname",
		"lib3mf_function_setdisplayname",
		"lib3mf_function_addinput",
		"lib3mf_function_getinputs",
		"lib3mf_function_removeinput",
		"lib3mf_function_addoutput",
		"lib3mf_function_getoutputs",
		"lib3mf_function_removeoutput",
		"lib3mf_function_findinput",
		"lib3mf_function_findoutput",
		"lib3mf_implicitfunction_getidentifier",
		"lib3mf_implicitfunction_setidentifier",
		"lib3mf_implicitfunction_addnode",
		"lib3mf_implicitfunction_addsinnode",
		"lib3mf_implicitfunction_addcosnode",
		"lib3mf_implicitfunction_addtannode",
		"lib3mf_implicitfunction_addarcsinnode",
		"lib3mf_implicitfunction_addarccosnode",
		"lib3mf_implicitfunction_addarctan2node",
		"lib3mf_implicitfunction_addsinhnode",
		"lib3mf_implicitfunction_addcoshnode",
		"lib3mf_implicitfunction_addtanhnode",
		"lib3mf_implicitfunction_addroundnode",
		"lib3mf_implicitfunction_addceilnode",
		"lib3mf_implicitfunction_addfloornode",
		"lib3mf_implicitfunction_addsignnode",
		"lib3mf_implicitfunction_addfractnode",
		"lib3mf_implicitfunction_addabsnode",
		"lib3mf_implicitfunction_addexpnode",
		"lib3mf_implicitfunction_addlognode",
		"lib3mf_implicitfunction_addlog2node",
		"lib3mf_implicitfunction_addlog10node",
		"lib3mf_implicitfunction_addlengthnode",
		"lib3mf_implicitfunction_addtransposenode",
		"lib3mf_implicitfunction_addinversenode",
		"lib3mf_implicitfunction_addsqrtnode",
		"lib3mf_implicitfunction_addresourceidnode",
		"lib3mf_implicitfunction_addadditionnode",
		"lib3mf_implicitfunction_addsubtractionnode",
		"lib3mf_implicitfunction_addmultiplicationnode",
		"lib3mf_implicitfunction_adddivisionnode",
		"lib3mf_implicitfunction_adddotnode",
		"lib3mf_implicitfunction_addcrossnode",
		"lib3mf_implicitfunction_addmatvecmultiplicationnode",
		"lib3mf_implicitfunction_addminnode",
		"lib3mf_implicitfunction_addmaxnode",
		"lib3mf_implicitfunction_addfmodnode",
		"lib3mf_implicitfunction_addpownode",
		"lib3mf_implicitfunction_addselectnode",
		"lib3mf_implicitfunction_addclampnode",
		"lib3mf_implicitfunction_addcomposevectornode",
		"lib3mf_implicitfunction_addvectorfromscalarnode",
		"lib3mf_implicitfunction_adddecomposevectornode",
		"lib3mf_implicitfunction_addcomposematrixnode",
		"lib3mf_implicitfunction_addmatrixfromrowsnode",
		"lib3mf_implicitfunction_addmatrixfromcolumnsnode",
		"lib3mf_implicitfunction_addconstantnode",
		"lib3mf_implicitfunction_addconstvecnode",
		"lib3mf_implicitfunction_addconstmatnode",
		"lib3mf_implicitfunction_addmeshnode",
		"lib3mf_implicitfunction_addunsignedmeshnode",
		"lib3mf_implicitfunction_addbeamlatticenode",
		"lib3mf_implicitfunction_addfunctiongradientnode",
		"lib3mf_implicitfunction_addnormalizedistancenode",
		"lib3mf_implicitfunction_addfunctioncallnode",
		"lib3mf_implicitfunction_getnodes",
		"lib3mf_implicitfunction_removenode",
		"lib3mf_implicitfunction_addlink",
		"lib3mf_implicitfunction_addlinkbynames",
		"lib3mf_implicitfunction_clear",
		"lib3mf_implicitfunction_sortnodestopologically",
		"lib3mf_functionfromimage3d_getimage3d",
		"lib3mf_functionfromimage3d_setimage3d",
		"lib3mf_functionfromimage3d_setfilter",
		"lib3mf_functionfromimage3d_getfilter",
		"lib3mf_functionfromimage3d_settilestyles",
		"lib3mf_functionfromimage3d_gettilestyles",
		"lib3mf_functionfromimage3d_getoffset",
		"lib3mf_functionfromimage3d_setoffset",
		"lib3mf_functionfromimage3d_getscale",
		"lib3mf_functionfromimage3d_setscale",
		"lib3mf_builditem_getobjectresource",
		"lib3mf_builditem_getuuid",
		"lib3mf_builditem_setuuid",
		"lib3mf_builditem_getobjectresourceid",
		"lib3mf_builditem_hasobjecttransform",
		"lib3mf_builditem_getobjecttransform",
		"lib3mf_builditem_setobjecttransform",
		"lib3mf_builditem_getpartnumber",
		"lib3mf_builditem_setpartnumber",
		"lib3mf_builditem_getmetadatagroup",
		"lib3mf_builditem_getoutbox",
		"lib3mf_builditemiterator_movenext",
		"lib3mf_builditemiterator_moveprevious",
		"lib3mf_builditemiterator_getcurrent",
		"lib3mf_builditemiterator_clone",
		"lib3mf_builditemiterator_count",
		"lib3mf_slice_setvertices",
		"lib3mf_slice_getvertices",
		"lib3mf_slice_getvertexcount",
		"lib3mf_slice_addpolygon",
		"lib3mf_slice_getpolygoncount",
		"lib3mf_slice_setpolygonindices",
		"lib3mf_slice_getpolygonindices",
		"lib3mf_slice_getpolygonindexcount",
		"lib3mf_slice_getztop",
		"lib3mf_slicestack_getbottomz",
		"lib3mf_slicestack_getslicecount",
		"lib3mf_slicestack_getslice",
		"lib3mf_slicestack_addslice",
		"lib3mf_slicestack_getslicerefcount",
		"lib3mf_slicestack_addslicestackreference",
		"lib3mf_slicestack_getslicestackreference",
		"lib3mf_slicestack_collapseslicereferences",
		"lib3mf_slicestack_setownpath",
		"lib3mf_slicestack_getownpath",
		"lib3mf_consumer_getconsumerid",
		"lib3mf_consumer_getkeyid",
		"lib3mf_consumer_getkeyvalue",
		"lib3mf_accessright_getconsumer",
		"lib3mf_accessright_getwrappingalgorithm",
		"lib3mf_accessright_getmgfalgorithm",
		"lib3mf_accessright_getdigestmethod",
		"lib3mf_contentencryptionparams_getencryptionalgorithm",
		"lib3mf_contentencryptionparams_getkey",
		"lib3mf_contentencryptionparams_getinitializationvector",
		"lib3mf_contentencryptionparams_getauthenticationtag",
		"lib3mf_contentencryptionparams_setauthenticationtag",
		"lib3mf_contentencryptionparams_getadditionalauthenticationdata",
		"lib3mf_contentencryptionparams_getdescriptor",
		"lib3mf_contentencryptionparams_getkeyuuid",
		"lib3mf_resourcedata_getpath",
		"lib3mf_resourcedata_getencryptionalgorithm",
		"lib3mf_resourcedata_getcompression",
		"lib3mf_resourcedata_getadditionalauthenticationdata",
		"lib3mf_resourcedatagroup_getkeyuuid",
		"lib3mf_resourcedatagroup_addaccessright",
		"lib3mf_resourcedatagroup_findaccessrightbyconsumer",
		"lib3mf_resourcedatagroup_removeaccessright",
		"lib3mf_keystore_addconsumer",
		"lib3mf_keystore_getconsumercount",
		"lib3mf_keystore_getconsumer",
		"lib3mf_keystore_removeconsumer",
		"lib3mf_keystore_findconsumer",
		"lib3mf_keystore_getresourcedatagroupcount",
		"lib3mf_keystore_addresourcedatagroup",
		"lib3mf_keystore_getresourcedatagroup",
		"lib3mf_keystore_removeresourcedatagroup",
		"lib3mf_keystore_findresourcedatagroup",
		"lib3mf_keystore_addresourcedata",
		"lib3mf_keystore_removeresourcedata",
		"lib3mf_keystore_findresourcedata",
		"lib3mf_keystore_getresourcedatacount",
		"lib3mf_keystore_getresourcedata",
		"lib3mf_keystore_getuuid",
		"lib3mf_keystore_setuuid",
		"lib3mf_model_rootmodelpart",
		"lib3mf_model_findorcreatepackagepart",
		"lib3mf_model_setunit",
		"lib3mf_model_getunit",
		"lib3mf_model_getlanguage",
		"lib3mf_model_setlanguage",
		"lib3mf_model_querywriter",
		"lib3mf_model_queryreader",
		"lib3mf_model_getresourcebyid",
		"lib3mf_model_gettexture2dbyid",
		"lib3mf_model_getpropertytypebyid",
		"lib3mf_model_getbasematerialgroupbyid",
		"lib3mf_model_gettexture2dgroupbyid",
		"lib3mf_model_getcompositematerialsbyid",
		"lib3mf_model_getmultipropertygroupbyid",
		"lib3mf_model_getmeshobjectbyid",
		"lib3mf_model_getcomponentsobjectbyid",
		"lib3mf_model_getcolorgroupbyid",
		"lib3mf_model_getslicestackbyid",
		"lib3mf_model_getlevelsetbyid",
		"lib3mf_model_getbuilduuid",
		"lib3mf_model_setbuilduuid",
		"lib3mf_model_getbuilditems",
		"lib3mf_model_getoutbox",
		"lib3mf_model_getresources",
		"lib3mf_model_getobjects",
		"lib3mf_model_getmeshobjects",
		"lib3mf_model_getcomponentsobjects",
		"lib3mf_model_gettexture2ds",
		"lib3mf_model_getbasematerialgroups",
		"lib3mf_model_getcolorgroups",
		"lib3mf_model_gettexture2dgroups",
		"lib3mf_model_getcompositematerials",
		"lib3mf_model_getmultipropertygroups",
		"lib3mf_model_getslicestacks",
		"lib3mf_model_getimage3ds",
		"lib3mf_model_mergetomodel",
		"lib3mf_model_mergefrommodel",
		"lib3mf_model_addmeshobject",
		"lib3mf_model_addcomponentsobject",
		"lib3mf_model_addslicestack",
		"lib3mf_model_addtexture2dfromattachment",
		"lib3mf_model_addbasematerialgroup",
		"lib3mf_model_addcolorgroup",
		"lib3mf_model_addtexture2dgroup",
		"lib3mf_model_addcompositematerials",
		"lib3mf_model_addmultipropertygroup",
		"lib3mf_model_addimagestack",
		"lib3mf_model_getimagestackbyid",
		"lib3mf_model_addbuilditem",
		"lib3mf_model_removebuilditem",
		"lib3mf_model_getmetadatagroup",
		"lib3mf_model_addattachment",
		"lib3mf_model_removeattachment",
		"lib3mf_model_getattachment",
		"lib3mf_model_findattachment",
		"lib3mf_model_getattachmentcount",
		"lib3mf_model_haspackagethumbnailattachment",
		"lib3mf_model_createpackagethumbnailattachment",
		"lib3mf_model_getpackagethumbnailattachment",
		"lib3mf_model_removepackagethumbnailattachment",
		"lib3mf_model_addcustomcontenttype",
		"lib3mf_model_removecustomcontenttype",
		"lib3mf_model_setrandomnumbercallback",
		"lib3mf_model_getkeystore",
		"lib3mf_model_getfunctions",
		"lib3mf_model_addimplicitfunction",
		"lib3mf_model_addfunctionfromimage3d",
		"lib3mf_model_addvolumedata",
		"lib3mf_model_addlevelset",
		"lib3mf_model_getlevelsets",
		"lib3mf_model_removeresource",
	)
		addr = Ref{Ptr{Cvoid}}()
		err = ccall(symbolLookupMethodAddress, Int32, (Cstring, Ref{Ptr{Cvoid}}), name, addr)
		if err != 0
			throw(ELib3MFException(Int32(COULDNOTLOADLIBRARY), string(err)))
		end
		w.funcs[Symbol(name)] = addr[]
	end
end

function _checkBinaryVersion(w::Wrapper)
	nMajor, nMinor, _ = GetLibraryVersion(w)
	if (nMajor != BINDING_VERSION_MAJOR) || (nMinor < BINDING_VERSION_MINOR)
		throw(ELib3MFException(Int32(INCOMPATIBLEBINARYVERSION), ""))
	end
end

get_handle(obj::AbstractLib3MFClass) = getfield(obj, :handle)
get_wrapper(obj::AbstractLib3MFClass) = getfield(obj, :wrapper)

function _checkError(w::Wrapper, instance, errorCode::Int32)
	if errorCode != Int32(SUCCESS)
		if instance !== nothing
			if get_wrapper(instance) !== w
				throw(ELib3MFException(Int32(INVALIDCAST), "invalid wrapper call"))
			end
		end
		message, _ = GetLastError(w, instance)
		throw(ELib3MFException(errorCode, message))
	end
end

function _attach_finalizer(obj)
	finalizer(obj) do o
		try
			Release(get_wrapper(o), o)
		catch
		end
	end
	return obj
end

function _make_object(::Type{T}, handle::Ptr{Cvoid}, w::Wrapper) where {T<:AbstractLib3MFClass}
	obj = T(handle, w)
	return _attach_finalizer(obj)
end

# Polymorphic factory
function _polymorphicFactory(w::Wrapper, handle::Ptr{Cvoid})
	handle == C_NULL && return nothing
	classTypeId = Ref{UInt64}(0)
	err = ccall(w.funcs[:lib3mf_base_classtypeid], Int32, (Ptr{Cvoid}, Ref{UInt64}), handle, classTypeId)
	_checkError(w, nothing, err)
	return _objectById(w, classTypeId[], handle)
end

function _objectById(w::Wrapper, classTypeId::UInt64, handle::Ptr{Cvoid})
	if classTypeId == 0x856632D0BAF1D8B7
		return _make_object(Base, handle, w)
	elseif classTypeId == 0xE76F642F363FD7E9
		return _make_object(Writer, handle, w)
	elseif classTypeId == 0x2D86831DA59FBE72
		return _make_object(Reader, handle, w)
	elseif classTypeId == 0x0E55A826D377483E
		return _make_object(PackagePart, handle, w)
	elseif classTypeId == 0xDFE3889D1B269CBB
		return _make_object(Resource, handle, w)
	elseif classTypeId == 0x460F3515E2621DBE
		return _make_object(ResourceIterator, handle, w)
	elseif classTypeId == 0x69684DB99FA813F6
		return _make_object(SliceStackIterator, handle, w)
	elseif classTypeId == 0xDE92510BD2112288
		return _make_object(ObjectIterator, handle, w)
	elseif classTypeId == 0xF4196034E2B9FDE6
		return _make_object(MeshObjectIterator, handle, w)
	elseif classTypeId == 0x564DE4217ED7614A
		return _make_object(ComponentsObjectIterator, handle, w)
	elseif classTypeId == 0x4BD32B4870FFC03B
		return _make_object(Texture2DIterator, handle, w)
	elseif classTypeId == 0x65E6EDD9362C79CB
		return _make_object(BaseMaterialGroupIterator, handle, w)
	elseif classTypeId == 0x10274A1757C729C0
		return _make_object(ColorGroupIterator, handle, w)
	elseif classTypeId == 0x30D55F4DB88FE0CA
		return _make_object(Texture2DGroupIterator, handle, w)
	elseif classTypeId == 0xA99CC6C3F70FB6F9
		return _make_object(CompositeMaterialsIterator, handle, w)
	elseif classTypeId == 0xC2BDF5D8CBBDB1F0
		return _make_object(MultiPropertyGroupIterator, handle, w)
	elseif classTypeId == 0xC4B8EC00A82BF336
		return _make_object(Image3DIterator, handle, w)
	elseif classTypeId == 0x40E9035363ACE65E
		return _make_object(FunctionIterator, handle, w)
	elseif classTypeId == 0xA0C005C035D5371D
		return _make_object(LevelSetIterator, handle, w)
	elseif classTypeId == 0xD17716D063DE2C22
		return _make_object(MetaData, handle, w)
	elseif classTypeId == 0x0C3B85369E9B25D3
		return _make_object(MetaDataGroup, handle, w)
	elseif classTypeId == 0x5950BB3EE8A82090
		return _make_object(TriangleSet, handle, w)
	elseif classTypeId == 0x2DA2136F577A779C
		return _make_object(Object, handle, w)
	elseif classTypeId == 0x3B3A6DC6EC610497
		return _make_object(MeshObject, handle, w)
	elseif classTypeId == 0xE8A7D9C192EFD0E2
		return _make_object(LevelSet, handle, w)
	elseif classTypeId == 0x63B3B461B30B4BA5
		return _make_object(BeamLattice, handle, w)
	elseif classTypeId == 0x4DF17E76926221C2
		return _make_object(FunctionReference, handle, w)
	elseif classTypeId == 0xD85B5B6143E787E3
		return _make_object(VolumeDataColor, handle, w)
	elseif classTypeId == 0x241FE6B4817C3FE4
		return _make_object(MaterialMapping, handle, w)
	elseif classTypeId == 0x46F1DAC40581B304
		return _make_object(VolumeDataComposite, handle, w)
	elseif classTypeId == 0xFC368AA44ACE42DA
		return _make_object(VolumeDataProperty, handle, w)
	elseif classTypeId == 0x9200586FB91587A7
		return _make_object(VolumeData, handle, w)
	elseif classTypeId == 0x4ECDB6A6F69F2BEB
		return _make_object(Component, handle, w)
	elseif classTypeId == 0x6522CF04EB283FED
		return _make_object(ComponentsObject, handle, w)
	elseif classTypeId == 0x30CCDBE90E00B55B
		return _make_object(BeamSet, handle, w)
	elseif classTypeId == 0xB27D4656E16609FA
		return _make_object(BaseMaterialGroup, handle, w)
	elseif classTypeId == 0xD085FB2E49CDB5B1
		return _make_object(ColorGroup, handle, w)
	elseif classTypeId == 0xBC1208397E37055D
		return _make_object(Texture2DGroup, handle, w)
	elseif classTypeId == 0xCE16224D688B86F2
		return _make_object(CompositeMaterials, handle, w)
	elseif classTypeId == 0xB989E02E43158FE6
		return _make_object(MultiPropertyGroup, handle, w)
	elseif classTypeId == 0xBD938FF2D2663D61
		return _make_object(Image3D, handle, w)
	elseif classTypeId == 0x13A2561F0CFB712A
		return _make_object(ImageStack, handle, w)
	elseif classTypeId == 0x8CE7A1191A63A35D
		return _make_object(Attachment, handle, w)
	elseif classTypeId == 0xE0441CF976B36319
		return _make_object(Texture2D, handle, w)
	elseif classTypeId == 0xD5C49B04AF1963CD
		return _make_object(ImplicitPort, handle, w)
	elseif classTypeId == 0x52F06268CD098EFE
		return _make_object(Iterator, handle, w)
	elseif classTypeId == 0xC62268F2D7C7012C
		return _make_object(ImplicitPortIterator, handle, w)
	elseif classTypeId == 0xE72592A7725AB29B
		return _make_object(ImplicitNode, handle, w)
	elseif classTypeId == 0xB19B9FDA94B0A5E7
		return _make_object(OneInputNode, handle, w)
	elseif classTypeId == 0xD5AEA50A56306722
		return _make_object(SinNode, handle, w)
	elseif classTypeId == 0x59BC328F6FB5C5FF
		return _make_object(CosNode, handle, w)
	elseif classTypeId == 0x2614CC572AF350B7
		return _make_object(TanNode, handle, w)
	elseif classTypeId == 0xE554C8A7E72AAF4D
		return _make_object(ArcSinNode, handle, w)
	elseif classTypeId == 0x943AF6AE0EFD2B8A
		return _make_object(ArcCosNode, handle, w)
	elseif classTypeId == 0xE47D547615816BAD
		return _make_object(ArcTanNode, handle, w)
	elseif classTypeId == 0x3C7756A456F2D089
		return _make_object(SinhNode, handle, w)
	elseif classTypeId == 0x4A993F91E1DE256D
		return _make_object(CoshNode, handle, w)
	elseif classTypeId == 0xCF077B19B0B78E9D
		return _make_object(TanhNode, handle, w)
	elseif classTypeId == 0xD9F5A53C657765AE
		return _make_object(RoundNode, handle, w)
	elseif classTypeId == 0x627E211653E11D93
		return _make_object(CeilNode, handle, w)
	elseif classTypeId == 0x392A0F4C041D249C
		return _make_object(FloorNode, handle, w)
	elseif classTypeId == 0x8A45165E6C9646D7
		return _make_object(SignNode, handle, w)
	elseif classTypeId == 0x53E62FD67F4D9A65
		return _make_object(FractNode, handle, w)
	elseif classTypeId == 0x6B641C7060040BE3
		return _make_object(AbsNode, handle, w)
	elseif classTypeId == 0x3390243A8E2410F3
		return _make_object(ExpNode, handle, w)
	elseif classTypeId == 0x0070021D73AA89FD
		return _make_object(LogNode, handle, w)
	elseif classTypeId == 0xE8C0ABF7C5DC7068
		return _make_object(Log2Node, handle, w)
	elseif classTypeId == 0x87740AD53454E0DF
		return _make_object(Log10Node, handle, w)
	elseif classTypeId == 0xD85889E2739A74B1
		return _make_object(LengthNode, handle, w)
	elseif classTypeId == 0xA808B7599C158CE6
		return _make_object(TransposeNode, handle, w)
	elseif classTypeId == 0xE8601F66A23A0540
		return _make_object(InverseNode, handle, w)
	elseif classTypeId == 0x9F831944A3DE31DA
		return _make_object(SqrtNode, handle, w)
	elseif classTypeId == 0xCA86A77C71CD3FAE
		return _make_object(ResourceIdNode, handle, w)
	elseif classTypeId == 0x7DE3951BA4C1064C
		return _make_object(TwoInputNode, handle, w)
	elseif classTypeId == 0x57A2236998DF5248
		return _make_object(AdditionNode, handle, w)
	elseif classTypeId == 0x6079B12FFF345D02
		return _make_object(SubtractionNode, handle, w)
	elseif classTypeId == 0xA3C27CF54C2AA76C
		return _make_object(MultiplicationNode, handle, w)
	elseif classTypeId == 0xB896B6413C08CF39
		return _make_object(DivisionNode, handle, w)
	elseif classTypeId == 0xFE60932A66375FAD
		return _make_object(DotNode, handle, w)
	elseif classTypeId == 0x106182D38CA5CFE3
		return _make_object(CrossNode, handle, w)
	elseif classTypeId == 0xB6153EF5DE7E5E11
		return _make_object(ArcTan2Node, handle, w)
	elseif classTypeId == 0x7570C43B9721D0C0
		return _make_object(MatVecMultiplicationNode, handle, w)
	elseif classTypeId == 0x846AFDE9A091E997
		return _make_object(MinNode, handle, w)
	elseif classTypeId == 0x073F910381BF250D
		return _make_object(MaxNode, handle, w)
	elseif classTypeId == 0x1EF703D298223F2A
		return _make_object(FmodNode, handle, w)
	elseif classTypeId == 0xEA57335849379F22
		return _make_object(ModNode, handle, w)
	elseif classTypeId == 0x7700AA17CA1AC0F8
		return _make_object(PowNode, handle, w)
	elseif classTypeId == 0x1127ED71E05A9BD4
		return _make_object(SelectNode, handle, w)
	elseif classTypeId == 0x77AF68C971B1485F
		return _make_object(ClampNode, handle, w)
	elseif classTypeId == 0x49C24B8840C01F7E
		return _make_object(ComposeVectorNode, handle, w)
	elseif classTypeId == 0x2E417B93351375E2
		return _make_object(VectorFromScalarNode, handle, w)
	elseif classTypeId == 0xCC4F8D561CCE35D4
		return _make_object(DecomposeVectorNode, handle, w)
	elseif classTypeId == 0x9EF9EB54A53AA40D
		return _make_object(ComposeMatrixNode, handle, w)
	elseif classTypeId == 0xD6DFD0A7EB64AC33
		return _make_object(MatrixFromRowsNode, handle, w)
	elseif classTypeId == 0x0DCBEAFCF83F3AAC
		return _make_object(MatrixFromColumnsNode, handle, w)
	elseif classTypeId == 0x3F8E5D082F966B1B
		return _make_object(ConstantNode, handle, w)
	elseif classTypeId == 0x9C9363B3F708D556
		return _make_object(ConstVecNode, handle, w)
	elseif classTypeId == 0xF85C90EDCE6F90A4
		return _make_object(ConstMatNode, handle, w)
	elseif classTypeId == 0x53601FD432E3DEF4
		return _make_object(MeshNode, handle, w)
	elseif classTypeId == 0x29985A628251A9CD
		return _make_object(UnsignedMeshNode, handle, w)
	elseif classTypeId == 0x0F3A4EE98F7FEC0C
		return _make_object(BeamLatticeNode, handle, w)
	elseif classTypeId == 0x0437E27AEF740121
		return _make_object(FunctionGradientNode, handle, w)
	elseif classTypeId == 0x817D2E566E73AA8F
		return _make_object(NormalizeDistanceNode, handle, w)
	elseif classTypeId == 0x0765C17C952F24E3
		return _make_object(FunctionCallNode, handle, w)
	elseif classTypeId == 0xFC006BC888CAB4D0
		return _make_object(NodeIterator, handle, w)
	elseif classTypeId == 0x9EFB2757CA1A5231
		return _make_object(Function, handle, w)
	elseif classTypeId == 0x6CE54469EEA83BC1
		return _make_object(ImplicitFunction, handle, w)
	elseif classTypeId == 0x9BD7D3C2026B8CE8
		return _make_object(FunctionFromImage3D, handle, w)
	elseif classTypeId == 0x68FB2D5FFC4BA12A
		return _make_object(BuildItem, handle, w)
	elseif classTypeId == 0xA7D21BD364910860
		return _make_object(BuildItemIterator, handle, w)
	elseif classTypeId == 0x2198BCF4D8DF9C40
		return _make_object(Slice, handle, w)
	elseif classTypeId == 0x6594B031B6096238
		return _make_object(SliceStack, handle, w)
	elseif classTypeId == 0xD9E46D5E6D8118EE
		return _make_object(Consumer, handle, w)
	elseif classTypeId == 0x385C42FC5609498A
		return _make_object(AccessRight, handle, w)
	elseif classTypeId == 0x7FB36B91D4CE4671
		return _make_object(ContentEncryptionParams, handle, w)
	elseif classTypeId == 0x1A47A5E258E22EF9
		return _make_object(ResourceData, handle, w)
	elseif classTypeId == 0xD59067227E428AA4
		return _make_object(ResourceDataGroup, handle, w)
	elseif classTypeId == 0x1CC9E0CC082253C6
		return _make_object(KeyStore, handle, w)
	elseif classTypeId == 0x5A8164ECEDB03F09
		return _make_object(Model, handle, w)
	else
		return nothing
	end
end

mutable struct Base <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct Writer <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct Reader <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct PackagePart <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct Resource <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ResourceIterator <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct SliceStackIterator <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ObjectIterator <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct MeshObjectIterator <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ComponentsObjectIterator <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct Texture2DIterator <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct BaseMaterialGroupIterator <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ColorGroupIterator <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct Texture2DGroupIterator <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct CompositeMaterialsIterator <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct MultiPropertyGroupIterator <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct Image3DIterator <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct FunctionIterator <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct LevelSetIterator <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct MetaData <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct MetaDataGroup <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct TriangleSet <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct Object <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct MeshObject <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct LevelSet <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct BeamLattice <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct FunctionReference <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct VolumeDataColor <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct MaterialMapping <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct VolumeDataComposite <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct VolumeDataProperty <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct VolumeData <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct Component <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ComponentsObject <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct BeamSet <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct BaseMaterialGroup <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ColorGroup <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct Texture2DGroup <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct CompositeMaterials <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct MultiPropertyGroup <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct Image3D <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ImageStack <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct Attachment <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct Texture2D <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ImplicitPort <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct Iterator <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ImplicitPortIterator <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ImplicitNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct OneInputNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct SinNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct CosNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct TanNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ArcSinNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ArcCosNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ArcTanNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct SinhNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct CoshNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct TanhNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct RoundNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct CeilNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct FloorNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct SignNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct FractNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct AbsNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ExpNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct LogNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct Log2Node <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct Log10Node <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct LengthNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct TransposeNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct InverseNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct SqrtNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ResourceIdNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct TwoInputNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct AdditionNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct SubtractionNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct MultiplicationNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct DivisionNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct DotNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct CrossNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ArcTan2Node <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct MatVecMultiplicationNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct MinNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct MaxNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct FmodNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ModNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct PowNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct SelectNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ClampNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ComposeVectorNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct VectorFromScalarNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct DecomposeVectorNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ComposeMatrixNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct MatrixFromRowsNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct MatrixFromColumnsNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ConstantNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ConstVecNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ConstMatNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct MeshNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct UnsignedMeshNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct BeamLatticeNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct FunctionGradientNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct NormalizeDistanceNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct FunctionCallNode <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct NodeIterator <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct Function <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ImplicitFunction <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct FunctionFromImage3D <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct BuildItem <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct BuildItemIterator <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct Slice <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct SliceStack <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct Consumer <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct AccessRight <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ContentEncryptionParams <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ResourceData <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct ResourceDataGroup <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct KeyStore <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

mutable struct Model <: AbstractLib3MFClass
	handle::Ptr{Cvoid}
	wrapper::Wrapper
end

function GetLibraryVersion(w::Wrapper)
	pMajor = Ref{UInt32}()
	pMinor = Ref{UInt32}()
	pMicro = Ref{UInt32}()
	err = ccall(w.funcs[:lib3mf_getlibraryversion], Int32, (Ref{UInt32}, Ref{UInt32}, Ref{UInt32}), pMajor, pMinor, pMicro)
	_checkError(w, nothing, err)
	return pMajor[], pMinor[], pMicro[]
end

function GetPrereleaseInformation(w::Wrapper)
	pHasPrereleaseInfo = Ref{Cbool}()
	nPrereleaseInfoBufferSize = UInt64(0)
	nPrereleaseInfoNeeded = Ref{UInt64}(0)
	pPrereleaseInfoBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(w.funcs[:lib3mf_getprereleaseinformation], Int32, (Ref{Cbool}, UInt64, Ref{UInt64}, Ptr{Cchar}), pHasPrereleaseInfo, nPrereleaseInfoBufferSize, nPrereleaseInfoNeeded, pPrereleaseInfoBuffer)
	_checkError(w, nothing, err)
	pPrereleaseInfoBuffer = Array{UInt8}(undef, Int(nPrereleaseInfoNeeded[]))
	nPrereleaseInfoBufferSize = UInt64(length(pPrereleaseInfoBuffer))
	pPrereleaseInfoBuffer_ptr = pointer(pPrereleaseInfoBuffer)
	GC.@preserve pPrereleaseInfoBuffer begin
		err = ccall(w.funcs[:lib3mf_getprereleaseinformation], Int32, (Ref{Cbool}, UInt64, Ref{UInt64}, Ptr{Cchar}), pHasPrereleaseInfo, nPrereleaseInfoBufferSize, nPrereleaseInfoNeeded, pPrereleaseInfoBuffer_ptr)
	end
	_checkError(w, nothing, err)
	return pHasPrereleaseInfo[] != 0, unsafe_string(pPrereleaseInfoBuffer_ptr)
end

function GetBuildInformation(w::Wrapper)
	pHasBuildInfo = Ref{Cbool}()
	nBuildInformationBufferSize = UInt64(0)
	nBuildInformationNeeded = Ref{UInt64}(0)
	pBuildInformationBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(w.funcs[:lib3mf_getbuildinformation], Int32, (Ref{Cbool}, UInt64, Ref{UInt64}, Ptr{Cchar}), pHasBuildInfo, nBuildInformationBufferSize, nBuildInformationNeeded, pBuildInformationBuffer)
	_checkError(w, nothing, err)
	pBuildInformationBuffer = Array{UInt8}(undef, Int(nBuildInformationNeeded[]))
	nBuildInformationBufferSize = UInt64(length(pBuildInformationBuffer))
	pBuildInformationBuffer_ptr = pointer(pBuildInformationBuffer)
	GC.@preserve pBuildInformationBuffer begin
		err = ccall(w.funcs[:lib3mf_getbuildinformation], Int32, (Ref{Cbool}, UInt64, Ref{UInt64}, Ptr{Cchar}), pHasBuildInfo, nBuildInformationBufferSize, nBuildInformationNeeded, pBuildInformationBuffer_ptr)
	end
	_checkError(w, nothing, err)
	return pHasBuildInfo[] != 0, unsafe_string(pBuildInformationBuffer_ptr)
end

function GetSpecificationVersion(w::Wrapper, SpecificationURL::AbstractString)
	pIsSupported = Ref{Cbool}()
	pMajor = Ref{UInt32}()
	pMinor = Ref{UInt32}()
	pMicro = Ref{UInt32}()
	GC.@preserve SpecificationURL begin
		err = ccall(w.funcs[:lib3mf_getspecificationversion], Int32, (Cstring, Ref{Cbool}, Ref{UInt32}, Ref{UInt32}, Ref{UInt32}), SpecificationURL, pIsSupported, pMajor, pMinor, pMicro)
	end
	_checkError(w, nothing, err)
	return pIsSupported[] != 0, pMajor[], pMinor[], pMicro[]
end

function CreateModel(w::Wrapper)
	pModel = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(w.funcs[:lib3mf_createmodel], Int32, (Ref{Ptr{Cvoid}},), pModel)
	_checkError(w, nothing, err)
	return _polymorphicFactory(w, pModel[])
end

function Release(w::Wrapper, Instance::Base)
	err = ccall(w.funcs[:lib3mf_release], Int32, (Ptr{Cvoid},), Instance.handle)
	_checkError(w, nothing, err)
end

function Acquire(w::Wrapper, Instance::Base)
	err = ccall(w.funcs[:lib3mf_acquire], Int32, (Ptr{Cvoid},), Instance.handle)
	_checkError(w, nothing, err)
end

function SetJournal(w::Wrapper, JournalPath::AbstractString)
	GC.@preserve JournalPath begin
		err = ccall(w.funcs[:lib3mf_setjournal], Int32, (Cstring,), JournalPath)
	end
	_checkError(w, nothing, err)
end

function GetLastError(w::Wrapper, Instance::Base)
	nLastErrorStringBufferSize = UInt64(0)
	nLastErrorStringNeeded = Ref{UInt64}(0)
	pLastErrorStringBuffer = Ptr{Cchar}(C_NULL)
	pHasLastError = Ref{Cbool}()
	err = ccall(w.funcs[:lib3mf_getlasterror], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}, Ref{Cbool}), Instance.handle, nLastErrorStringBufferSize, nLastErrorStringNeeded, pLastErrorStringBuffer, pHasLastError)
	_checkError(w, nothing, err)
	pLastErrorStringBuffer = Array{UInt8}(undef, Int(nLastErrorStringNeeded[]))
	nLastErrorStringBufferSize = UInt64(length(pLastErrorStringBuffer))
	pLastErrorStringBuffer_ptr = pointer(pLastErrorStringBuffer)
	GC.@preserve pLastErrorStringBuffer begin
		err = ccall(w.funcs[:lib3mf_getlasterror], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}, Ref{Cbool}), Instance.handle, nLastErrorStringBufferSize, nLastErrorStringNeeded, pLastErrorStringBuffer_ptr, pHasLastError)
	end
	_checkError(w, nothing, err)
	return unsafe_string(pLastErrorStringBuffer_ptr), pHasLastError[] != 0
end

function GetSymbolLookupMethod(w::Wrapper)
	pSymbolLookupMethod = Ref{Ptr{Cvoid}}()
	err = ccall(w.funcs[:lib3mf_getsymbollookupmethod], Int32, (Ref{Ptr{Cvoid}},), pSymbolLookupMethod)
	_checkError(w, nothing, err)
	return pSymbolLookupMethod[]
end

function RetrieveProgressMessage(w::Wrapper, TheProgressIdentifier::eProgressIdentifier)
	nProgressMessageBufferSize = UInt64(0)
	nProgressMessageNeeded = Ref{UInt64}(0)
	pProgressMessageBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(w.funcs[:lib3mf_retrieveprogressmessage], Int32, (eProgressIdentifier, UInt64, Ref{UInt64}, Ptr{Cchar}), TheProgressIdentifier, nProgressMessageBufferSize, nProgressMessageNeeded, pProgressMessageBuffer)
	_checkError(w, nothing, err)
	pProgressMessageBuffer = Array{UInt8}(undef, Int(nProgressMessageNeeded[]))
	nProgressMessageBufferSize = UInt64(length(pProgressMessageBuffer))
	pProgressMessageBuffer_ptr = pointer(pProgressMessageBuffer)
	GC.@preserve pProgressMessageBuffer begin
		err = ccall(w.funcs[:lib3mf_retrieveprogressmessage], Int32, (eProgressIdentifier, UInt64, Ref{UInt64}, Ptr{Cchar}), TheProgressIdentifier, nProgressMessageBufferSize, nProgressMessageNeeded, pProgressMessageBuffer_ptr)
	end
	_checkError(w, nothing, err)
	return unsafe_string(pProgressMessageBuffer_ptr)
end

function RGBAToColor(w::Wrapper, Red::UInt8, Green::UInt8, Blue::UInt8, Alpha::UInt8)
	pTheColor = Ref{sColor}()
	err = ccall(w.funcs[:lib3mf_rgbatocolor], Int32, (UInt8, UInt8, UInt8, UInt8, Ref{sColor}), Red, Green, Blue, Alpha, pTheColor)
	_checkError(w, nothing, err)
	return pTheColor[]
end

function FloatRGBAToColor(w::Wrapper, Red::Cfloat, Green::Cfloat, Blue::Cfloat, Alpha::Cfloat)
	pTheColor = Ref{sColor}()
	err = ccall(w.funcs[:lib3mf_floatrgbatocolor], Int32, (Cfloat, Cfloat, Cfloat, Cfloat, Ref{sColor}), Red, Green, Blue, Alpha, pTheColor)
	_checkError(w, nothing, err)
	return pTheColor[]
end

function ColorToRGBA(w::Wrapper, TheColor::sColor)
	pTheColor = Ref{sColor}(TheColor)
	pRed = Ref{UInt8}()
	pGreen = Ref{UInt8}()
	pBlue = Ref{UInt8}()
	pAlpha = Ref{UInt8}()
	err = ccall(w.funcs[:lib3mf_colortorgba], Int32, (Ref{sColor}, Ref{UInt8}, Ref{UInt8}, Ref{UInt8}, Ref{UInt8}), pTheColor, pRed, pGreen, pBlue, pAlpha)
	_checkError(w, nothing, err)
	return pRed[], pGreen[], pBlue[], pAlpha[]
end

function ColorToFloatRGBA(w::Wrapper, TheColor::sColor)
	pTheColor = Ref{sColor}(TheColor)
	pRed = Ref{Cfloat}()
	pGreen = Ref{Cfloat}()
	pBlue = Ref{Cfloat}()
	pAlpha = Ref{Cfloat}()
	err = ccall(w.funcs[:lib3mf_colortofloatrgba], Int32, (Ref{sColor}, Ref{Cfloat}, Ref{Cfloat}, Ref{Cfloat}, Ref{Cfloat}), pTheColor, pRed, pGreen, pBlue, pAlpha)
	_checkError(w, nothing, err)
	return pRed[], pGreen[], pBlue[], pAlpha[]
end

function GetIdentityTransform(w::Wrapper)
	pTransform = Ref{sTransform}()
	err = ccall(w.funcs[:lib3mf_getidentitytransform], Int32, (Ref{sTransform},), pTransform)
	_checkError(w, nothing, err)
	return pTransform[]
end

function GetUniformScaleTransform(w::Wrapper, Factor::Cfloat)
	pTransform = Ref{sTransform}()
	err = ccall(w.funcs[:lib3mf_getuniformscaletransform], Int32, (Cfloat, Ref{sTransform}), Factor, pTransform)
	_checkError(w, nothing, err)
	return pTransform[]
end

function GetScaleTransform(w::Wrapper, FactorX::Cfloat, FactorY::Cfloat, FactorZ::Cfloat)
	pTransform = Ref{sTransform}()
	err = ccall(w.funcs[:lib3mf_getscaletransform], Int32, (Cfloat, Cfloat, Cfloat, Ref{sTransform}), FactorX, FactorY, FactorZ, pTransform)
	_checkError(w, nothing, err)
	return pTransform[]
end

function GetTranslationTransform(w::Wrapper, VectorX::Cfloat, VectorY::Cfloat, VectorZ::Cfloat)
	pTransform = Ref{sTransform}()
	err = ccall(w.funcs[:lib3mf_gettranslationtransform], Int32, (Cfloat, Cfloat, Cfloat, Ref{sTransform}), VectorX, VectorY, VectorZ, pTransform)
	_checkError(w, nothing, err)
	return pTransform[]
end

function ClassTypeId(self::Base)
	pClassTypeId = Ref{UInt64}()
	err = ccall(self.wrapper.funcs[:lib3mf_base_classtypeid], Int32, (Ptr{Cvoid}, Ref{UInt64}), self.handle, pClassTypeId)
	_checkError(self.wrapper, self, err)
	return pClassTypeId[]
end

function WriteToFile(self::Writer, Filename::AbstractString)
	GC.@preserve Filename begin
		err = ccall(self.wrapper.funcs[:lib3mf_writer_writetofile], Int32, (Ptr{Cvoid}, Cstring), self.handle, Filename)
	end
	_checkError(self.wrapper, self, err)
end

function GetStreamSize(self::Writer)
	pStreamSize = Ref{UInt64}()
	err = ccall(self.wrapper.funcs[:lib3mf_writer_getstreamsize], Int32, (Ptr{Cvoid}, Ref{UInt64}), self.handle, pStreamSize)
	_checkError(self.wrapper, self, err)
	return pStreamSize[]
end

function WriteToBuffer(self::Writer)
	nBufferCount = UInt64(0)
	nBufferNeeded = Ref{UInt64}(0)
	pBufferBuffer = Ptr{UInt8}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_writer_writetobuffer], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt8}), self.handle, nBufferCount, nBufferNeeded, pBufferBuffer)
	_checkError(self.wrapper, self, err)
	pBufferBuffer = Array{UInt8}(undef, Int(nBufferNeeded[]))
	nBufferCount = UInt64(length(pBufferBuffer))
	pBufferBuffer_ptr = pointer(pBufferBuffer)
	GC.@preserve pBufferBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_writer_writetobuffer], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt8}), self.handle, nBufferCount, nBufferNeeded, pBufferBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pBufferBuffer
end



function GetDecimalPrecision(self::Writer)
	pDecimalPrecision = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_writer_getdecimalprecision], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pDecimalPrecision)
	_checkError(self.wrapper, self, err)
	return pDecimalPrecision[]
end

function SetDecimalPrecision(self::Writer, DecimalPrecision::UInt32)
	err = ccall(self.wrapper.funcs[:lib3mf_writer_setdecimalprecision], Int32, (Ptr{Cvoid}, UInt32), self.handle, DecimalPrecision)
	_checkError(self.wrapper, self, err)
end

function SetStrictModeActive(self::Writer, StrictModeActive::Cbool)
	err = ccall(self.wrapper.funcs[:lib3mf_writer_setstrictmodeactive], Int32, (Ptr{Cvoid}, Cbool), self.handle, StrictModeActive)
	_checkError(self.wrapper, self, err)
end

function GetStrictModeActive(self::Writer)
	pStrictModeActive = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_writer_getstrictmodeactive], Int32, (Ptr{Cvoid}, Ref{Cbool}), self.handle, pStrictModeActive)
	_checkError(self.wrapper, self, err)
	return pStrictModeActive[] != 0
end

function GetWarning(self::Writer, Index::UInt32)
	pErrorCode = Ref{UInt32}()
	nWarningBufferSize = UInt64(0)
	nWarningNeeded = Ref{UInt64}(0)
	pWarningBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_writer_getwarning], Int32, (Ptr{Cvoid}, UInt32, Ref{UInt32}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, Index, pErrorCode, nWarningBufferSize, nWarningNeeded, pWarningBuffer)
	_checkError(self.wrapper, self, err)
	pWarningBuffer = Array{UInt8}(undef, Int(nWarningNeeded[]))
	nWarningBufferSize = UInt64(length(pWarningBuffer))
	pWarningBuffer_ptr = pointer(pWarningBuffer)
	GC.@preserve pWarningBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_writer_getwarning], Int32, (Ptr{Cvoid}, UInt32, Ref{UInt32}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, Index, pErrorCode, nWarningBufferSize, nWarningNeeded, pWarningBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pErrorCode[], unsafe_string(pWarningBuffer_ptr)
end

function GetWarningCount(self::Writer)
	pCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_writer_getwarningcount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end



function ClassTypeId(self::Writer)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function ReadFromFile(self::Reader, Filename::AbstractString)
	GC.@preserve Filename begin
		err = ccall(self.wrapper.funcs[:lib3mf_reader_readfromfile], Int32, (Ptr{Cvoid}, Cstring), self.handle, Filename)
	end
	_checkError(self.wrapper, self, err)
end

function ReadFromBuffer(self::Reader, Buffer::Array{UInt8, 1})
	nBufferCount = UInt64(length(Buffer))
	pBufferBuffer = length(Buffer) == 0 ? Ptr{UInt8}(C_NULL) : pointer(Buffer)
	GC.@preserve Buffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_reader_readfrombuffer], Int32, (Ptr{Cvoid}, UInt64, Ptr{UInt8}), self.handle, nBufferCount, pBufferBuffer)
	end
	_checkError(self.wrapper, self, err)
end



function AddRelationToRead(self::Reader, RelationShipType::AbstractString)
	GC.@preserve RelationShipType begin
		err = ccall(self.wrapper.funcs[:lib3mf_reader_addrelationtoread], Int32, (Ptr{Cvoid}, Cstring), self.handle, RelationShipType)
	end
	_checkError(self.wrapper, self, err)
end

function RemoveRelationToRead(self::Reader, RelationShipType::AbstractString)
	GC.@preserve RelationShipType begin
		err = ccall(self.wrapper.funcs[:lib3mf_reader_removerelationtoread], Int32, (Ptr{Cvoid}, Cstring), self.handle, RelationShipType)
	end
	_checkError(self.wrapper, self, err)
end

function SetStrictModeActive(self::Reader, StrictModeActive::Cbool)
	err = ccall(self.wrapper.funcs[:lib3mf_reader_setstrictmodeactive], Int32, (Ptr{Cvoid}, Cbool), self.handle, StrictModeActive)
	_checkError(self.wrapper, self, err)
end

function GetStrictModeActive(self::Reader)
	pStrictModeActive = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_reader_getstrictmodeactive], Int32, (Ptr{Cvoid}, Ref{Cbool}), self.handle, pStrictModeActive)
	_checkError(self.wrapper, self, err)
	return pStrictModeActive[] != 0
end

function GetWarning(self::Reader, Index::UInt32)
	pErrorCode = Ref{UInt32}()
	nWarningBufferSize = UInt64(0)
	nWarningNeeded = Ref{UInt64}(0)
	pWarningBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_reader_getwarning], Int32, (Ptr{Cvoid}, UInt32, Ref{UInt32}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, Index, pErrorCode, nWarningBufferSize, nWarningNeeded, pWarningBuffer)
	_checkError(self.wrapper, self, err)
	pWarningBuffer = Array{UInt8}(undef, Int(nWarningNeeded[]))
	nWarningBufferSize = UInt64(length(pWarningBuffer))
	pWarningBuffer_ptr = pointer(pWarningBuffer)
	GC.@preserve pWarningBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_reader_getwarning], Int32, (Ptr{Cvoid}, UInt32, Ref{UInt32}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, Index, pErrorCode, nWarningBufferSize, nWarningNeeded, pWarningBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pErrorCode[], unsafe_string(pWarningBuffer_ptr)
end

function GetWarningCount(self::Reader)
	pCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_reader_getwarningcount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end



function ClassTypeId(self::Reader)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetPath(self::PackagePart)
	nPathBufferSize = UInt64(0)
	nPathNeeded = Ref{UInt64}(0)
	pPathBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_packagepart_getpath], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nPathBufferSize, nPathNeeded, pPathBuffer)
	_checkError(self.wrapper, self, err)
	pPathBuffer = Array{UInt8}(undef, Int(nPathNeeded[]))
	nPathBufferSize = UInt64(length(pPathBuffer))
	pPathBuffer_ptr = pointer(pPathBuffer)
	GC.@preserve pPathBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_packagepart_getpath], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nPathBufferSize, nPathNeeded, pPathBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pPathBuffer_ptr)
end

function SetPath(self::PackagePart, Path::AbstractString)
	GC.@preserve Path begin
		err = ccall(self.wrapper.funcs[:lib3mf_packagepart_setpath], Int32, (Ptr{Cvoid}, Cstring), self.handle, Path)
	end
	_checkError(self.wrapper, self, err)
end

function ClassTypeId(self::PackagePart)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetResourceID(self::Resource)
	pUniqueResourceID = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_resource_getresourceid], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pUniqueResourceID)
	_checkError(self.wrapper, self, err)
	return pUniqueResourceID[]
end

function GetUniqueResourceID(self::Resource)
	pUniqueResourceID = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_resource_getuniqueresourceid], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pUniqueResourceID)
	_checkError(self.wrapper, self, err)
	return pUniqueResourceID[]
end

function PackagePart(self::Resource)
	pPackagePart = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_resource_packagepart], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pPackagePart)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pPackagePart[])
end

function SetPackagePart(self::Resource, PackagePart::PackagePart)
	err = ccall(self.wrapper.funcs[:lib3mf_resource_setpackagepart], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, PackagePart.handle)
	_checkError(self.wrapper, self, err)
end

function GetModelResourceID(self::Resource)
	pModelResourceId = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_resource_getmodelresourceid], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pModelResourceId)
	_checkError(self.wrapper, self, err)
	return pModelResourceId[]
end

function ClassTypeId(self::Resource)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function MoveNext(self::ResourceIterator)
	pHasNext = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_resourceiterator_movenext], Int32, (Ptr{Cvoid}, Ref{Cbool}), self.handle, pHasNext)
	_checkError(self.wrapper, self, err)
	return pHasNext[] != 0
end

function MovePrevious(self::ResourceIterator)
	pHasPrevious = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_resourceiterator_moveprevious], Int32, (Ptr{Cvoid}, Ref{Cbool}), self.handle, pHasPrevious)
	_checkError(self.wrapper, self, err)
	return pHasPrevious[] != 0
end

function GetCurrent(self::ResourceIterator)
	pResource = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_resourceiterator_getcurrent], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResource)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResource[])
end

function Clone(self::ResourceIterator)
	pOutResourceIterator = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_resourceiterator_clone], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pOutResourceIterator)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pOutResourceIterator[])
end

function Count(self::ResourceIterator)
	pCount = Ref{UInt64}()
	err = ccall(self.wrapper.funcs[:lib3mf_resourceiterator_count], Int32, (Ptr{Cvoid}, Ref{UInt64}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function ClassTypeId(self::ResourceIterator)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetCurrentSliceStack(self::SliceStackIterator)
	pResource = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_slicestackiterator_getcurrentslicestack], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResource)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResource[])
end

function MoveNext(self::SliceStackIterator)
	return MoveNext(ResourceIterator(self.handle, self.wrapper))
end

function MovePrevious(self::SliceStackIterator)
	return MovePrevious(ResourceIterator(self.handle, self.wrapper))
end

function GetCurrent(self::SliceStackIterator)
	return GetCurrent(ResourceIterator(self.handle, self.wrapper))
end

function Clone(self::SliceStackIterator)
	return Clone(ResourceIterator(self.handle, self.wrapper))
end

function Count(self::SliceStackIterator)
	return Count(ResourceIterator(self.handle, self.wrapper))
end

function ClassTypeId(self::SliceStackIterator)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetCurrentObject(self::ObjectIterator)
	pResource = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_objectiterator_getcurrentobject], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResource)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResource[])
end

function MoveNext(self::ObjectIterator)
	return MoveNext(ResourceIterator(self.handle, self.wrapper))
end

function MovePrevious(self::ObjectIterator)
	return MovePrevious(ResourceIterator(self.handle, self.wrapper))
end

function GetCurrent(self::ObjectIterator)
	return GetCurrent(ResourceIterator(self.handle, self.wrapper))
end

function Clone(self::ObjectIterator)
	return Clone(ResourceIterator(self.handle, self.wrapper))
end

function Count(self::ObjectIterator)
	return Count(ResourceIterator(self.handle, self.wrapper))
end

function ClassTypeId(self::ObjectIterator)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetCurrentMeshObject(self::MeshObjectIterator)
	pResource = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_meshobjectiterator_getcurrentmeshobject], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResource)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResource[])
end

function MoveNext(self::MeshObjectIterator)
	return MoveNext(ResourceIterator(self.handle, self.wrapper))
end

function MovePrevious(self::MeshObjectIterator)
	return MovePrevious(ResourceIterator(self.handle, self.wrapper))
end

function GetCurrent(self::MeshObjectIterator)
	return GetCurrent(ResourceIterator(self.handle, self.wrapper))
end

function Clone(self::MeshObjectIterator)
	return Clone(ResourceIterator(self.handle, self.wrapper))
end

function Count(self::MeshObjectIterator)
	return Count(ResourceIterator(self.handle, self.wrapper))
end

function ClassTypeId(self::MeshObjectIterator)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetCurrentComponentsObject(self::ComponentsObjectIterator)
	pResource = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_componentsobjectiterator_getcurrentcomponentsobject], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResource)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResource[])
end

function MoveNext(self::ComponentsObjectIterator)
	return MoveNext(ResourceIterator(self.handle, self.wrapper))
end

function MovePrevious(self::ComponentsObjectIterator)
	return MovePrevious(ResourceIterator(self.handle, self.wrapper))
end

function GetCurrent(self::ComponentsObjectIterator)
	return GetCurrent(ResourceIterator(self.handle, self.wrapper))
end

function Clone(self::ComponentsObjectIterator)
	return Clone(ResourceIterator(self.handle, self.wrapper))
end

function Count(self::ComponentsObjectIterator)
	return Count(ResourceIterator(self.handle, self.wrapper))
end

function ClassTypeId(self::ComponentsObjectIterator)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetCurrentTexture2D(self::Texture2DIterator)
	pResource = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_texture2diterator_getcurrenttexture2d], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResource)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResource[])
end

function MoveNext(self::Texture2DIterator)
	return MoveNext(ResourceIterator(self.handle, self.wrapper))
end

function MovePrevious(self::Texture2DIterator)
	return MovePrevious(ResourceIterator(self.handle, self.wrapper))
end

function GetCurrent(self::Texture2DIterator)
	return GetCurrent(ResourceIterator(self.handle, self.wrapper))
end

function Clone(self::Texture2DIterator)
	return Clone(ResourceIterator(self.handle, self.wrapper))
end

function Count(self::Texture2DIterator)
	return Count(ResourceIterator(self.handle, self.wrapper))
end

function ClassTypeId(self::Texture2DIterator)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetCurrentBaseMaterialGroup(self::BaseMaterialGroupIterator)
	pResource = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_basematerialgroupiterator_getcurrentbasematerialgroup], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResource)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResource[])
end

function MoveNext(self::BaseMaterialGroupIterator)
	return MoveNext(ResourceIterator(self.handle, self.wrapper))
end

function MovePrevious(self::BaseMaterialGroupIterator)
	return MovePrevious(ResourceIterator(self.handle, self.wrapper))
end

function GetCurrent(self::BaseMaterialGroupIterator)
	return GetCurrent(ResourceIterator(self.handle, self.wrapper))
end

function Clone(self::BaseMaterialGroupIterator)
	return Clone(ResourceIterator(self.handle, self.wrapper))
end

function Count(self::BaseMaterialGroupIterator)
	return Count(ResourceIterator(self.handle, self.wrapper))
end

function ClassTypeId(self::BaseMaterialGroupIterator)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetCurrentColorGroup(self::ColorGroupIterator)
	pResource = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_colorgroupiterator_getcurrentcolorgroup], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResource)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResource[])
end

function MoveNext(self::ColorGroupIterator)
	return MoveNext(ResourceIterator(self.handle, self.wrapper))
end

function MovePrevious(self::ColorGroupIterator)
	return MovePrevious(ResourceIterator(self.handle, self.wrapper))
end

function GetCurrent(self::ColorGroupIterator)
	return GetCurrent(ResourceIterator(self.handle, self.wrapper))
end

function Clone(self::ColorGroupIterator)
	return Clone(ResourceIterator(self.handle, self.wrapper))
end

function Count(self::ColorGroupIterator)
	return Count(ResourceIterator(self.handle, self.wrapper))
end

function ClassTypeId(self::ColorGroupIterator)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetCurrentTexture2DGroup(self::Texture2DGroupIterator)
	pResource = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_texture2dgroupiterator_getcurrenttexture2dgroup], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResource)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResource[])
end

function MoveNext(self::Texture2DGroupIterator)
	return MoveNext(ResourceIterator(self.handle, self.wrapper))
end

function MovePrevious(self::Texture2DGroupIterator)
	return MovePrevious(ResourceIterator(self.handle, self.wrapper))
end

function GetCurrent(self::Texture2DGroupIterator)
	return GetCurrent(ResourceIterator(self.handle, self.wrapper))
end

function Clone(self::Texture2DGroupIterator)
	return Clone(ResourceIterator(self.handle, self.wrapper))
end

function Count(self::Texture2DGroupIterator)
	return Count(ResourceIterator(self.handle, self.wrapper))
end

function ClassTypeId(self::Texture2DGroupIterator)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetCurrentCompositeMaterials(self::CompositeMaterialsIterator)
	pResource = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_compositematerialsiterator_getcurrentcompositematerials], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResource)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResource[])
end

function MoveNext(self::CompositeMaterialsIterator)
	return MoveNext(ResourceIterator(self.handle, self.wrapper))
end

function MovePrevious(self::CompositeMaterialsIterator)
	return MovePrevious(ResourceIterator(self.handle, self.wrapper))
end

function GetCurrent(self::CompositeMaterialsIterator)
	return GetCurrent(ResourceIterator(self.handle, self.wrapper))
end

function Clone(self::CompositeMaterialsIterator)
	return Clone(ResourceIterator(self.handle, self.wrapper))
end

function Count(self::CompositeMaterialsIterator)
	return Count(ResourceIterator(self.handle, self.wrapper))
end

function ClassTypeId(self::CompositeMaterialsIterator)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetCurrentMultiPropertyGroup(self::MultiPropertyGroupIterator)
	pResource = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_multipropertygroupiterator_getcurrentmultipropertygroup], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResource)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResource[])
end

function MoveNext(self::MultiPropertyGroupIterator)
	return MoveNext(ResourceIterator(self.handle, self.wrapper))
end

function MovePrevious(self::MultiPropertyGroupIterator)
	return MovePrevious(ResourceIterator(self.handle, self.wrapper))
end

function GetCurrent(self::MultiPropertyGroupIterator)
	return GetCurrent(ResourceIterator(self.handle, self.wrapper))
end

function Clone(self::MultiPropertyGroupIterator)
	return Clone(ResourceIterator(self.handle, self.wrapper))
end

function Count(self::MultiPropertyGroupIterator)
	return Count(ResourceIterator(self.handle, self.wrapper))
end

function ClassTypeId(self::MultiPropertyGroupIterator)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetCurrentImage3D(self::Image3DIterator)
	pResource = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_image3diterator_getcurrentimage3d], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResource)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResource[])
end

function MoveNext(self::Image3DIterator)
	return MoveNext(ResourceIterator(self.handle, self.wrapper))
end

function MovePrevious(self::Image3DIterator)
	return MovePrevious(ResourceIterator(self.handle, self.wrapper))
end

function GetCurrent(self::Image3DIterator)
	return GetCurrent(ResourceIterator(self.handle, self.wrapper))
end

function Clone(self::Image3DIterator)
	return Clone(ResourceIterator(self.handle, self.wrapper))
end

function Count(self::Image3DIterator)
	return Count(ResourceIterator(self.handle, self.wrapper))
end

function ClassTypeId(self::Image3DIterator)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetCurrentFunction(self::FunctionIterator)
	pResource = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_functioniterator_getcurrentfunction], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResource)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResource[])
end

function MoveNext(self::FunctionIterator)
	return MoveNext(ResourceIterator(self.handle, self.wrapper))
end

function MovePrevious(self::FunctionIterator)
	return MovePrevious(ResourceIterator(self.handle, self.wrapper))
end

function GetCurrent(self::FunctionIterator)
	return GetCurrent(ResourceIterator(self.handle, self.wrapper))
end

function Clone(self::FunctionIterator)
	return Clone(ResourceIterator(self.handle, self.wrapper))
end

function Count(self::FunctionIterator)
	return Count(ResourceIterator(self.handle, self.wrapper))
end

function ClassTypeId(self::FunctionIterator)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetCurrentLevelSet(self::LevelSetIterator)
	pResource = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_levelsetiterator_getcurrentlevelset], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResource)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResource[])
end

function MoveNext(self::LevelSetIterator)
	return MoveNext(ResourceIterator(self.handle, self.wrapper))
end

function MovePrevious(self::LevelSetIterator)
	return MovePrevious(ResourceIterator(self.handle, self.wrapper))
end

function GetCurrent(self::LevelSetIterator)
	return GetCurrent(ResourceIterator(self.handle, self.wrapper))
end

function Clone(self::LevelSetIterator)
	return Clone(ResourceIterator(self.handle, self.wrapper))
end

function Count(self::LevelSetIterator)
	return Count(ResourceIterator(self.handle, self.wrapper))
end

function ClassTypeId(self::LevelSetIterator)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetNameSpace(self::MetaData)
	nNameSpaceBufferSize = UInt64(0)
	nNameSpaceNeeded = Ref{UInt64}(0)
	pNameSpaceBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_metadata_getnamespace], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nNameSpaceBufferSize, nNameSpaceNeeded, pNameSpaceBuffer)
	_checkError(self.wrapper, self, err)
	pNameSpaceBuffer = Array{UInt8}(undef, Int(nNameSpaceNeeded[]))
	nNameSpaceBufferSize = UInt64(length(pNameSpaceBuffer))
	pNameSpaceBuffer_ptr = pointer(pNameSpaceBuffer)
	GC.@preserve pNameSpaceBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_metadata_getnamespace], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nNameSpaceBufferSize, nNameSpaceNeeded, pNameSpaceBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pNameSpaceBuffer_ptr)
end

function SetNameSpace(self::MetaData, NameSpace::AbstractString)
	GC.@preserve NameSpace begin
		err = ccall(self.wrapper.funcs[:lib3mf_metadata_setnamespace], Int32, (Ptr{Cvoid}, Cstring), self.handle, NameSpace)
	end
	_checkError(self.wrapper, self, err)
end

function GetName(self::MetaData)
	nNameBufferSize = UInt64(0)
	nNameNeeded = Ref{UInt64}(0)
	pNameBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_metadata_getname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nNameBufferSize, nNameNeeded, pNameBuffer)
	_checkError(self.wrapper, self, err)
	pNameBuffer = Array{UInt8}(undef, Int(nNameNeeded[]))
	nNameBufferSize = UInt64(length(pNameBuffer))
	pNameBuffer_ptr = pointer(pNameBuffer)
	GC.@preserve pNameBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_metadata_getname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nNameBufferSize, nNameNeeded, pNameBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pNameBuffer_ptr)
end

function SetName(self::MetaData, Name::AbstractString)
	GC.@preserve Name begin
		err = ccall(self.wrapper.funcs[:lib3mf_metadata_setname], Int32, (Ptr{Cvoid}, Cstring), self.handle, Name)
	end
	_checkError(self.wrapper, self, err)
end

function GetKey(self::MetaData)
	nKeyBufferSize = UInt64(0)
	nKeyNeeded = Ref{UInt64}(0)
	pKeyBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_metadata_getkey], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nKeyBufferSize, nKeyNeeded, pKeyBuffer)
	_checkError(self.wrapper, self, err)
	pKeyBuffer = Array{UInt8}(undef, Int(nKeyNeeded[]))
	nKeyBufferSize = UInt64(length(pKeyBuffer))
	pKeyBuffer_ptr = pointer(pKeyBuffer)
	GC.@preserve pKeyBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_metadata_getkey], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nKeyBufferSize, nKeyNeeded, pKeyBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pKeyBuffer_ptr)
end

function GetMustPreserve(self::MetaData)
	pMustPreserve = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_metadata_getmustpreserve], Int32, (Ptr{Cvoid}, Ref{Cbool}), self.handle, pMustPreserve)
	_checkError(self.wrapper, self, err)
	return pMustPreserve[] != 0
end

function SetMustPreserve(self::MetaData, MustPreserve::Cbool)
	err = ccall(self.wrapper.funcs[:lib3mf_metadata_setmustpreserve], Int32, (Ptr{Cvoid}, Cbool), self.handle, MustPreserve)
	_checkError(self.wrapper, self, err)
end

function GetType(self::MetaData)
	nTypeBufferSize = UInt64(0)
	nTypeNeeded = Ref{UInt64}(0)
	pTypeBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_metadata_gettype], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nTypeBufferSize, nTypeNeeded, pTypeBuffer)
	_checkError(self.wrapper, self, err)
	pTypeBuffer = Array{UInt8}(undef, Int(nTypeNeeded[]))
	nTypeBufferSize = UInt64(length(pTypeBuffer))
	pTypeBuffer_ptr = pointer(pTypeBuffer)
	GC.@preserve pTypeBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_metadata_gettype], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nTypeBufferSize, nTypeNeeded, pTypeBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pTypeBuffer_ptr)
end

function SetType(self::MetaData, Type::AbstractString)
	GC.@preserve Type begin
		err = ccall(self.wrapper.funcs[:lib3mf_metadata_settype], Int32, (Ptr{Cvoid}, Cstring), self.handle, Type)
	end
	_checkError(self.wrapper, self, err)
end

function GetValue(self::MetaData)
	nValueBufferSize = UInt64(0)
	nValueNeeded = Ref{UInt64}(0)
	pValueBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_metadata_getvalue], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nValueBufferSize, nValueNeeded, pValueBuffer)
	_checkError(self.wrapper, self, err)
	pValueBuffer = Array{UInt8}(undef, Int(nValueNeeded[]))
	nValueBufferSize = UInt64(length(pValueBuffer))
	pValueBuffer_ptr = pointer(pValueBuffer)
	GC.@preserve pValueBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_metadata_getvalue], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nValueBufferSize, nValueNeeded, pValueBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pValueBuffer_ptr)
end

function SetValue(self::MetaData, Value::AbstractString)
	GC.@preserve Value begin
		err = ccall(self.wrapper.funcs[:lib3mf_metadata_setvalue], Int32, (Ptr{Cvoid}, Cstring), self.handle, Value)
	end
	_checkError(self.wrapper, self, err)
end

function ClassTypeId(self::MetaData)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetMetaDataCount(self::MetaDataGroup)
	pCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_metadatagroup_getmetadatacount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function GetMetaData(self::MetaDataGroup, Index::UInt32)
	pMetaData = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_metadatagroup_getmetadata], Int32, (Ptr{Cvoid}, UInt32, Ref{Ptr{Cvoid}}), self.handle, Index, pMetaData)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pMetaData[])
end

function GetMetaDataByKey(self::MetaDataGroup, NameSpace::AbstractString, Name::AbstractString)
	pMetaData = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve NameSpace Name begin
		err = ccall(self.wrapper.funcs[:lib3mf_metadatagroup_getmetadatabykey], Int32, (Ptr{Cvoid}, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, NameSpace, Name, pMetaData)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pMetaData[])
end

function RemoveMetaDataByIndex(self::MetaDataGroup, Index::UInt32)
	err = ccall(self.wrapper.funcs[:lib3mf_metadatagroup_removemetadatabyindex], Int32, (Ptr{Cvoid}, UInt32), self.handle, Index)
	_checkError(self.wrapper, self, err)
end

function RemoveMetaData(self::MetaDataGroup, TheMetaData::MetaData)
	err = ccall(self.wrapper.funcs[:lib3mf_metadatagroup_removemetadata], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, TheMetaData.handle)
	_checkError(self.wrapper, self, err)
end

function AddMetaData(self::MetaDataGroup, NameSpace::AbstractString, Name::AbstractString, Value::AbstractString, Type::AbstractString, MustPreserve::Cbool)
	pMetaData = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve NameSpace Name Value Type begin
		err = ccall(self.wrapper.funcs[:lib3mf_metadatagroup_addmetadata], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Cstring, Cbool, Ref{Ptr{Cvoid}}), self.handle, NameSpace, Name, Value, Type, MustPreserve, pMetaData)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pMetaData[])
end

function ClassTypeId(self::MetaDataGroup)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function SetName(self::TriangleSet, Name::AbstractString)
	GC.@preserve Name begin
		err = ccall(self.wrapper.funcs[:lib3mf_triangleset_setname], Int32, (Ptr{Cvoid}, Cstring), self.handle, Name)
	end
	_checkError(self.wrapper, self, err)
end

function GetName(self::TriangleSet)
	nNameBufferSize = UInt64(0)
	nNameNeeded = Ref{UInt64}(0)
	pNameBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_triangleset_getname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nNameBufferSize, nNameNeeded, pNameBuffer)
	_checkError(self.wrapper, self, err)
	pNameBuffer = Array{UInt8}(undef, Int(nNameNeeded[]))
	nNameBufferSize = UInt64(length(pNameBuffer))
	pNameBuffer_ptr = pointer(pNameBuffer)
	GC.@preserve pNameBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_triangleset_getname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nNameBufferSize, nNameNeeded, pNameBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pNameBuffer_ptr)
end

function SetIdentifier(self::TriangleSet, Identifier::AbstractString)
	GC.@preserve Identifier begin
		err = ccall(self.wrapper.funcs[:lib3mf_triangleset_setidentifier], Int32, (Ptr{Cvoid}, Cstring), self.handle, Identifier)
	end
	_checkError(self.wrapper, self, err)
end

function GetIdentifier(self::TriangleSet)
	nIdentifierBufferSize = UInt64(0)
	nIdentifierNeeded = Ref{UInt64}(0)
	pIdentifierBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_triangleset_getidentifier], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nIdentifierBufferSize, nIdentifierNeeded, pIdentifierBuffer)
	_checkError(self.wrapper, self, err)
	pIdentifierBuffer = Array{UInt8}(undef, Int(nIdentifierNeeded[]))
	nIdentifierBufferSize = UInt64(length(pIdentifierBuffer))
	pIdentifierBuffer_ptr = pointer(pIdentifierBuffer)
	GC.@preserve pIdentifierBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_triangleset_getidentifier], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nIdentifierBufferSize, nIdentifierNeeded, pIdentifierBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pIdentifierBuffer_ptr)
end

function AddTriangle(self::TriangleSet, TriangleIndex::UInt32)
	err = ccall(self.wrapper.funcs[:lib3mf_triangleset_addtriangle], Int32, (Ptr{Cvoid}, UInt32), self.handle, TriangleIndex)
	_checkError(self.wrapper, self, err)
end

function RemoveTriangle(self::TriangleSet, TriangleIndex::UInt32)
	err = ccall(self.wrapper.funcs[:lib3mf_triangleset_removetriangle], Int32, (Ptr{Cvoid}, UInt32), self.handle, TriangleIndex)
	_checkError(self.wrapper, self, err)
end

function Clear(self::TriangleSet)
	err = ccall(self.wrapper.funcs[:lib3mf_triangleset_clear], Int32, (Ptr{Cvoid},), self.handle)
	_checkError(self.wrapper, self, err)
end

function SetTriangleList(self::TriangleSet, TriangleIndices::Array{UInt32, 1})
	nTriangleIndicesCount = UInt64(length(TriangleIndices))
	pTriangleIndicesBuffer = length(TriangleIndices) == 0 ? Ptr{UInt32}(C_NULL) : pointer(TriangleIndices)
	GC.@preserve TriangleIndices begin
		err = ccall(self.wrapper.funcs[:lib3mf_triangleset_settrianglelist], Int32, (Ptr{Cvoid}, UInt64, Ptr{UInt32}), self.handle, nTriangleIndicesCount, pTriangleIndicesBuffer)
	end
	_checkError(self.wrapper, self, err)
end

function GetTriangleList(self::TriangleSet)
	nTriangleIndicesCount = UInt64(0)
	nTriangleIndicesNeeded = Ref{UInt64}(0)
	pTriangleIndicesBuffer = Ptr{UInt32}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_triangleset_gettrianglelist], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt32}), self.handle, nTriangleIndicesCount, nTriangleIndicesNeeded, pTriangleIndicesBuffer)
	_checkError(self.wrapper, self, err)
	pTriangleIndicesBuffer = Array{UInt32}(undef, Int(nTriangleIndicesNeeded[]))
	nTriangleIndicesCount = UInt64(length(pTriangleIndicesBuffer))
	pTriangleIndicesBuffer_ptr = pointer(pTriangleIndicesBuffer)
	GC.@preserve pTriangleIndicesBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_triangleset_gettrianglelist], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt32}), self.handle, nTriangleIndicesCount, nTriangleIndicesNeeded, pTriangleIndicesBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pTriangleIndicesBuffer
end

function AddTriangleList(self::TriangleSet, TriangleIndices::Array{UInt32, 1})
	nTriangleIndicesCount = UInt64(length(TriangleIndices))
	pTriangleIndicesBuffer = length(TriangleIndices) == 0 ? Ptr{UInt32}(C_NULL) : pointer(TriangleIndices)
	GC.@preserve TriangleIndices begin
		err = ccall(self.wrapper.funcs[:lib3mf_triangleset_addtrianglelist], Int32, (Ptr{Cvoid}, UInt64, Ptr{UInt32}), self.handle, nTriangleIndicesCount, pTriangleIndicesBuffer)
	end
	_checkError(self.wrapper, self, err)
end

function Merge(self::TriangleSet, OtherTriangleSet::TriangleSet, DeleteOther::Cbool)
	err = ccall(self.wrapper.funcs[:lib3mf_triangleset_merge], Int32, (Ptr{Cvoid}, Ptr{Cvoid}, Cbool), self.handle, OtherTriangleSet.handle, DeleteOther)
	_checkError(self.wrapper, self, err)
end

function DeleteSet(self::TriangleSet)
	err = ccall(self.wrapper.funcs[:lib3mf_triangleset_deleteset], Int32, (Ptr{Cvoid},), self.handle)
	_checkError(self.wrapper, self, err)
end

function Duplicate(self::TriangleSet, Identifier::AbstractString)
	pNewSet = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier begin
		err = ccall(self.wrapper.funcs[:lib3mf_triangleset_duplicate], Int32, (Ptr{Cvoid}, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, pNewSet)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNewSet[])
end

function ClassTypeId(self::TriangleSet)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetType(self::Object)
	pObjectType = Ref{Int32}(0)
	err = ccall(self.wrapper.funcs[:lib3mf_object_gettype], Int32, (Ptr{Cvoid}, Ref{Int32}), self.handle, pObjectType)
	_checkError(self.wrapper, self, err)
	return eObjectType(pObjectType[])
end

function SetType(self::Object, ObjectType::eObjectType)
	err = ccall(self.wrapper.funcs[:lib3mf_object_settype], Int32, (Ptr{Cvoid}, eObjectType), self.handle, ObjectType)
	_checkError(self.wrapper, self, err)
end

function GetName(self::Object)
	nNameBufferSize = UInt64(0)
	nNameNeeded = Ref{UInt64}(0)
	pNameBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_object_getname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nNameBufferSize, nNameNeeded, pNameBuffer)
	_checkError(self.wrapper, self, err)
	pNameBuffer = Array{UInt8}(undef, Int(nNameNeeded[]))
	nNameBufferSize = UInt64(length(pNameBuffer))
	pNameBuffer_ptr = pointer(pNameBuffer)
	GC.@preserve pNameBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_object_getname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nNameBufferSize, nNameNeeded, pNameBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pNameBuffer_ptr)
end

function SetName(self::Object, Name::AbstractString)
	GC.@preserve Name begin
		err = ccall(self.wrapper.funcs[:lib3mf_object_setname], Int32, (Ptr{Cvoid}, Cstring), self.handle, Name)
	end
	_checkError(self.wrapper, self, err)
end

function GetPartNumber(self::Object)
	nPartNumberBufferSize = UInt64(0)
	nPartNumberNeeded = Ref{UInt64}(0)
	pPartNumberBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_object_getpartnumber], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nPartNumberBufferSize, nPartNumberNeeded, pPartNumberBuffer)
	_checkError(self.wrapper, self, err)
	pPartNumberBuffer = Array{UInt8}(undef, Int(nPartNumberNeeded[]))
	nPartNumberBufferSize = UInt64(length(pPartNumberBuffer))
	pPartNumberBuffer_ptr = pointer(pPartNumberBuffer)
	GC.@preserve pPartNumberBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_object_getpartnumber], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nPartNumberBufferSize, nPartNumberNeeded, pPartNumberBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pPartNumberBuffer_ptr)
end

function SetPartNumber(self::Object, PartNumber::AbstractString)
	GC.@preserve PartNumber begin
		err = ccall(self.wrapper.funcs[:lib3mf_object_setpartnumber], Int32, (Ptr{Cvoid}, Cstring), self.handle, PartNumber)
	end
	_checkError(self.wrapper, self, err)
end

function IsMeshObject(self::Object)
	pIsMeshObject = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_object_ismeshobject], Int32, (Ptr{Cvoid}, Ref{Cbool}), self.handle, pIsMeshObject)
	_checkError(self.wrapper, self, err)
	return pIsMeshObject[] != 0
end

function IsComponentsObject(self::Object)
	pIsComponentsObject = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_object_iscomponentsobject], Int32, (Ptr{Cvoid}, Ref{Cbool}), self.handle, pIsComponentsObject)
	_checkError(self.wrapper, self, err)
	return pIsComponentsObject[] != 0
end

function IsLevelSetObject(self::Object)
	pIsLevelSetObject = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_object_islevelsetobject], Int32, (Ptr{Cvoid}, Ref{Cbool}), self.handle, pIsLevelSetObject)
	_checkError(self.wrapper, self, err)
	return pIsLevelSetObject[] != 0
end

function IsValid(self::Object)
	pIsValid = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_object_isvalid], Int32, (Ptr{Cvoid}, Ref{Cbool}), self.handle, pIsValid)
	_checkError(self.wrapper, self, err)
	return pIsValid[] != 0
end

function SetAttachmentAsThumbnail(self::Object, Attachment::Attachment)
	err = ccall(self.wrapper.funcs[:lib3mf_object_setattachmentasthumbnail], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, Attachment.handle)
	_checkError(self.wrapper, self, err)
end

function GetThumbnailAttachment(self::Object)
	pAttachment = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_object_getthumbnailattachment], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pAttachment)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pAttachment[])
end

function ClearThumbnailAttachment(self::Object)
	err = ccall(self.wrapper.funcs[:lib3mf_object_clearthumbnailattachment], Int32, (Ptr{Cvoid},), self.handle)
	_checkError(self.wrapper, self, err)
end

function GetOutbox(self::Object)
	pOutbox = Ref{sBox}()
	err = ccall(self.wrapper.funcs[:lib3mf_object_getoutbox], Int32, (Ptr{Cvoid}, Ref{sBox}), self.handle, pOutbox)
	_checkError(self.wrapper, self, err)
	return pOutbox[]
end

function GetUUID(self::Object)
	pHasUUID = Ref{Cbool}()
	nUUIDBufferSize = UInt64(0)
	nUUIDNeeded = Ref{UInt64}(0)
	pUUIDBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_object_getuuid], Int32, (Ptr{Cvoid}, Ref{Cbool}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, pHasUUID, nUUIDBufferSize, nUUIDNeeded, pUUIDBuffer)
	_checkError(self.wrapper, self, err)
	pUUIDBuffer = Array{UInt8}(undef, Int(nUUIDNeeded[]))
	nUUIDBufferSize = UInt64(length(pUUIDBuffer))
	pUUIDBuffer_ptr = pointer(pUUIDBuffer)
	GC.@preserve pUUIDBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_object_getuuid], Int32, (Ptr{Cvoid}, Ref{Cbool}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, pHasUUID, nUUIDBufferSize, nUUIDNeeded, pUUIDBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pHasUUID[] != 0, unsafe_string(pUUIDBuffer_ptr)
end

function SetUUID(self::Object, UUID::AbstractString)
	GC.@preserve UUID begin
		err = ccall(self.wrapper.funcs[:lib3mf_object_setuuid], Int32, (Ptr{Cvoid}, Cstring), self.handle, UUID)
	end
	_checkError(self.wrapper, self, err)
end

function GetMetaDataGroup(self::Object)
	pMetaDataGroup = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_object_getmetadatagroup], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pMetaDataGroup)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pMetaDataGroup[])
end

function SetSlicesMeshResolution(self::Object, MeshResolution::eSlicesMeshResolution)
	err = ccall(self.wrapper.funcs[:lib3mf_object_setslicesmeshresolution], Int32, (Ptr{Cvoid}, eSlicesMeshResolution), self.handle, MeshResolution)
	_checkError(self.wrapper, self, err)
end

function GetSlicesMeshResolution(self::Object)
	pMeshResolution = Ref{Int32}(0)
	err = ccall(self.wrapper.funcs[:lib3mf_object_getslicesmeshresolution], Int32, (Ptr{Cvoid}, Ref{Int32}), self.handle, pMeshResolution)
	_checkError(self.wrapper, self, err)
	return eSlicesMeshResolution(pMeshResolution[])
end

function HasSlices(self::Object, Recursive::Cbool)
	pHasSlices = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_object_hasslices], Int32, (Ptr{Cvoid}, Cbool, Ref{Cbool}), self.handle, Recursive, pHasSlices)
	_checkError(self.wrapper, self, err)
	return pHasSlices[] != 0
end

function ClearSliceStack(self::Object)
	err = ccall(self.wrapper.funcs[:lib3mf_object_clearslicestack], Int32, (Ptr{Cvoid},), self.handle)
	_checkError(self.wrapper, self, err)
end

function GetSliceStack(self::Object)
	pSliceStackInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_object_getslicestack], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pSliceStackInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pSliceStackInstance[])
end

function AssignSliceStack(self::Object, SliceStackInstance::SliceStack)
	err = ccall(self.wrapper.funcs[:lib3mf_object_assignslicestack], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, SliceStackInstance.handle)
	_checkError(self.wrapper, self, err)
end

function GetResourceID(self::Object)
	return GetResourceID(Resource(self.handle, self.wrapper))
end

function GetUniqueResourceID(self::Object)
	return GetUniqueResourceID(Resource(self.handle, self.wrapper))
end

function PackagePart(self::Object)
	return PackagePart(Resource(self.handle, self.wrapper))
end

function SetPackagePart(self::Object, PackagePart::PackagePart)
	return SetPackagePart(Resource(self.handle, self.wrapper), PackagePart)
end

function GetModelResourceID(self::Object)
	return GetModelResourceID(Resource(self.handle, self.wrapper))
end

function ClassTypeId(self::Object)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetVertexCount(self::MeshObject)
	pVertexCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_meshobject_getvertexcount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pVertexCount)
	_checkError(self.wrapper, self, err)
	return pVertexCount[]
end

function GetTriangleCount(self::MeshObject)
	pVertexCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_meshobject_gettrianglecount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pVertexCount)
	_checkError(self.wrapper, self, err)
	return pVertexCount[]
end

function GetVertex(self::MeshObject, Index::UInt32)
	pCoordinates = Ref{sPosition}()
	err = ccall(self.wrapper.funcs[:lib3mf_meshobject_getvertex], Int32, (Ptr{Cvoid}, UInt32, Ref{sPosition}), self.handle, Index, pCoordinates)
	_checkError(self.wrapper, self, err)
	return pCoordinates[]
end

function SetVertex(self::MeshObject, Index::UInt32, Coordinates::sPosition)
	pCoordinates = Ref{sPosition}(Coordinates)
	err = ccall(self.wrapper.funcs[:lib3mf_meshobject_setvertex], Int32, (Ptr{Cvoid}, UInt32, Ref{sPosition}), self.handle, Index, pCoordinates)
	_checkError(self.wrapper, self, err)
end

function AddVertex(self::MeshObject, Coordinates::sPosition)
	pCoordinates = Ref{sPosition}(Coordinates)
	pNewIndex = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_meshobject_addvertex], Int32, (Ptr{Cvoid}, Ref{sPosition}, Ref{UInt32}), self.handle, pCoordinates, pNewIndex)
	_checkError(self.wrapper, self, err)
	return pNewIndex[]
end

function GetVertices(self::MeshObject)
	nVerticesCount = UInt64(0)
	nVerticesNeeded = Ref{UInt64}(0)
	pVerticesBuffer = Ptr{sPosition}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_meshobject_getvertices], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{sPosition}), self.handle, nVerticesCount, nVerticesNeeded, pVerticesBuffer)
	_checkError(self.wrapper, self, err)
	pVerticesBuffer = Array{sPosition}(undef, Int(nVerticesNeeded[]))
	nVerticesCount = UInt64(length(pVerticesBuffer))
	pVerticesBuffer_ptr = pointer(pVerticesBuffer)
	GC.@preserve pVerticesBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_meshobject_getvertices], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{sPosition}), self.handle, nVerticesCount, nVerticesNeeded, pVerticesBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pVerticesBuffer
end

function GetTriangle(self::MeshObject, Index::UInt32)
	pIndices = Ref{sTriangle}()
	err = ccall(self.wrapper.funcs[:lib3mf_meshobject_gettriangle], Int32, (Ptr{Cvoid}, UInt32, Ref{sTriangle}), self.handle, Index, pIndices)
	_checkError(self.wrapper, self, err)
	return pIndices[]
end

function SetTriangle(self::MeshObject, Index::UInt32, Indices::sTriangle)
	pIndices = Ref{sTriangle}(Indices)
	err = ccall(self.wrapper.funcs[:lib3mf_meshobject_settriangle], Int32, (Ptr{Cvoid}, UInt32, Ref{sTriangle}), self.handle, Index, pIndices)
	_checkError(self.wrapper, self, err)
end

function AddTriangle(self::MeshObject, Indices::sTriangle)
	pIndices = Ref{sTriangle}(Indices)
	pNewIndex = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_meshobject_addtriangle], Int32, (Ptr{Cvoid}, Ref{sTriangle}, Ref{UInt32}), self.handle, pIndices, pNewIndex)
	_checkError(self.wrapper, self, err)
	return pNewIndex[]
end

function GetTriangleIndices(self::MeshObject)
	nIndicesCount = UInt64(0)
	nIndicesNeeded = Ref{UInt64}(0)
	pIndicesBuffer = Ptr{sTriangle}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_meshobject_gettriangleindices], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{sTriangle}), self.handle, nIndicesCount, nIndicesNeeded, pIndicesBuffer)
	_checkError(self.wrapper, self, err)
	pIndicesBuffer = Array{sTriangle}(undef, Int(nIndicesNeeded[]))
	nIndicesCount = UInt64(length(pIndicesBuffer))
	pIndicesBuffer_ptr = pointer(pIndicesBuffer)
	GC.@preserve pIndicesBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_meshobject_gettriangleindices], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{sTriangle}), self.handle, nIndicesCount, nIndicesNeeded, pIndicesBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pIndicesBuffer
end

function SetObjectLevelProperty(self::MeshObject, UniqueResourceID::UInt32, PropertyID::UInt32)
	err = ccall(self.wrapper.funcs[:lib3mf_meshobject_setobjectlevelproperty], Int32, (Ptr{Cvoid}, UInt32, UInt32), self.handle, UniqueResourceID, PropertyID)
	_checkError(self.wrapper, self, err)
end

function GetObjectLevelProperty(self::MeshObject)
	pUniqueResourceID = Ref{UInt32}()
	pPropertyID = Ref{UInt32}()
	pHasObjectLevelProperty = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_meshobject_getobjectlevelproperty], Int32, (Ptr{Cvoid}, Ref{UInt32}, Ref{UInt32}, Ref{Cbool}), self.handle, pUniqueResourceID, pPropertyID, pHasObjectLevelProperty)
	_checkError(self.wrapper, self, err)
	return pUniqueResourceID[], pPropertyID[], pHasObjectLevelProperty[] != 0
end

function SetTriangleProperties(self::MeshObject, Index::UInt32, Properties::sTriangleProperties)
	pProperties = Ref{sTriangleProperties}(Properties)
	err = ccall(self.wrapper.funcs[:lib3mf_meshobject_settriangleproperties], Int32, (Ptr{Cvoid}, UInt32, Ref{sTriangleProperties}), self.handle, Index, pProperties)
	_checkError(self.wrapper, self, err)
end

function GetTriangleProperties(self::MeshObject, Index::UInt32)
	pProperty = Ref{sTriangleProperties}()
	err = ccall(self.wrapper.funcs[:lib3mf_meshobject_gettriangleproperties], Int32, (Ptr{Cvoid}, UInt32, Ref{sTriangleProperties}), self.handle, Index, pProperty)
	_checkError(self.wrapper, self, err)
	return pProperty[]
end

function SetAllTriangleProperties(self::MeshObject, PropertiesArray::Array{sTriangleProperties, 1})
	nPropertiesArrayCount = UInt64(length(PropertiesArray))
	pPropertiesArrayBuffer = length(PropertiesArray) == 0 ? Ptr{sTriangleProperties}(C_NULL) : pointer(PropertiesArray)
	GC.@preserve PropertiesArray begin
		err = ccall(self.wrapper.funcs[:lib3mf_meshobject_setalltriangleproperties], Int32, (Ptr{Cvoid}, UInt64, Ptr{sTriangleProperties}), self.handle, nPropertiesArrayCount, pPropertiesArrayBuffer)
	end
	_checkError(self.wrapper, self, err)
end

function GetAllTriangleProperties(self::MeshObject)
	nPropertiesArrayCount = UInt64(0)
	nPropertiesArrayNeeded = Ref{UInt64}(0)
	pPropertiesArrayBuffer = Ptr{sTriangleProperties}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_meshobject_getalltriangleproperties], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{sTriangleProperties}), self.handle, nPropertiesArrayCount, nPropertiesArrayNeeded, pPropertiesArrayBuffer)
	_checkError(self.wrapper, self, err)
	pPropertiesArrayBuffer = Array{sTriangleProperties}(undef, Int(nPropertiesArrayNeeded[]))
	nPropertiesArrayCount = UInt64(length(pPropertiesArrayBuffer))
	pPropertiesArrayBuffer_ptr = pointer(pPropertiesArrayBuffer)
	GC.@preserve pPropertiesArrayBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_meshobject_getalltriangleproperties], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{sTriangleProperties}), self.handle, nPropertiesArrayCount, nPropertiesArrayNeeded, pPropertiesArrayBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pPropertiesArrayBuffer
end

function ClearAllProperties(self::MeshObject)
	err = ccall(self.wrapper.funcs[:lib3mf_meshobject_clearallproperties], Int32, (Ptr{Cvoid},), self.handle)
	_checkError(self.wrapper, self, err)
end

function SetGeometry(self::MeshObject, Vertices::Array{sPosition, 1}, Indices::Array{sTriangle, 1})
	nVerticesCount = UInt64(length(Vertices))
	pVerticesBuffer = length(Vertices) == 0 ? Ptr{sPosition}(C_NULL) : pointer(Vertices)
	nIndicesCount = UInt64(length(Indices))
	pIndicesBuffer = length(Indices) == 0 ? Ptr{sTriangle}(C_NULL) : pointer(Indices)
	GC.@preserve Vertices Indices begin
		err = ccall(self.wrapper.funcs[:lib3mf_meshobject_setgeometry], Int32, (Ptr{Cvoid}, UInt64, Ptr{sPosition}, UInt64, Ptr{sTriangle}), self.handle, nVerticesCount, pVerticesBuffer, nIndicesCount, pIndicesBuffer)
	end
	_checkError(self.wrapper, self, err)
end

function IsManifoldAndOriented(self::MeshObject)
	pIsManifoldAndOriented = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_meshobject_ismanifoldandoriented], Int32, (Ptr{Cvoid}, Ref{Cbool}), self.handle, pIsManifoldAndOriented)
	_checkError(self.wrapper, self, err)
	return pIsManifoldAndOriented[] != 0
end

function BeamLattice(self::MeshObject)
	pTheBeamLattice = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_meshobject_beamlattice], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pTheBeamLattice)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheBeamLattice[])
end

function GetVolumeData(self::MeshObject)
	pTheVolumeData = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_meshobject_getvolumedata], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pTheVolumeData)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheVolumeData[])
end

function SetVolumeData(self::MeshObject, TheVolumeData::VolumeData)
	err = ccall(self.wrapper.funcs[:lib3mf_meshobject_setvolumedata], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, TheVolumeData.handle)
	_checkError(self.wrapper, self, err)
end

function AddTriangleSet(self::MeshObject, Identifier::AbstractString, Name::AbstractString)
	pTheTriangleSet = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier Name begin
		err = ccall(self.wrapper.funcs[:lib3mf_meshobject_addtriangleset], Int32, (Ptr{Cvoid}, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Name, pTheTriangleSet)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheTriangleSet[])
end

function HasTriangleSet(self::MeshObject, Identifier::AbstractString)
	pTriangleSetExists = Ref{Cbool}()
	GC.@preserve Identifier begin
		err = ccall(self.wrapper.funcs[:lib3mf_meshobject_hastriangleset], Int32, (Ptr{Cvoid}, Cstring, Ref{Cbool}), self.handle, Identifier, pTriangleSetExists)
	end
	_checkError(self.wrapper, self, err)
	return pTriangleSetExists[] != 0
end

function FindTriangleSet(self::MeshObject, Identifier::AbstractString)
	pTheTriangleSet = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier begin
		err = ccall(self.wrapper.funcs[:lib3mf_meshobject_findtriangleset], Int32, (Ptr{Cvoid}, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, pTheTriangleSet)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheTriangleSet[])
end

function GetTriangleSetCount(self::MeshObject)
	pCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_meshobject_gettrianglesetcount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function GetTriangleSet(self::MeshObject, Index::UInt32)
	pTheTriangleSet = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_meshobject_gettriangleset], Int32, (Ptr{Cvoid}, UInt32, Ref{Ptr{Cvoid}}), self.handle, Index, pTheTriangleSet)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheTriangleSet[])
end

function GetType(self::MeshObject)
	return GetType(Object(self.handle, self.wrapper))
end

function SetType(self::MeshObject, ObjectType::eObjectType)
	return SetType(Object(self.handle, self.wrapper), ObjectType)
end

function GetName(self::MeshObject)
	return GetName(Object(self.handle, self.wrapper))
end

function SetName(self::MeshObject, Name::AbstractString)
	return SetName(Object(self.handle, self.wrapper), Name)
end

function GetPartNumber(self::MeshObject)
	return GetPartNumber(Object(self.handle, self.wrapper))
end

function SetPartNumber(self::MeshObject, PartNumber::AbstractString)
	return SetPartNumber(Object(self.handle, self.wrapper), PartNumber)
end

function IsMeshObject(self::MeshObject)
	return IsMeshObject(Object(self.handle, self.wrapper))
end

function IsComponentsObject(self::MeshObject)
	return IsComponentsObject(Object(self.handle, self.wrapper))
end

function IsLevelSetObject(self::MeshObject)
	return IsLevelSetObject(Object(self.handle, self.wrapper))
end

function IsValid(self::MeshObject)
	return IsValid(Object(self.handle, self.wrapper))
end

function SetAttachmentAsThumbnail(self::MeshObject, Attachment::Attachment)
	return SetAttachmentAsThumbnail(Object(self.handle, self.wrapper), Attachment)
end

function GetThumbnailAttachment(self::MeshObject)
	return GetThumbnailAttachment(Object(self.handle, self.wrapper))
end

function ClearThumbnailAttachment(self::MeshObject)
	return ClearThumbnailAttachment(Object(self.handle, self.wrapper))
end

function GetOutbox(self::MeshObject)
	return GetOutbox(Object(self.handle, self.wrapper))
end

function GetUUID(self::MeshObject)
	return GetUUID(Object(self.handle, self.wrapper))
end

function SetUUID(self::MeshObject, UUID::AbstractString)
	return SetUUID(Object(self.handle, self.wrapper), UUID)
end

function GetMetaDataGroup(self::MeshObject)
	return GetMetaDataGroup(Object(self.handle, self.wrapper))
end

function SetSlicesMeshResolution(self::MeshObject, MeshResolution::eSlicesMeshResolution)
	return SetSlicesMeshResolution(Object(self.handle, self.wrapper), MeshResolution)
end

function GetSlicesMeshResolution(self::MeshObject)
	return GetSlicesMeshResolution(Object(self.handle, self.wrapper))
end

function HasSlices(self::MeshObject, Recursive::Cbool)
	return HasSlices(Object(self.handle, self.wrapper), Recursive)
end

function ClearSliceStack(self::MeshObject)
	return ClearSliceStack(Object(self.handle, self.wrapper))
end

function GetSliceStack(self::MeshObject)
	return GetSliceStack(Object(self.handle, self.wrapper))
end

function AssignSliceStack(self::MeshObject, SliceStackInstance::SliceStack)
	return AssignSliceStack(Object(self.handle, self.wrapper), SliceStackInstance)
end

function GetResourceID(self::MeshObject)
	return GetResourceID(Resource(self.handle, self.wrapper))
end

function GetUniqueResourceID(self::MeshObject)
	return GetUniqueResourceID(Resource(self.handle, self.wrapper))
end

function PackagePart(self::MeshObject)
	return PackagePart(Resource(self.handle, self.wrapper))
end

function SetPackagePart(self::MeshObject, PackagePart::PackagePart)
	return SetPackagePart(Resource(self.handle, self.wrapper), PackagePart)
end

function GetModelResourceID(self::MeshObject)
	return GetModelResourceID(Resource(self.handle, self.wrapper))
end

function ClassTypeId(self::MeshObject)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetFunction(self::LevelSet)
	pTheFunction = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_levelset_getfunction], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pTheFunction)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheFunction[])
end

function SetFunction(self::LevelSet, TheFunction::Function)
	err = ccall(self.wrapper.funcs[:lib3mf_levelset_setfunction], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, TheFunction.handle)
	_checkError(self.wrapper, self, err)
end

function GetTransform(self::LevelSet)
	pTransform = Ref{sTransform}()
	err = ccall(self.wrapper.funcs[:lib3mf_levelset_gettransform], Int32, (Ptr{Cvoid}, Ref{sTransform}), self.handle, pTransform)
	_checkError(self.wrapper, self, err)
	return pTransform[]
end

function SetTransform(self::LevelSet, Transform::sTransform)
	pTransform = Ref{sTransform}(Transform)
	err = ccall(self.wrapper.funcs[:lib3mf_levelset_settransform], Int32, (Ptr{Cvoid}, Ref{sTransform}), self.handle, pTransform)
	_checkError(self.wrapper, self, err)
end

function GetChannelName(self::LevelSet)
	nChannelNameBufferSize = UInt64(0)
	nChannelNameNeeded = Ref{UInt64}(0)
	pChannelNameBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_levelset_getchannelname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nChannelNameBufferSize, nChannelNameNeeded, pChannelNameBuffer)
	_checkError(self.wrapper, self, err)
	pChannelNameBuffer = Array{UInt8}(undef, Int(nChannelNameNeeded[]))
	nChannelNameBufferSize = UInt64(length(pChannelNameBuffer))
	pChannelNameBuffer_ptr = pointer(pChannelNameBuffer)
	GC.@preserve pChannelNameBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_levelset_getchannelname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nChannelNameBufferSize, nChannelNameNeeded, pChannelNameBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pChannelNameBuffer_ptr)
end

function SetChannelName(self::LevelSet, ChannelName::AbstractString)
	GC.@preserve ChannelName begin
		err = ccall(self.wrapper.funcs[:lib3mf_levelset_setchannelname], Int32, (Ptr{Cvoid}, Cstring), self.handle, ChannelName)
	end
	_checkError(self.wrapper, self, err)
end

function SetMinFeatureSize(self::LevelSet, MinFeatureSize::Cdouble)
	err = ccall(self.wrapper.funcs[:lib3mf_levelset_setminfeaturesize], Int32, (Ptr{Cvoid}, Cdouble), self.handle, MinFeatureSize)
	_checkError(self.wrapper, self, err)
end

function GetMinFeatureSize(self::LevelSet)
	pMinFeatureSize = Ref{Cdouble}()
	err = ccall(self.wrapper.funcs[:lib3mf_levelset_getminfeaturesize], Int32, (Ptr{Cvoid}, Ref{Cdouble}), self.handle, pMinFeatureSize)
	_checkError(self.wrapper, self, err)
	return pMinFeatureSize[]
end

function SetFallBackValue(self::LevelSet, FallBackValue::Cdouble)
	err = ccall(self.wrapper.funcs[:lib3mf_levelset_setfallbackvalue], Int32, (Ptr{Cvoid}, Cdouble), self.handle, FallBackValue)
	_checkError(self.wrapper, self, err)
end

function GetFallBackValue(self::LevelSet)
	pFallBackValue = Ref{Cdouble}()
	err = ccall(self.wrapper.funcs[:lib3mf_levelset_getfallbackvalue], Int32, (Ptr{Cvoid}, Ref{Cdouble}), self.handle, pFallBackValue)
	_checkError(self.wrapper, self, err)
	return pFallBackValue[]
end

function SetMeshBBoxOnly(self::LevelSet, MeshBBoxOnly::Cbool)
	err = ccall(self.wrapper.funcs[:lib3mf_levelset_setmeshbboxonly], Int32, (Ptr{Cvoid}, Cbool), self.handle, MeshBBoxOnly)
	_checkError(self.wrapper, self, err)
end

function GetMeshBBoxOnly(self::LevelSet)
	pMeshBBoxOnly = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_levelset_getmeshbboxonly], Int32, (Ptr{Cvoid}, Ref{Cbool}), self.handle, pMeshBBoxOnly)
	_checkError(self.wrapper, self, err)
	return pMeshBBoxOnly[] != 0
end

function SetMesh(self::LevelSet, TheMesh::MeshObject)
	err = ccall(self.wrapper.funcs[:lib3mf_levelset_setmesh], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, TheMesh.handle)
	_checkError(self.wrapper, self, err)
end

function GetMesh(self::LevelSet)
	pTheMesh = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_levelset_getmesh], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pTheMesh)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheMesh[])
end

function GetVolumeData(self::LevelSet)
	pTheVolumeData = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_levelset_getvolumedata], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pTheVolumeData)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheVolumeData[])
end

function SetVolumeData(self::LevelSet, TheVolumeData::VolumeData)
	err = ccall(self.wrapper.funcs[:lib3mf_levelset_setvolumedata], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, TheVolumeData.handle)
	_checkError(self.wrapper, self, err)
end

function GetType(self::LevelSet)
	return GetType(Object(self.handle, self.wrapper))
end

function SetType(self::LevelSet, ObjectType::eObjectType)
	return SetType(Object(self.handle, self.wrapper), ObjectType)
end

function GetName(self::LevelSet)
	return GetName(Object(self.handle, self.wrapper))
end

function SetName(self::LevelSet, Name::AbstractString)
	return SetName(Object(self.handle, self.wrapper), Name)
end

function GetPartNumber(self::LevelSet)
	return GetPartNumber(Object(self.handle, self.wrapper))
end

function SetPartNumber(self::LevelSet, PartNumber::AbstractString)
	return SetPartNumber(Object(self.handle, self.wrapper), PartNumber)
end

function IsMeshObject(self::LevelSet)
	return IsMeshObject(Object(self.handle, self.wrapper))
end

function IsComponentsObject(self::LevelSet)
	return IsComponentsObject(Object(self.handle, self.wrapper))
end

function IsLevelSetObject(self::LevelSet)
	return IsLevelSetObject(Object(self.handle, self.wrapper))
end

function IsValid(self::LevelSet)
	return IsValid(Object(self.handle, self.wrapper))
end

function SetAttachmentAsThumbnail(self::LevelSet, Attachment::Attachment)
	return SetAttachmentAsThumbnail(Object(self.handle, self.wrapper), Attachment)
end

function GetThumbnailAttachment(self::LevelSet)
	return GetThumbnailAttachment(Object(self.handle, self.wrapper))
end

function ClearThumbnailAttachment(self::LevelSet)
	return ClearThumbnailAttachment(Object(self.handle, self.wrapper))
end

function GetOutbox(self::LevelSet)
	return GetOutbox(Object(self.handle, self.wrapper))
end

function GetUUID(self::LevelSet)
	return GetUUID(Object(self.handle, self.wrapper))
end

function SetUUID(self::LevelSet, UUID::AbstractString)
	return SetUUID(Object(self.handle, self.wrapper), UUID)
end

function GetMetaDataGroup(self::LevelSet)
	return GetMetaDataGroup(Object(self.handle, self.wrapper))
end

function SetSlicesMeshResolution(self::LevelSet, MeshResolution::eSlicesMeshResolution)
	return SetSlicesMeshResolution(Object(self.handle, self.wrapper), MeshResolution)
end

function GetSlicesMeshResolution(self::LevelSet)
	return GetSlicesMeshResolution(Object(self.handle, self.wrapper))
end

function HasSlices(self::LevelSet, Recursive::Cbool)
	return HasSlices(Object(self.handle, self.wrapper), Recursive)
end

function ClearSliceStack(self::LevelSet)
	return ClearSliceStack(Object(self.handle, self.wrapper))
end

function GetSliceStack(self::LevelSet)
	return GetSliceStack(Object(self.handle, self.wrapper))
end

function AssignSliceStack(self::LevelSet, SliceStackInstance::SliceStack)
	return AssignSliceStack(Object(self.handle, self.wrapper), SliceStackInstance)
end

function GetResourceID(self::LevelSet)
	return GetResourceID(Resource(self.handle, self.wrapper))
end

function GetUniqueResourceID(self::LevelSet)
	return GetUniqueResourceID(Resource(self.handle, self.wrapper))
end

function PackagePart(self::LevelSet)
	return PackagePart(Resource(self.handle, self.wrapper))
end

function SetPackagePart(self::LevelSet, PackagePart::PackagePart)
	return SetPackagePart(Resource(self.handle, self.wrapper), PackagePart)
end

function GetModelResourceID(self::LevelSet)
	return GetModelResourceID(Resource(self.handle, self.wrapper))
end

function ClassTypeId(self::LevelSet)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetMinLength(self::BeamLattice)
	pMinLength = Ref{Cdouble}()
	err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_getminlength], Int32, (Ptr{Cvoid}, Ref{Cdouble}), self.handle, pMinLength)
	_checkError(self.wrapper, self, err)
	return pMinLength[]
end

function SetMinLength(self::BeamLattice, MinLength::Cdouble)
	err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_setminlength], Int32, (Ptr{Cvoid}, Cdouble), self.handle, MinLength)
	_checkError(self.wrapper, self, err)
end

function GetClipping(self::BeamLattice)
	pClipMode = Ref{Int32}(0)
	pUniqueResourceID = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_getclipping], Int32, (Ptr{Cvoid}, Ref{Int32}, Ref{UInt32}), self.handle, pClipMode, pUniqueResourceID)
	_checkError(self.wrapper, self, err)
	return eBeamLatticeClipMode(pClipMode[]), pUniqueResourceID[]
end

function SetClipping(self::BeamLattice, ClipMode::eBeamLatticeClipMode, UniqueResourceID::UInt32)
	err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_setclipping], Int32, (Ptr{Cvoid}, eBeamLatticeClipMode, UInt32), self.handle, ClipMode, UniqueResourceID)
	_checkError(self.wrapper, self, err)
end

function GetRepresentation(self::BeamLattice)
	pHasRepresentation = Ref{Cbool}()
	pUniqueResourceID = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_getrepresentation], Int32, (Ptr{Cvoid}, Ref{Cbool}, Ref{UInt32}), self.handle, pHasRepresentation, pUniqueResourceID)
	_checkError(self.wrapper, self, err)
	return pHasRepresentation[] != 0, pUniqueResourceID[]
end

function SetRepresentation(self::BeamLattice, UniqueResourceID::UInt32)
	err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_setrepresentation], Int32, (Ptr{Cvoid}, UInt32), self.handle, UniqueResourceID)
	_checkError(self.wrapper, self, err)
end

function GetBallOptions(self::BeamLattice)
	pBallMode = Ref{Int32}(0)
	pBallRadius = Ref{Cdouble}()
	err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_getballoptions], Int32, (Ptr{Cvoid}, Ref{Int32}, Ref{Cdouble}), self.handle, pBallMode, pBallRadius)
	_checkError(self.wrapper, self, err)
	return eBeamLatticeBallMode(pBallMode[]), pBallRadius[]
end

function SetBallOptions(self::BeamLattice, BallMode::eBeamLatticeBallMode, BallRadius::Cdouble)
	err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_setballoptions], Int32, (Ptr{Cvoid}, eBeamLatticeBallMode, Cdouble), self.handle, BallMode, BallRadius)
	_checkError(self.wrapper, self, err)
end

function GetBeamCount(self::BeamLattice)
	pCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_getbeamcount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function GetBeam(self::BeamLattice, Index::UInt32)
	pBeamInfo = Ref{sBeam}()
	err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_getbeam], Int32, (Ptr{Cvoid}, UInt32, Ref{sBeam}), self.handle, Index, pBeamInfo)
	_checkError(self.wrapper, self, err)
	return pBeamInfo[]
end

function AddBeam(self::BeamLattice, BeamInfo::sBeam)
	pBeamInfo = Ref{sBeam}(BeamInfo)
	pIndex = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_addbeam], Int32, (Ptr{Cvoid}, Ref{sBeam}, Ref{UInt32}), self.handle, pBeamInfo, pIndex)
	_checkError(self.wrapper, self, err)
	return pIndex[]
end

function SetBeam(self::BeamLattice, Index::UInt32, BeamInfo::sBeam)
	pBeamInfo = Ref{sBeam}(BeamInfo)
	err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_setbeam], Int32, (Ptr{Cvoid}, UInt32, Ref{sBeam}), self.handle, Index, pBeamInfo)
	_checkError(self.wrapper, self, err)
end

function SetBeams(self::BeamLattice, BeamInfo::Array{sBeam, 1})
	nBeamInfoCount = UInt64(length(BeamInfo))
	pBeamInfoBuffer = length(BeamInfo) == 0 ? Ptr{sBeam}(C_NULL) : pointer(BeamInfo)
	GC.@preserve BeamInfo begin
		err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_setbeams], Int32, (Ptr{Cvoid}, UInt64, Ptr{sBeam}), self.handle, nBeamInfoCount, pBeamInfoBuffer)
	end
	_checkError(self.wrapper, self, err)
end

function GetBeams(self::BeamLattice)
	nBeamInfoCount = UInt64(0)
	nBeamInfoNeeded = Ref{UInt64}(0)
	pBeamInfoBuffer = Ptr{sBeam}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_getbeams], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{sBeam}), self.handle, nBeamInfoCount, nBeamInfoNeeded, pBeamInfoBuffer)
	_checkError(self.wrapper, self, err)
	pBeamInfoBuffer = Array{sBeam}(undef, Int(nBeamInfoNeeded[]))
	nBeamInfoCount = UInt64(length(pBeamInfoBuffer))
	pBeamInfoBuffer_ptr = pointer(pBeamInfoBuffer)
	GC.@preserve pBeamInfoBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_getbeams], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{sBeam}), self.handle, nBeamInfoCount, nBeamInfoNeeded, pBeamInfoBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pBeamInfoBuffer
end

function GetBallCount(self::BeamLattice)
	pCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_getballcount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function GetBall(self::BeamLattice, Index::UInt32)
	pBallInfo = Ref{sBall}()
	err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_getball], Int32, (Ptr{Cvoid}, UInt32, Ref{sBall}), self.handle, Index, pBallInfo)
	_checkError(self.wrapper, self, err)
	return pBallInfo[]
end

function AddBall(self::BeamLattice, BallInfo::sBall)
	pBallInfo = Ref{sBall}(BallInfo)
	pIndex = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_addball], Int32, (Ptr{Cvoid}, Ref{sBall}, Ref{UInt32}), self.handle, pBallInfo, pIndex)
	_checkError(self.wrapper, self, err)
	return pIndex[]
end

function SetBall(self::BeamLattice, Index::UInt32, BallInfo::sBall)
	pBallInfo = Ref{sBall}(BallInfo)
	err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_setball], Int32, (Ptr{Cvoid}, UInt32, Ref{sBall}), self.handle, Index, pBallInfo)
	_checkError(self.wrapper, self, err)
end

function SetBalls(self::BeamLattice, BallInfo::Array{sBall, 1})
	nBallInfoCount = UInt64(length(BallInfo))
	pBallInfoBuffer = length(BallInfo) == 0 ? Ptr{sBall}(C_NULL) : pointer(BallInfo)
	GC.@preserve BallInfo begin
		err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_setballs], Int32, (Ptr{Cvoid}, UInt64, Ptr{sBall}), self.handle, nBallInfoCount, pBallInfoBuffer)
	end
	_checkError(self.wrapper, self, err)
end

function GetBalls(self::BeamLattice)
	nBallInfoCount = UInt64(0)
	nBallInfoNeeded = Ref{UInt64}(0)
	pBallInfoBuffer = Ptr{sBall}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_getballs], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{sBall}), self.handle, nBallInfoCount, nBallInfoNeeded, pBallInfoBuffer)
	_checkError(self.wrapper, self, err)
	pBallInfoBuffer = Array{sBall}(undef, Int(nBallInfoNeeded[]))
	nBallInfoCount = UInt64(length(pBallInfoBuffer))
	pBallInfoBuffer_ptr = pointer(pBallInfoBuffer)
	GC.@preserve pBallInfoBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_getballs], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{sBall}), self.handle, nBallInfoCount, nBallInfoNeeded, pBallInfoBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pBallInfoBuffer
end

function GetBeamSetCount(self::BeamLattice)
	pCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_getbeamsetcount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function AddBeamSet(self::BeamLattice)
	pBeamSet = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_addbeamset], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pBeamSet)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pBeamSet[])
end

function GetBeamSet(self::BeamLattice, Index::UInt32)
	pBeamSet = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_beamlattice_getbeamset], Int32, (Ptr{Cvoid}, UInt32, Ref{Ptr{Cvoid}}), self.handle, Index, pBeamSet)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pBeamSet[])
end

function ClassTypeId(self::BeamLattice)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetFunctionResourceID(self::FunctionReference)
	pUniqueResourceID = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_functionreference_getfunctionresourceid], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pUniqueResourceID)
	_checkError(self.wrapper, self, err)
	return pUniqueResourceID[]
end

function SetFunctionResourceID(self::FunctionReference, UniqueResourceID::UInt32)
	err = ccall(self.wrapper.funcs[:lib3mf_functionreference_setfunctionresourceid], Int32, (Ptr{Cvoid}, UInt32), self.handle, UniqueResourceID)
	_checkError(self.wrapper, self, err)
end

function GetTransform(self::FunctionReference)
	pTransform = Ref{sTransform}()
	err = ccall(self.wrapper.funcs[:lib3mf_functionreference_gettransform], Int32, (Ptr{Cvoid}, Ref{sTransform}), self.handle, pTransform)
	_checkError(self.wrapper, self, err)
	return pTransform[]
end

function SetTransform(self::FunctionReference, Transform::sTransform)
	pTransform = Ref{sTransform}(Transform)
	err = ccall(self.wrapper.funcs[:lib3mf_functionreference_settransform], Int32, (Ptr{Cvoid}, Ref{sTransform}), self.handle, pTransform)
	_checkError(self.wrapper, self, err)
end

function GetChannelName(self::FunctionReference)
	nChannelNameBufferSize = UInt64(0)
	nChannelNameNeeded = Ref{UInt64}(0)
	pChannelNameBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_functionreference_getchannelname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nChannelNameBufferSize, nChannelNameNeeded, pChannelNameBuffer)
	_checkError(self.wrapper, self, err)
	pChannelNameBuffer = Array{UInt8}(undef, Int(nChannelNameNeeded[]))
	nChannelNameBufferSize = UInt64(length(pChannelNameBuffer))
	pChannelNameBuffer_ptr = pointer(pChannelNameBuffer)
	GC.@preserve pChannelNameBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_functionreference_getchannelname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nChannelNameBufferSize, nChannelNameNeeded, pChannelNameBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pChannelNameBuffer_ptr)
end

function SetChannelName(self::FunctionReference, ChannelName::AbstractString)
	GC.@preserve ChannelName begin
		err = ccall(self.wrapper.funcs[:lib3mf_functionreference_setchannelname], Int32, (Ptr{Cvoid}, Cstring), self.handle, ChannelName)
	end
	_checkError(self.wrapper, self, err)
end

function SetMinFeatureSize(self::FunctionReference, MinFeatureSize::Cdouble)
	err = ccall(self.wrapper.funcs[:lib3mf_functionreference_setminfeaturesize], Int32, (Ptr{Cvoid}, Cdouble), self.handle, MinFeatureSize)
	_checkError(self.wrapper, self, err)
end

function GetMinFeatureSize(self::FunctionReference)
	pMinFeatureSize = Ref{Cdouble}()
	err = ccall(self.wrapper.funcs[:lib3mf_functionreference_getminfeaturesize], Int32, (Ptr{Cvoid}, Ref{Cdouble}), self.handle, pMinFeatureSize)
	_checkError(self.wrapper, self, err)
	return pMinFeatureSize[]
end

function SetFallBackValue(self::FunctionReference, FallBackValue::Cdouble)
	err = ccall(self.wrapper.funcs[:lib3mf_functionreference_setfallbackvalue], Int32, (Ptr{Cvoid}, Cdouble), self.handle, FallBackValue)
	_checkError(self.wrapper, self, err)
end

function GetFallBackValue(self::FunctionReference)
	pFallBackValue = Ref{Cdouble}()
	err = ccall(self.wrapper.funcs[:lib3mf_functionreference_getfallbackvalue], Int32, (Ptr{Cvoid}, Ref{Cdouble}), self.handle, pFallBackValue)
	_checkError(self.wrapper, self, err)
	return pFallBackValue[]
end

function ClassTypeId(self::FunctionReference)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetFunctionResourceID(self::VolumeDataColor)
	return GetFunctionResourceID(FunctionReference(self.handle, self.wrapper))
end

function SetFunctionResourceID(self::VolumeDataColor, UniqueResourceID::UInt32)
	return SetFunctionResourceID(FunctionReference(self.handle, self.wrapper), UniqueResourceID)
end

function GetTransform(self::VolumeDataColor)
	return GetTransform(FunctionReference(self.handle, self.wrapper))
end

function SetTransform(self::VolumeDataColor, Transform::sTransform)
	return SetTransform(FunctionReference(self.handle, self.wrapper), Transform)
end

function GetChannelName(self::VolumeDataColor)
	return GetChannelName(FunctionReference(self.handle, self.wrapper))
end

function SetChannelName(self::VolumeDataColor, ChannelName::AbstractString)
	return SetChannelName(FunctionReference(self.handle, self.wrapper), ChannelName)
end

function SetMinFeatureSize(self::VolumeDataColor, MinFeatureSize::Cdouble)
	return SetMinFeatureSize(FunctionReference(self.handle, self.wrapper), MinFeatureSize)
end

function GetMinFeatureSize(self::VolumeDataColor)
	return GetMinFeatureSize(FunctionReference(self.handle, self.wrapper))
end

function SetFallBackValue(self::VolumeDataColor, FallBackValue::Cdouble)
	return SetFallBackValue(FunctionReference(self.handle, self.wrapper), FallBackValue)
end

function GetFallBackValue(self::VolumeDataColor)
	return GetFallBackValue(FunctionReference(self.handle, self.wrapper))
end

function ClassTypeId(self::VolumeDataColor)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetFunctionResourceID(self::MaterialMapping)
	return GetFunctionResourceID(FunctionReference(self.handle, self.wrapper))
end

function SetFunctionResourceID(self::MaterialMapping, UniqueResourceID::UInt32)
	return SetFunctionResourceID(FunctionReference(self.handle, self.wrapper), UniqueResourceID)
end

function GetTransform(self::MaterialMapping)
	return GetTransform(FunctionReference(self.handle, self.wrapper))
end

function SetTransform(self::MaterialMapping, Transform::sTransform)
	return SetTransform(FunctionReference(self.handle, self.wrapper), Transform)
end

function GetChannelName(self::MaterialMapping)
	return GetChannelName(FunctionReference(self.handle, self.wrapper))
end

function SetChannelName(self::MaterialMapping, ChannelName::AbstractString)
	return SetChannelName(FunctionReference(self.handle, self.wrapper), ChannelName)
end

function SetMinFeatureSize(self::MaterialMapping, MinFeatureSize::Cdouble)
	return SetMinFeatureSize(FunctionReference(self.handle, self.wrapper), MinFeatureSize)
end

function GetMinFeatureSize(self::MaterialMapping)
	return GetMinFeatureSize(FunctionReference(self.handle, self.wrapper))
end

function SetFallBackValue(self::MaterialMapping, FallBackValue::Cdouble)
	return SetFallBackValue(FunctionReference(self.handle, self.wrapper), FallBackValue)
end

function GetFallBackValue(self::MaterialMapping)
	return GetFallBackValue(FunctionReference(self.handle, self.wrapper))
end

function ClassTypeId(self::MaterialMapping)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetBaseMaterialGroup(self::VolumeDataComposite)
	pBaseMaterialGroupInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_volumedatacomposite_getbasematerialgroup], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pBaseMaterialGroupInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pBaseMaterialGroupInstance[])
end

function SetBaseMaterialGroup(self::VolumeDataComposite, BaseMaterialGroupInstance::BaseMaterialGroup)
	err = ccall(self.wrapper.funcs[:lib3mf_volumedatacomposite_setbasematerialgroup], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, BaseMaterialGroupInstance.handle)
	_checkError(self.wrapper, self, err)
end

function GetMaterialMappingCount(self::VolumeDataComposite)
	pCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_volumedatacomposite_getmaterialmappingcount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function GetMaterialMapping(self::VolumeDataComposite, Index::UInt32)
	pTheMaterialMapping = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_volumedatacomposite_getmaterialmapping], Int32, (Ptr{Cvoid}, UInt32, Ref{Ptr{Cvoid}}), self.handle, Index, pTheMaterialMapping)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheMaterialMapping[])
end

function AddMaterialMapping(self::VolumeDataComposite, Transform::sTransform)
	pTransform = Ref{sTransform}(Transform)
	pTheMaterialMapping = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_volumedatacomposite_addmaterialmapping], Int32, (Ptr{Cvoid}, Ref{sTransform}, Ref{Ptr{Cvoid}}), self.handle, pTransform, pTheMaterialMapping)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheMaterialMapping[])
end

function RemoveMaterialMapping(self::VolumeDataComposite, Index::UInt32)
	err = ccall(self.wrapper.funcs[:lib3mf_volumedatacomposite_removematerialmapping], Int32, (Ptr{Cvoid}, UInt32), self.handle, Index)
	_checkError(self.wrapper, self, err)
end

function ClassTypeId(self::VolumeDataComposite)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetName(self::VolumeDataProperty)
	nPropertyNameBufferSize = UInt64(0)
	nPropertyNameNeeded = Ref{UInt64}(0)
	pPropertyNameBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_volumedataproperty_getname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nPropertyNameBufferSize, nPropertyNameNeeded, pPropertyNameBuffer)
	_checkError(self.wrapper, self, err)
	pPropertyNameBuffer = Array{UInt8}(undef, Int(nPropertyNameNeeded[]))
	nPropertyNameBufferSize = UInt64(length(pPropertyNameBuffer))
	pPropertyNameBuffer_ptr = pointer(pPropertyNameBuffer)
	GC.@preserve pPropertyNameBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_volumedataproperty_getname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nPropertyNameBufferSize, nPropertyNameNeeded, pPropertyNameBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pPropertyNameBuffer_ptr)
end

function SetIsRequired(self::VolumeDataProperty, IsRequired::Cbool)
	err = ccall(self.wrapper.funcs[:lib3mf_volumedataproperty_setisrequired], Int32, (Ptr{Cvoid}, Cbool), self.handle, IsRequired)
	_checkError(self.wrapper, self, err)
end

function IsRequired(self::VolumeDataProperty)
	pIsRequired = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_volumedataproperty_isrequired], Int32, (Ptr{Cvoid}, Ref{Cbool}), self.handle, pIsRequired)
	_checkError(self.wrapper, self, err)
	return pIsRequired[] != 0
end

function GetFunctionResourceID(self::VolumeDataProperty)
	return GetFunctionResourceID(FunctionReference(self.handle, self.wrapper))
end

function SetFunctionResourceID(self::VolumeDataProperty, UniqueResourceID::UInt32)
	return SetFunctionResourceID(FunctionReference(self.handle, self.wrapper), UniqueResourceID)
end

function GetTransform(self::VolumeDataProperty)
	return GetTransform(FunctionReference(self.handle, self.wrapper))
end

function SetTransform(self::VolumeDataProperty, Transform::sTransform)
	return SetTransform(FunctionReference(self.handle, self.wrapper), Transform)
end

function GetChannelName(self::VolumeDataProperty)
	return GetChannelName(FunctionReference(self.handle, self.wrapper))
end

function SetChannelName(self::VolumeDataProperty, ChannelName::AbstractString)
	return SetChannelName(FunctionReference(self.handle, self.wrapper), ChannelName)
end

function SetMinFeatureSize(self::VolumeDataProperty, MinFeatureSize::Cdouble)
	return SetMinFeatureSize(FunctionReference(self.handle, self.wrapper), MinFeatureSize)
end

function GetMinFeatureSize(self::VolumeDataProperty)
	return GetMinFeatureSize(FunctionReference(self.handle, self.wrapper))
end

function SetFallBackValue(self::VolumeDataProperty, FallBackValue::Cdouble)
	return SetFallBackValue(FunctionReference(self.handle, self.wrapper), FallBackValue)
end

function GetFallBackValue(self::VolumeDataProperty)
	return GetFallBackValue(FunctionReference(self.handle, self.wrapper))
end

function ClassTypeId(self::VolumeDataProperty)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetComposite(self::VolumeData)
	pTheCompositeData = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_volumedata_getcomposite], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pTheCompositeData)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheCompositeData[])
end

function CreateNewComposite(self::VolumeData)
	pTheCompositeData = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_volumedata_createnewcomposite], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pTheCompositeData)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheCompositeData[])
end

function RemoveComposite(self::VolumeData)
	err = ccall(self.wrapper.funcs[:lib3mf_volumedata_removecomposite], Int32, (Ptr{Cvoid},), self.handle)
	_checkError(self.wrapper, self, err)
end

function GetColor(self::VolumeData)
	pTheColorData = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_volumedata_getcolor], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pTheColorData)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheColorData[])
end

function CreateNewColor(self::VolumeData, TheFunction::Function)
	pTheColorData = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_volumedata_createnewcolor], Int32, (Ptr{Cvoid}, Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, TheFunction.handle, pTheColorData)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheColorData[])
end

function RemoveColor(self::VolumeData)
	err = ccall(self.wrapper.funcs[:lib3mf_volumedata_removecolor], Int32, (Ptr{Cvoid},), self.handle)
	_checkError(self.wrapper, self, err)
end

function GetPropertyCount(self::VolumeData)
	pCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_volumedata_getpropertycount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function GetProperty(self::VolumeData, Index::UInt32)
	pTheVolumeDataProperty = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_volumedata_getproperty], Int32, (Ptr{Cvoid}, UInt32, Ref{Ptr{Cvoid}}), self.handle, Index, pTheVolumeDataProperty)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheVolumeDataProperty[])
end

function AddPropertyFromFunction(self::VolumeData, Name::AbstractString, TheFunction::Function)
	pTheVolumeDataProperty = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Name begin
		err = ccall(self.wrapper.funcs[:lib3mf_volumedata_addpropertyfromfunction], Int32, (Ptr{Cvoid}, Cstring, Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, Name, TheFunction.handle, pTheVolumeDataProperty)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheVolumeDataProperty[])
end

function RemoveProperty(self::VolumeData, Index::UInt32)
	err = ccall(self.wrapper.funcs[:lib3mf_volumedata_removeproperty], Int32, (Ptr{Cvoid}, UInt32), self.handle, Index)
	_checkError(self.wrapper, self, err)
end

function GetResourceID(self::VolumeData)
	return GetResourceID(Resource(self.handle, self.wrapper))
end

function GetUniqueResourceID(self::VolumeData)
	return GetUniqueResourceID(Resource(self.handle, self.wrapper))
end

function PackagePart(self::VolumeData)
	return PackagePart(Resource(self.handle, self.wrapper))
end

function SetPackagePart(self::VolumeData, PackagePart::PackagePart)
	return SetPackagePart(Resource(self.handle, self.wrapper), PackagePart)
end

function GetModelResourceID(self::VolumeData)
	return GetModelResourceID(Resource(self.handle, self.wrapper))
end

function ClassTypeId(self::VolumeData)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetObjectResource(self::Component)
	pObjectResource = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_component_getobjectresource], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pObjectResource)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pObjectResource[])
end

function GetObjectResourceID(self::Component)
	pUniqueResourceID = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_component_getobjectresourceid], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pUniqueResourceID)
	_checkError(self.wrapper, self, err)
	return pUniqueResourceID[]
end

function GetUUID(self::Component)
	pHasUUID = Ref{Cbool}()
	nUUIDBufferSize = UInt64(0)
	nUUIDNeeded = Ref{UInt64}(0)
	pUUIDBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_component_getuuid], Int32, (Ptr{Cvoid}, Ref{Cbool}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, pHasUUID, nUUIDBufferSize, nUUIDNeeded, pUUIDBuffer)
	_checkError(self.wrapper, self, err)
	pUUIDBuffer = Array{UInt8}(undef, Int(nUUIDNeeded[]))
	nUUIDBufferSize = UInt64(length(pUUIDBuffer))
	pUUIDBuffer_ptr = pointer(pUUIDBuffer)
	GC.@preserve pUUIDBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_component_getuuid], Int32, (Ptr{Cvoid}, Ref{Cbool}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, pHasUUID, nUUIDBufferSize, nUUIDNeeded, pUUIDBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pHasUUID[] != 0, unsafe_string(pUUIDBuffer_ptr)
end

function SetUUID(self::Component, UUID::AbstractString)
	GC.@preserve UUID begin
		err = ccall(self.wrapper.funcs[:lib3mf_component_setuuid], Int32, (Ptr{Cvoid}, Cstring), self.handle, UUID)
	end
	_checkError(self.wrapper, self, err)
end

function HasTransform(self::Component)
	pHasTransform = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_component_hastransform], Int32, (Ptr{Cvoid}, Ref{Cbool}), self.handle, pHasTransform)
	_checkError(self.wrapper, self, err)
	return pHasTransform[] != 0
end

function GetTransform(self::Component)
	pTransform = Ref{sTransform}()
	err = ccall(self.wrapper.funcs[:lib3mf_component_gettransform], Int32, (Ptr{Cvoid}, Ref{sTransform}), self.handle, pTransform)
	_checkError(self.wrapper, self, err)
	return pTransform[]
end

function SetTransform(self::Component, Transform::sTransform)
	pTransform = Ref{sTransform}(Transform)
	err = ccall(self.wrapper.funcs[:lib3mf_component_settransform], Int32, (Ptr{Cvoid}, Ref{sTransform}), self.handle, pTransform)
	_checkError(self.wrapper, self, err)
end

function ClassTypeId(self::Component)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function AddComponent(self::ComponentsObject, ObjectResource::Object, Transform::sTransform)
	pTransform = Ref{sTransform}(Transform)
	pComponentInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_componentsobject_addcomponent], Int32, (Ptr{Cvoid}, Ptr{Cvoid}, Ref{sTransform}, Ref{Ptr{Cvoid}}), self.handle, ObjectResource.handle, pTransform, pComponentInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pComponentInstance[])
end

function GetComponent(self::ComponentsObject, Index::UInt32)
	pComponentInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_componentsobject_getcomponent], Int32, (Ptr{Cvoid}, UInt32, Ref{Ptr{Cvoid}}), self.handle, Index, pComponentInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pComponentInstance[])
end

function GetComponentCount(self::ComponentsObject)
	pCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_componentsobject_getcomponentcount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function GetType(self::ComponentsObject)
	return GetType(Object(self.handle, self.wrapper))
end

function SetType(self::ComponentsObject, ObjectType::eObjectType)
	return SetType(Object(self.handle, self.wrapper), ObjectType)
end

function GetName(self::ComponentsObject)
	return GetName(Object(self.handle, self.wrapper))
end

function SetName(self::ComponentsObject, Name::AbstractString)
	return SetName(Object(self.handle, self.wrapper), Name)
end

function GetPartNumber(self::ComponentsObject)
	return GetPartNumber(Object(self.handle, self.wrapper))
end

function SetPartNumber(self::ComponentsObject, PartNumber::AbstractString)
	return SetPartNumber(Object(self.handle, self.wrapper), PartNumber)
end

function IsMeshObject(self::ComponentsObject)
	return IsMeshObject(Object(self.handle, self.wrapper))
end

function IsComponentsObject(self::ComponentsObject)
	return IsComponentsObject(Object(self.handle, self.wrapper))
end

function IsLevelSetObject(self::ComponentsObject)
	return IsLevelSetObject(Object(self.handle, self.wrapper))
end

function IsValid(self::ComponentsObject)
	return IsValid(Object(self.handle, self.wrapper))
end

function SetAttachmentAsThumbnail(self::ComponentsObject, Attachment::Attachment)
	return SetAttachmentAsThumbnail(Object(self.handle, self.wrapper), Attachment)
end

function GetThumbnailAttachment(self::ComponentsObject)
	return GetThumbnailAttachment(Object(self.handle, self.wrapper))
end

function ClearThumbnailAttachment(self::ComponentsObject)
	return ClearThumbnailAttachment(Object(self.handle, self.wrapper))
end

function GetOutbox(self::ComponentsObject)
	return GetOutbox(Object(self.handle, self.wrapper))
end

function GetUUID(self::ComponentsObject)
	return GetUUID(Object(self.handle, self.wrapper))
end

function SetUUID(self::ComponentsObject, UUID::AbstractString)
	return SetUUID(Object(self.handle, self.wrapper), UUID)
end

function GetMetaDataGroup(self::ComponentsObject)
	return GetMetaDataGroup(Object(self.handle, self.wrapper))
end

function SetSlicesMeshResolution(self::ComponentsObject, MeshResolution::eSlicesMeshResolution)
	return SetSlicesMeshResolution(Object(self.handle, self.wrapper), MeshResolution)
end

function GetSlicesMeshResolution(self::ComponentsObject)
	return GetSlicesMeshResolution(Object(self.handle, self.wrapper))
end

function HasSlices(self::ComponentsObject, Recursive::Cbool)
	return HasSlices(Object(self.handle, self.wrapper), Recursive)
end

function ClearSliceStack(self::ComponentsObject)
	return ClearSliceStack(Object(self.handle, self.wrapper))
end

function GetSliceStack(self::ComponentsObject)
	return GetSliceStack(Object(self.handle, self.wrapper))
end

function AssignSliceStack(self::ComponentsObject, SliceStackInstance::SliceStack)
	return AssignSliceStack(Object(self.handle, self.wrapper), SliceStackInstance)
end

function GetResourceID(self::ComponentsObject)
	return GetResourceID(Resource(self.handle, self.wrapper))
end

function GetUniqueResourceID(self::ComponentsObject)
	return GetUniqueResourceID(Resource(self.handle, self.wrapper))
end

function PackagePart(self::ComponentsObject)
	return PackagePart(Resource(self.handle, self.wrapper))
end

function SetPackagePart(self::ComponentsObject, PackagePart::PackagePart)
	return SetPackagePart(Resource(self.handle, self.wrapper), PackagePart)
end

function GetModelResourceID(self::ComponentsObject)
	return GetModelResourceID(Resource(self.handle, self.wrapper))
end

function ClassTypeId(self::ComponentsObject)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function SetName(self::BeamSet, Name::AbstractString)
	GC.@preserve Name begin
		err = ccall(self.wrapper.funcs[:lib3mf_beamset_setname], Int32, (Ptr{Cvoid}, Cstring), self.handle, Name)
	end
	_checkError(self.wrapper, self, err)
end

function GetName(self::BeamSet)
	nNameBufferSize = UInt64(0)
	nNameNeeded = Ref{UInt64}(0)
	pNameBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_beamset_getname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nNameBufferSize, nNameNeeded, pNameBuffer)
	_checkError(self.wrapper, self, err)
	pNameBuffer = Array{UInt8}(undef, Int(nNameNeeded[]))
	nNameBufferSize = UInt64(length(pNameBuffer))
	pNameBuffer_ptr = pointer(pNameBuffer)
	GC.@preserve pNameBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_beamset_getname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nNameBufferSize, nNameNeeded, pNameBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pNameBuffer_ptr)
end

function SetIdentifier(self::BeamSet, Identifier::AbstractString)
	GC.@preserve Identifier begin
		err = ccall(self.wrapper.funcs[:lib3mf_beamset_setidentifier], Int32, (Ptr{Cvoid}, Cstring), self.handle, Identifier)
	end
	_checkError(self.wrapper, self, err)
end

function GetIdentifier(self::BeamSet)
	nIdentifierBufferSize = UInt64(0)
	nIdentifierNeeded = Ref{UInt64}(0)
	pIdentifierBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_beamset_getidentifier], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nIdentifierBufferSize, nIdentifierNeeded, pIdentifierBuffer)
	_checkError(self.wrapper, self, err)
	pIdentifierBuffer = Array{UInt8}(undef, Int(nIdentifierNeeded[]))
	nIdentifierBufferSize = UInt64(length(pIdentifierBuffer))
	pIdentifierBuffer_ptr = pointer(pIdentifierBuffer)
	GC.@preserve pIdentifierBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_beamset_getidentifier], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nIdentifierBufferSize, nIdentifierNeeded, pIdentifierBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pIdentifierBuffer_ptr)
end

function GetReferenceCount(self::BeamSet)
	pCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_beamset_getreferencecount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function SetReferences(self::BeamSet, References::Array{UInt32, 1})
	nReferencesCount = UInt64(length(References))
	pReferencesBuffer = length(References) == 0 ? Ptr{UInt32}(C_NULL) : pointer(References)
	GC.@preserve References begin
		err = ccall(self.wrapper.funcs[:lib3mf_beamset_setreferences], Int32, (Ptr{Cvoid}, UInt64, Ptr{UInt32}), self.handle, nReferencesCount, pReferencesBuffer)
	end
	_checkError(self.wrapper, self, err)
end

function GetReferences(self::BeamSet)
	nReferencesCount = UInt64(0)
	nReferencesNeeded = Ref{UInt64}(0)
	pReferencesBuffer = Ptr{UInt32}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_beamset_getreferences], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt32}), self.handle, nReferencesCount, nReferencesNeeded, pReferencesBuffer)
	_checkError(self.wrapper, self, err)
	pReferencesBuffer = Array{UInt32}(undef, Int(nReferencesNeeded[]))
	nReferencesCount = UInt64(length(pReferencesBuffer))
	pReferencesBuffer_ptr = pointer(pReferencesBuffer)
	GC.@preserve pReferencesBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_beamset_getreferences], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt32}), self.handle, nReferencesCount, nReferencesNeeded, pReferencesBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pReferencesBuffer
end

function GetBallReferenceCount(self::BeamSet)
	pCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_beamset_getballreferencecount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function SetBallReferences(self::BeamSet, BallReferences::Array{UInt32, 1})
	nBallReferencesCount = UInt64(length(BallReferences))
	pBallReferencesBuffer = length(BallReferences) == 0 ? Ptr{UInt32}(C_NULL) : pointer(BallReferences)
	GC.@preserve BallReferences begin
		err = ccall(self.wrapper.funcs[:lib3mf_beamset_setballreferences], Int32, (Ptr{Cvoid}, UInt64, Ptr{UInt32}), self.handle, nBallReferencesCount, pBallReferencesBuffer)
	end
	_checkError(self.wrapper, self, err)
end

function GetBallReferences(self::BeamSet)
	nBallReferencesCount = UInt64(0)
	nBallReferencesNeeded = Ref{UInt64}(0)
	pBallReferencesBuffer = Ptr{UInt32}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_beamset_getballreferences], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt32}), self.handle, nBallReferencesCount, nBallReferencesNeeded, pBallReferencesBuffer)
	_checkError(self.wrapper, self, err)
	pBallReferencesBuffer = Array{UInt32}(undef, Int(nBallReferencesNeeded[]))
	nBallReferencesCount = UInt64(length(pBallReferencesBuffer))
	pBallReferencesBuffer_ptr = pointer(pBallReferencesBuffer)
	GC.@preserve pBallReferencesBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_beamset_getballreferences], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt32}), self.handle, nBallReferencesCount, nBallReferencesNeeded, pBallReferencesBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pBallReferencesBuffer
end

function ClassTypeId(self::BeamSet)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetCount(self::BaseMaterialGroup)
	pCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_basematerialgroup_getcount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function GetAllPropertyIDs(self::BaseMaterialGroup)
	nPropertyIDsCount = UInt64(0)
	nPropertyIDsNeeded = Ref{UInt64}(0)
	pPropertyIDsBuffer = Ptr{UInt32}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_basematerialgroup_getallpropertyids], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt32}), self.handle, nPropertyIDsCount, nPropertyIDsNeeded, pPropertyIDsBuffer)
	_checkError(self.wrapper, self, err)
	pPropertyIDsBuffer = Array{UInt32}(undef, Int(nPropertyIDsNeeded[]))
	nPropertyIDsCount = UInt64(length(pPropertyIDsBuffer))
	pPropertyIDsBuffer_ptr = pointer(pPropertyIDsBuffer)
	GC.@preserve pPropertyIDsBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_basematerialgroup_getallpropertyids], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt32}), self.handle, nPropertyIDsCount, nPropertyIDsNeeded, pPropertyIDsBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pPropertyIDsBuffer
end

function AddMaterial(self::BaseMaterialGroup, Name::AbstractString, DisplayColor::sColor)
	pDisplayColor = Ref{sColor}(DisplayColor)
	pPropertyID = Ref{UInt32}()
	GC.@preserve Name begin
		err = ccall(self.wrapper.funcs[:lib3mf_basematerialgroup_addmaterial], Int32, (Ptr{Cvoid}, Cstring, Ref{sColor}, Ref{UInt32}), self.handle, Name, pDisplayColor, pPropertyID)
	end
	_checkError(self.wrapper, self, err)
	return pPropertyID[]
end

function RemoveMaterial(self::BaseMaterialGroup, PropertyID::UInt32)
	err = ccall(self.wrapper.funcs[:lib3mf_basematerialgroup_removematerial], Int32, (Ptr{Cvoid}, UInt32), self.handle, PropertyID)
	_checkError(self.wrapper, self, err)
end

function GetName(self::BaseMaterialGroup, PropertyID::UInt32)
	nNameBufferSize = UInt64(0)
	nNameNeeded = Ref{UInt64}(0)
	pNameBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_basematerialgroup_getname], Int32, (Ptr{Cvoid}, UInt32, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, PropertyID, nNameBufferSize, nNameNeeded, pNameBuffer)
	_checkError(self.wrapper, self, err)
	pNameBuffer = Array{UInt8}(undef, Int(nNameNeeded[]))
	nNameBufferSize = UInt64(length(pNameBuffer))
	pNameBuffer_ptr = pointer(pNameBuffer)
	GC.@preserve pNameBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_basematerialgroup_getname], Int32, (Ptr{Cvoid}, UInt32, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, PropertyID, nNameBufferSize, nNameNeeded, pNameBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pNameBuffer_ptr)
end

function SetName(self::BaseMaterialGroup, PropertyID::UInt32, Name::AbstractString)
	GC.@preserve Name begin
		err = ccall(self.wrapper.funcs[:lib3mf_basematerialgroup_setname], Int32, (Ptr{Cvoid}, UInt32, Cstring), self.handle, PropertyID, Name)
	end
	_checkError(self.wrapper, self, err)
end

function SetDisplayColor(self::BaseMaterialGroup, PropertyID::UInt32, TheColor::sColor)
	pTheColor = Ref{sColor}(TheColor)
	err = ccall(self.wrapper.funcs[:lib3mf_basematerialgroup_setdisplaycolor], Int32, (Ptr{Cvoid}, UInt32, Ref{sColor}), self.handle, PropertyID, pTheColor)
	_checkError(self.wrapper, self, err)
end

function GetDisplayColor(self::BaseMaterialGroup, PropertyID::UInt32)
	pTheColor = Ref{sColor}()
	err = ccall(self.wrapper.funcs[:lib3mf_basematerialgroup_getdisplaycolor], Int32, (Ptr{Cvoid}, UInt32, Ref{sColor}), self.handle, PropertyID, pTheColor)
	_checkError(self.wrapper, self, err)
	return pTheColor[]
end

function GetResourceID(self::BaseMaterialGroup)
	return GetResourceID(Resource(self.handle, self.wrapper))
end

function GetUniqueResourceID(self::BaseMaterialGroup)
	return GetUniqueResourceID(Resource(self.handle, self.wrapper))
end

function PackagePart(self::BaseMaterialGroup)
	return PackagePart(Resource(self.handle, self.wrapper))
end

function SetPackagePart(self::BaseMaterialGroup, PackagePart::PackagePart)
	return SetPackagePart(Resource(self.handle, self.wrapper), PackagePart)
end

function GetModelResourceID(self::BaseMaterialGroup)
	return GetModelResourceID(Resource(self.handle, self.wrapper))
end

function ClassTypeId(self::BaseMaterialGroup)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetCount(self::ColorGroup)
	pCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_colorgroup_getcount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function GetAllPropertyIDs(self::ColorGroup)
	nPropertyIDsCount = UInt64(0)
	nPropertyIDsNeeded = Ref{UInt64}(0)
	pPropertyIDsBuffer = Ptr{UInt32}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_colorgroup_getallpropertyids], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt32}), self.handle, nPropertyIDsCount, nPropertyIDsNeeded, pPropertyIDsBuffer)
	_checkError(self.wrapper, self, err)
	pPropertyIDsBuffer = Array{UInt32}(undef, Int(nPropertyIDsNeeded[]))
	nPropertyIDsCount = UInt64(length(pPropertyIDsBuffer))
	pPropertyIDsBuffer_ptr = pointer(pPropertyIDsBuffer)
	GC.@preserve pPropertyIDsBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_colorgroup_getallpropertyids], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt32}), self.handle, nPropertyIDsCount, nPropertyIDsNeeded, pPropertyIDsBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pPropertyIDsBuffer
end

function AddColor(self::ColorGroup, TheColor::sColor)
	pTheColor = Ref{sColor}(TheColor)
	pPropertyID = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_colorgroup_addcolor], Int32, (Ptr{Cvoid}, Ref{sColor}, Ref{UInt32}), self.handle, pTheColor, pPropertyID)
	_checkError(self.wrapper, self, err)
	return pPropertyID[]
end

function RemoveColor(self::ColorGroup, PropertyID::UInt32)
	err = ccall(self.wrapper.funcs[:lib3mf_colorgroup_removecolor], Int32, (Ptr{Cvoid}, UInt32), self.handle, PropertyID)
	_checkError(self.wrapper, self, err)
end

function SetColor(self::ColorGroup, PropertyID::UInt32, TheColor::sColor)
	pTheColor = Ref{sColor}(TheColor)
	err = ccall(self.wrapper.funcs[:lib3mf_colorgroup_setcolor], Int32, (Ptr{Cvoid}, UInt32, Ref{sColor}), self.handle, PropertyID, pTheColor)
	_checkError(self.wrapper, self, err)
end

function GetColor(self::ColorGroup, PropertyID::UInt32)
	pTheColor = Ref{sColor}()
	err = ccall(self.wrapper.funcs[:lib3mf_colorgroup_getcolor], Int32, (Ptr{Cvoid}, UInt32, Ref{sColor}), self.handle, PropertyID, pTheColor)
	_checkError(self.wrapper, self, err)
	return pTheColor[]
end

function GetResourceID(self::ColorGroup)
	return GetResourceID(Resource(self.handle, self.wrapper))
end

function GetUniqueResourceID(self::ColorGroup)
	return GetUniqueResourceID(Resource(self.handle, self.wrapper))
end

function PackagePart(self::ColorGroup)
	return PackagePart(Resource(self.handle, self.wrapper))
end

function SetPackagePart(self::ColorGroup, PackagePart::PackagePart)
	return SetPackagePart(Resource(self.handle, self.wrapper), PackagePart)
end

function GetModelResourceID(self::ColorGroup)
	return GetModelResourceID(Resource(self.handle, self.wrapper))
end

function ClassTypeId(self::ColorGroup)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetCount(self::Texture2DGroup)
	pCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_texture2dgroup_getcount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function GetAllPropertyIDs(self::Texture2DGroup)
	nPropertyIDsCount = UInt64(0)
	nPropertyIDsNeeded = Ref{UInt64}(0)
	pPropertyIDsBuffer = Ptr{UInt32}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_texture2dgroup_getallpropertyids], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt32}), self.handle, nPropertyIDsCount, nPropertyIDsNeeded, pPropertyIDsBuffer)
	_checkError(self.wrapper, self, err)
	pPropertyIDsBuffer = Array{UInt32}(undef, Int(nPropertyIDsNeeded[]))
	nPropertyIDsCount = UInt64(length(pPropertyIDsBuffer))
	pPropertyIDsBuffer_ptr = pointer(pPropertyIDsBuffer)
	GC.@preserve pPropertyIDsBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_texture2dgroup_getallpropertyids], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt32}), self.handle, nPropertyIDsCount, nPropertyIDsNeeded, pPropertyIDsBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pPropertyIDsBuffer
end

function AddTex2Coord(self::Texture2DGroup, UVCoordinate::sTex2Coord)
	pUVCoordinate = Ref{sTex2Coord}(UVCoordinate)
	pPropertyID = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_texture2dgroup_addtex2coord], Int32, (Ptr{Cvoid}, Ref{sTex2Coord}, Ref{UInt32}), self.handle, pUVCoordinate, pPropertyID)
	_checkError(self.wrapper, self, err)
	return pPropertyID[]
end

function GetTex2Coord(self::Texture2DGroup, PropertyID::UInt32)
	pUVCoordinate = Ref{sTex2Coord}()
	err = ccall(self.wrapper.funcs[:lib3mf_texture2dgroup_gettex2coord], Int32, (Ptr{Cvoid}, UInt32, Ref{sTex2Coord}), self.handle, PropertyID, pUVCoordinate)
	_checkError(self.wrapper, self, err)
	return pUVCoordinate[]
end

function RemoveTex2Coord(self::Texture2DGroup, PropertyID::UInt32)
	err = ccall(self.wrapper.funcs[:lib3mf_texture2dgroup_removetex2coord], Int32, (Ptr{Cvoid}, UInt32), self.handle, PropertyID)
	_checkError(self.wrapper, self, err)
end

function GetTexture2D(self::Texture2DGroup)
	pTexture2DInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_texture2dgroup_gettexture2d], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pTexture2DInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTexture2DInstance[])
end

function GetResourceID(self::Texture2DGroup)
	return GetResourceID(Resource(self.handle, self.wrapper))
end

function GetUniqueResourceID(self::Texture2DGroup)
	return GetUniqueResourceID(Resource(self.handle, self.wrapper))
end

function PackagePart(self::Texture2DGroup)
	return PackagePart(Resource(self.handle, self.wrapper))
end

function SetPackagePart(self::Texture2DGroup, PackagePart::PackagePart)
	return SetPackagePart(Resource(self.handle, self.wrapper), PackagePart)
end

function GetModelResourceID(self::Texture2DGroup)
	return GetModelResourceID(Resource(self.handle, self.wrapper))
end

function ClassTypeId(self::Texture2DGroup)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetCount(self::CompositeMaterials)
	pCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_compositematerials_getcount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function GetAllPropertyIDs(self::CompositeMaterials)
	nPropertyIDsCount = UInt64(0)
	nPropertyIDsNeeded = Ref{UInt64}(0)
	pPropertyIDsBuffer = Ptr{UInt32}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_compositematerials_getallpropertyids], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt32}), self.handle, nPropertyIDsCount, nPropertyIDsNeeded, pPropertyIDsBuffer)
	_checkError(self.wrapper, self, err)
	pPropertyIDsBuffer = Array{UInt32}(undef, Int(nPropertyIDsNeeded[]))
	nPropertyIDsCount = UInt64(length(pPropertyIDsBuffer))
	pPropertyIDsBuffer_ptr = pointer(pPropertyIDsBuffer)
	GC.@preserve pPropertyIDsBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_compositematerials_getallpropertyids], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt32}), self.handle, nPropertyIDsCount, nPropertyIDsNeeded, pPropertyIDsBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pPropertyIDsBuffer
end

function GetBaseMaterialGroup(self::CompositeMaterials)
	pBaseMaterialGroupInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_compositematerials_getbasematerialgroup], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pBaseMaterialGroupInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pBaseMaterialGroupInstance[])
end

function AddComposite(self::CompositeMaterials, Composite::Array{sCompositeConstituent, 1})
	nCompositeCount = UInt64(length(Composite))
	pCompositeBuffer = length(Composite) == 0 ? Ptr{sCompositeConstituent}(C_NULL) : pointer(Composite)
	pPropertyID = Ref{UInt32}()
	GC.@preserve Composite begin
		err = ccall(self.wrapper.funcs[:lib3mf_compositematerials_addcomposite], Int32, (Ptr{Cvoid}, UInt64, Ptr{sCompositeConstituent}, Ref{UInt32}), self.handle, nCompositeCount, pCompositeBuffer, pPropertyID)
	end
	_checkError(self.wrapper, self, err)
	return pPropertyID[]
end

function RemoveComposite(self::CompositeMaterials, PropertyID::UInt32)
	err = ccall(self.wrapper.funcs[:lib3mf_compositematerials_removecomposite], Int32, (Ptr{Cvoid}, UInt32), self.handle, PropertyID)
	_checkError(self.wrapper, self, err)
end

function GetComposite(self::CompositeMaterials, PropertyID::UInt32)
	nCompositeCount = UInt64(0)
	nCompositeNeeded = Ref{UInt64}(0)
	pCompositeBuffer = Ptr{sCompositeConstituent}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_compositematerials_getcomposite], Int32, (Ptr{Cvoid}, UInt32, UInt64, Ref{UInt64}, Ptr{sCompositeConstituent}), self.handle, PropertyID, nCompositeCount, nCompositeNeeded, pCompositeBuffer)
	_checkError(self.wrapper, self, err)
	pCompositeBuffer = Array{sCompositeConstituent}(undef, Int(nCompositeNeeded[]))
	nCompositeCount = UInt64(length(pCompositeBuffer))
	pCompositeBuffer_ptr = pointer(pCompositeBuffer)
	GC.@preserve pCompositeBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_compositematerials_getcomposite], Int32, (Ptr{Cvoid}, UInt32, UInt64, Ref{UInt64}, Ptr{sCompositeConstituent}), self.handle, PropertyID, nCompositeCount, nCompositeNeeded, pCompositeBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pCompositeBuffer
end

function GetResourceID(self::CompositeMaterials)
	return GetResourceID(Resource(self.handle, self.wrapper))
end

function GetUniqueResourceID(self::CompositeMaterials)
	return GetUniqueResourceID(Resource(self.handle, self.wrapper))
end

function PackagePart(self::CompositeMaterials)
	return PackagePart(Resource(self.handle, self.wrapper))
end

function SetPackagePart(self::CompositeMaterials, PackagePart::PackagePart)
	return SetPackagePart(Resource(self.handle, self.wrapper), PackagePart)
end

function GetModelResourceID(self::CompositeMaterials)
	return GetModelResourceID(Resource(self.handle, self.wrapper))
end

function ClassTypeId(self::CompositeMaterials)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetCount(self::MultiPropertyGroup)
	pCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_multipropertygroup_getcount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function GetAllPropertyIDs(self::MultiPropertyGroup)
	nPropertyIDsCount = UInt64(0)
	nPropertyIDsNeeded = Ref{UInt64}(0)
	pPropertyIDsBuffer = Ptr{UInt32}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_multipropertygroup_getallpropertyids], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt32}), self.handle, nPropertyIDsCount, nPropertyIDsNeeded, pPropertyIDsBuffer)
	_checkError(self.wrapper, self, err)
	pPropertyIDsBuffer = Array{UInt32}(undef, Int(nPropertyIDsNeeded[]))
	nPropertyIDsCount = UInt64(length(pPropertyIDsBuffer))
	pPropertyIDsBuffer_ptr = pointer(pPropertyIDsBuffer)
	GC.@preserve pPropertyIDsBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_multipropertygroup_getallpropertyids], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt32}), self.handle, nPropertyIDsCount, nPropertyIDsNeeded, pPropertyIDsBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pPropertyIDsBuffer
end

function AddMultiProperty(self::MultiPropertyGroup, PropertyIDs::Array{UInt32, 1})
	nPropertyIDsCount = UInt64(length(PropertyIDs))
	pPropertyIDsBuffer = length(PropertyIDs) == 0 ? Ptr{UInt32}(C_NULL) : pointer(PropertyIDs)
	pPropertyID = Ref{UInt32}()
	GC.@preserve PropertyIDs begin
		err = ccall(self.wrapper.funcs[:lib3mf_multipropertygroup_addmultiproperty], Int32, (Ptr{Cvoid}, UInt64, Ptr{UInt32}, Ref{UInt32}), self.handle, nPropertyIDsCount, pPropertyIDsBuffer, pPropertyID)
	end
	_checkError(self.wrapper, self, err)
	return pPropertyID[]
end

function SetMultiProperty(self::MultiPropertyGroup, PropertyID::UInt32, PropertyIDs::Array{UInt32, 1})
	nPropertyIDsCount = UInt64(length(PropertyIDs))
	pPropertyIDsBuffer = length(PropertyIDs) == 0 ? Ptr{UInt32}(C_NULL) : pointer(PropertyIDs)
	GC.@preserve PropertyIDs begin
		err = ccall(self.wrapper.funcs[:lib3mf_multipropertygroup_setmultiproperty], Int32, (Ptr{Cvoid}, UInt32, UInt64, Ptr{UInt32}), self.handle, PropertyID, nPropertyIDsCount, pPropertyIDsBuffer)
	end
	_checkError(self.wrapper, self, err)
end

function GetMultiProperty(self::MultiPropertyGroup, PropertyID::UInt32)
	nPropertyIDsCount = UInt64(0)
	nPropertyIDsNeeded = Ref{UInt64}(0)
	pPropertyIDsBuffer = Ptr{UInt32}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_multipropertygroup_getmultiproperty], Int32, (Ptr{Cvoid}, UInt32, UInt64, Ref{UInt64}, Ptr{UInt32}), self.handle, PropertyID, nPropertyIDsCount, nPropertyIDsNeeded, pPropertyIDsBuffer)
	_checkError(self.wrapper, self, err)
	pPropertyIDsBuffer = Array{UInt32}(undef, Int(nPropertyIDsNeeded[]))
	nPropertyIDsCount = UInt64(length(pPropertyIDsBuffer))
	pPropertyIDsBuffer_ptr = pointer(pPropertyIDsBuffer)
	GC.@preserve pPropertyIDsBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_multipropertygroup_getmultiproperty], Int32, (Ptr{Cvoid}, UInt32, UInt64, Ref{UInt64}, Ptr{UInt32}), self.handle, PropertyID, nPropertyIDsCount, nPropertyIDsNeeded, pPropertyIDsBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pPropertyIDsBuffer
end

function RemoveMultiProperty(self::MultiPropertyGroup, PropertyID::UInt32)
	err = ccall(self.wrapper.funcs[:lib3mf_multipropertygroup_removemultiproperty], Int32, (Ptr{Cvoid}, UInt32), self.handle, PropertyID)
	_checkError(self.wrapper, self, err)
end

function GetLayerCount(self::MultiPropertyGroup)
	pCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_multipropertygroup_getlayercount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function AddLayer(self::MultiPropertyGroup, TheLayer::sMultiPropertyLayer)
	pTheLayer = Ref{sMultiPropertyLayer}(TheLayer)
	pLayerIndex = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_multipropertygroup_addlayer], Int32, (Ptr{Cvoid}, Ref{sMultiPropertyLayer}, Ref{UInt32}), self.handle, pTheLayer, pLayerIndex)
	_checkError(self.wrapper, self, err)
	return pLayerIndex[]
end

function GetLayer(self::MultiPropertyGroup, LayerIndex::UInt32)
	pTheLayer = Ref{sMultiPropertyLayer}()
	err = ccall(self.wrapper.funcs[:lib3mf_multipropertygroup_getlayer], Int32, (Ptr{Cvoid}, UInt32, Ref{sMultiPropertyLayer}), self.handle, LayerIndex, pTheLayer)
	_checkError(self.wrapper, self, err)
	return pTheLayer[]
end

function RemoveLayer(self::MultiPropertyGroup, LayerIndex::UInt32)
	err = ccall(self.wrapper.funcs[:lib3mf_multipropertygroup_removelayer], Int32, (Ptr{Cvoid}, UInt32), self.handle, LayerIndex)
	_checkError(self.wrapper, self, err)
end

function GetResourceID(self::MultiPropertyGroup)
	return GetResourceID(Resource(self.handle, self.wrapper))
end

function GetUniqueResourceID(self::MultiPropertyGroup)
	return GetUniqueResourceID(Resource(self.handle, self.wrapper))
end

function PackagePart(self::MultiPropertyGroup)
	return PackagePart(Resource(self.handle, self.wrapper))
end

function SetPackagePart(self::MultiPropertyGroup, PackagePart::PackagePart)
	return SetPackagePart(Resource(self.handle, self.wrapper), PackagePart)
end

function GetModelResourceID(self::MultiPropertyGroup)
	return GetModelResourceID(Resource(self.handle, self.wrapper))
end

function ClassTypeId(self::MultiPropertyGroup)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetName(self::Image3D)
	nNameBufferSize = UInt64(0)
	nNameNeeded = Ref{UInt64}(0)
	pNameBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_image3d_getname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nNameBufferSize, nNameNeeded, pNameBuffer)
	_checkError(self.wrapper, self, err)
	pNameBuffer = Array{UInt8}(undef, Int(nNameNeeded[]))
	nNameBufferSize = UInt64(length(pNameBuffer))
	pNameBuffer_ptr = pointer(pNameBuffer)
	GC.@preserve pNameBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_image3d_getname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nNameBufferSize, nNameNeeded, pNameBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pNameBuffer_ptr)
end

function SetName(self::Image3D, Name::AbstractString)
	GC.@preserve Name begin
		err = ccall(self.wrapper.funcs[:lib3mf_image3d_setname], Int32, (Ptr{Cvoid}, Cstring), self.handle, Name)
	end
	_checkError(self.wrapper, self, err)
end

function IsImageStack(self::Image3D)
	pIsImageStack = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_image3d_isimagestack], Int32, (Ptr{Cvoid}, Ref{Cbool}), self.handle, pIsImageStack)
	_checkError(self.wrapper, self, err)
	return pIsImageStack[] != 0
end

function GetResourceID(self::Image3D)
	return GetResourceID(Resource(self.handle, self.wrapper))
end

function GetUniqueResourceID(self::Image3D)
	return GetUniqueResourceID(Resource(self.handle, self.wrapper))
end

function PackagePart(self::Image3D)
	return PackagePart(Resource(self.handle, self.wrapper))
end

function SetPackagePart(self::Image3D, PackagePart::PackagePart)
	return SetPackagePart(Resource(self.handle, self.wrapper), PackagePart)
end

function GetModelResourceID(self::Image3D)
	return GetModelResourceID(Resource(self.handle, self.wrapper))
end

function ClassTypeId(self::Image3D)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetRowCount(self::ImageStack)
	pRowCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_imagestack_getrowcount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pRowCount)
	_checkError(self.wrapper, self, err)
	return pRowCount[]
end

function SetRowCount(self::ImageStack, RowCount::UInt32)
	err = ccall(self.wrapper.funcs[:lib3mf_imagestack_setrowcount], Int32, (Ptr{Cvoid}, UInt32), self.handle, RowCount)
	_checkError(self.wrapper, self, err)
end

function GetColumnCount(self::ImageStack)
	pColumnCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_imagestack_getcolumncount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pColumnCount)
	_checkError(self.wrapper, self, err)
	return pColumnCount[]
end

function SetColumnCount(self::ImageStack, ColumnCount::UInt32)
	err = ccall(self.wrapper.funcs[:lib3mf_imagestack_setcolumncount], Int32, (Ptr{Cvoid}, UInt32), self.handle, ColumnCount)
	_checkError(self.wrapper, self, err)
end

function GetSheetCount(self::ImageStack)
	pSheetCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_imagestack_getsheetcount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pSheetCount)
	_checkError(self.wrapper, self, err)
	return pSheetCount[]
end

function GetSheet(self::ImageStack, Index::UInt32)
	pSheet = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_imagestack_getsheet], Int32, (Ptr{Cvoid}, UInt32, Ref{Ptr{Cvoid}}), self.handle, Index, pSheet)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pSheet[])
end

function SetSheet(self::ImageStack, Index::UInt32, Sheet::Attachment)
	err = ccall(self.wrapper.funcs[:lib3mf_imagestack_setsheet], Int32, (Ptr{Cvoid}, UInt32, Ptr{Cvoid}), self.handle, Index, Sheet.handle)
	_checkError(self.wrapper, self, err)
end

function CreateEmptySheet(self::ImageStack, Index::UInt32, Path::AbstractString)
	pSheet = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Path begin
		err = ccall(self.wrapper.funcs[:lib3mf_imagestack_createemptysheet], Int32, (Ptr{Cvoid}, UInt32, Cstring, Ref{Ptr{Cvoid}}), self.handle, Index, Path, pSheet)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pSheet[])
end

function CreateSheetFromBuffer(self::ImageStack, Index::UInt32, Path::AbstractString, Data::Array{UInt8, 1})
	nDataCount = UInt64(length(Data))
	pDataBuffer = length(Data) == 0 ? Ptr{UInt8}(C_NULL) : pointer(Data)
	pSheet = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Path Data begin
		err = ccall(self.wrapper.funcs[:lib3mf_imagestack_createsheetfrombuffer], Int32, (Ptr{Cvoid}, UInt32, Cstring, UInt64, Ptr{UInt8}, Ref{Ptr{Cvoid}}), self.handle, Index, Path, nDataCount, pDataBuffer, pSheet)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pSheet[])
end

function CreateSheetFromFile(self::ImageStack, Index::UInt32, Path::AbstractString, FileName::AbstractString)
	pSheet = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Path FileName begin
		err = ccall(self.wrapper.funcs[:lib3mf_imagestack_createsheetfromfile], Int32, (Ptr{Cvoid}, UInt32, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Index, Path, FileName, pSheet)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pSheet[])
end

function GetName(self::ImageStack)
	return GetName(Image3D(self.handle, self.wrapper))
end

function SetName(self::ImageStack, Name::AbstractString)
	return SetName(Image3D(self.handle, self.wrapper), Name)
end

function IsImageStack(self::ImageStack)
	return IsImageStack(Image3D(self.handle, self.wrapper))
end

function GetResourceID(self::ImageStack)
	return GetResourceID(Resource(self.handle, self.wrapper))
end

function GetUniqueResourceID(self::ImageStack)
	return GetUniqueResourceID(Resource(self.handle, self.wrapper))
end

function PackagePart(self::ImageStack)
	return PackagePart(Resource(self.handle, self.wrapper))
end

function SetPackagePart(self::ImageStack, PackagePart::PackagePart)
	return SetPackagePart(Resource(self.handle, self.wrapper), PackagePart)
end

function GetModelResourceID(self::ImageStack)
	return GetModelResourceID(Resource(self.handle, self.wrapper))
end

function ClassTypeId(self::ImageStack)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetPath(self::Attachment)
	nPathBufferSize = UInt64(0)
	nPathNeeded = Ref{UInt64}(0)
	pPathBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_attachment_getpath], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nPathBufferSize, nPathNeeded, pPathBuffer)
	_checkError(self.wrapper, self, err)
	pPathBuffer = Array{UInt8}(undef, Int(nPathNeeded[]))
	nPathBufferSize = UInt64(length(pPathBuffer))
	pPathBuffer_ptr = pointer(pPathBuffer)
	GC.@preserve pPathBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_attachment_getpath], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nPathBufferSize, nPathNeeded, pPathBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pPathBuffer_ptr)
end

function SetPath(self::Attachment, Path::AbstractString)
	GC.@preserve Path begin
		err = ccall(self.wrapper.funcs[:lib3mf_attachment_setpath], Int32, (Ptr{Cvoid}, Cstring), self.handle, Path)
	end
	_checkError(self.wrapper, self, err)
end

function PackagePart(self::Attachment)
	pPackagePart = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_attachment_packagepart], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pPackagePart)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pPackagePart[])
end

function GetRelationShipType(self::Attachment)
	nPathBufferSize = UInt64(0)
	nPathNeeded = Ref{UInt64}(0)
	pPathBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_attachment_getrelationshiptype], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nPathBufferSize, nPathNeeded, pPathBuffer)
	_checkError(self.wrapper, self, err)
	pPathBuffer = Array{UInt8}(undef, Int(nPathNeeded[]))
	nPathBufferSize = UInt64(length(pPathBuffer))
	pPathBuffer_ptr = pointer(pPathBuffer)
	GC.@preserve pPathBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_attachment_getrelationshiptype], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nPathBufferSize, nPathNeeded, pPathBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pPathBuffer_ptr)
end

function SetRelationShipType(self::Attachment, Path::AbstractString)
	GC.@preserve Path begin
		err = ccall(self.wrapper.funcs[:lib3mf_attachment_setrelationshiptype], Int32, (Ptr{Cvoid}, Cstring), self.handle, Path)
	end
	_checkError(self.wrapper, self, err)
end

function WriteToFile(self::Attachment, FileName::AbstractString)
	GC.@preserve FileName begin
		err = ccall(self.wrapper.funcs[:lib3mf_attachment_writetofile], Int32, (Ptr{Cvoid}, Cstring), self.handle, FileName)
	end
	_checkError(self.wrapper, self, err)
end

function ReadFromFile(self::Attachment, FileName::AbstractString)
	GC.@preserve FileName begin
		err = ccall(self.wrapper.funcs[:lib3mf_attachment_readfromfile], Int32, (Ptr{Cvoid}, Cstring), self.handle, FileName)
	end
	_checkError(self.wrapper, self, err)
end


function GetStreamSize(self::Attachment)
	pStreamSize = Ref{UInt64}()
	err = ccall(self.wrapper.funcs[:lib3mf_attachment_getstreamsize], Int32, (Ptr{Cvoid}, Ref{UInt64}), self.handle, pStreamSize)
	_checkError(self.wrapper, self, err)
	return pStreamSize[]
end

function WriteToBuffer(self::Attachment)
	nBufferCount = UInt64(0)
	nBufferNeeded = Ref{UInt64}(0)
	pBufferBuffer = Ptr{UInt8}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_attachment_writetobuffer], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt8}), self.handle, nBufferCount, nBufferNeeded, pBufferBuffer)
	_checkError(self.wrapper, self, err)
	pBufferBuffer = Array{UInt8}(undef, Int(nBufferNeeded[]))
	nBufferCount = UInt64(length(pBufferBuffer))
	pBufferBuffer_ptr = pointer(pBufferBuffer)
	GC.@preserve pBufferBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_attachment_writetobuffer], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt8}), self.handle, nBufferCount, nBufferNeeded, pBufferBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pBufferBuffer
end

function ReadFromBuffer(self::Attachment, Buffer::Array{UInt8, 1})
	nBufferCount = UInt64(length(Buffer))
	pBufferBuffer = length(Buffer) == 0 ? Ptr{UInt8}(C_NULL) : pointer(Buffer)
	GC.@preserve Buffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_attachment_readfrombuffer], Int32, (Ptr{Cvoid}, UInt64, Ptr{UInt8}), self.handle, nBufferCount, pBufferBuffer)
	end
	_checkError(self.wrapper, self, err)
end

function ClassTypeId(self::Attachment)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetAttachment(self::Texture2D)
	pAttachment = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_texture2d_getattachment], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pAttachment)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pAttachment[])
end

function SetAttachment(self::Texture2D, Attachment::Attachment)
	err = ccall(self.wrapper.funcs[:lib3mf_texture2d_setattachment], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, Attachment.handle)
	_checkError(self.wrapper, self, err)
end

function GetContentType(self::Texture2D)
	pContentType = Ref{Int32}(0)
	err = ccall(self.wrapper.funcs[:lib3mf_texture2d_getcontenttype], Int32, (Ptr{Cvoid}, Ref{Int32}), self.handle, pContentType)
	_checkError(self.wrapper, self, err)
	return eTextureType(pContentType[])
end

function SetContentType(self::Texture2D, ContentType::eTextureType)
	err = ccall(self.wrapper.funcs[:lib3mf_texture2d_setcontenttype], Int32, (Ptr{Cvoid}, eTextureType), self.handle, ContentType)
	_checkError(self.wrapper, self, err)
end

function GetTileStyleUV(self::Texture2D)
	pTileStyleU = Ref{Int32}(0)
	pTileStyleV = Ref{Int32}(0)
	err = ccall(self.wrapper.funcs[:lib3mf_texture2d_gettilestyleuv], Int32, (Ptr{Cvoid}, Ref{Int32}, Ref{Int32}), self.handle, pTileStyleU, pTileStyleV)
	_checkError(self.wrapper, self, err)
	return eTextureTileStyle(pTileStyleU[]), eTextureTileStyle(pTileStyleV[])
end

function SetTileStyleUV(self::Texture2D, TileStyleU::eTextureTileStyle, TileStyleV::eTextureTileStyle)
	err = ccall(self.wrapper.funcs[:lib3mf_texture2d_settilestyleuv], Int32, (Ptr{Cvoid}, eTextureTileStyle, eTextureTileStyle), self.handle, TileStyleU, TileStyleV)
	_checkError(self.wrapper, self, err)
end

function GetFilter(self::Texture2D)
	pFilter = Ref{Int32}(0)
	err = ccall(self.wrapper.funcs[:lib3mf_texture2d_getfilter], Int32, (Ptr{Cvoid}, Ref{Int32}), self.handle, pFilter)
	_checkError(self.wrapper, self, err)
	return eTextureFilter(pFilter[])
end

function SetFilter(self::Texture2D, Filter::eTextureFilter)
	err = ccall(self.wrapper.funcs[:lib3mf_texture2d_setfilter], Int32, (Ptr{Cvoid}, eTextureFilter), self.handle, Filter)
	_checkError(self.wrapper, self, err)
end

function GetResourceID(self::Texture2D)
	return GetResourceID(Resource(self.handle, self.wrapper))
end

function GetUniqueResourceID(self::Texture2D)
	return GetUniqueResourceID(Resource(self.handle, self.wrapper))
end

function PackagePart(self::Texture2D)
	return PackagePart(Resource(self.handle, self.wrapper))
end

function SetPackagePart(self::Texture2D, PackagePart::PackagePart)
	return SetPackagePart(Resource(self.handle, self.wrapper), PackagePart)
end

function GetModelResourceID(self::Texture2D)
	return GetModelResourceID(Resource(self.handle, self.wrapper))
end

function ClassTypeId(self::Texture2D)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetIdentifier(self::ImplicitPort)
	nIdentifierBufferSize = UInt64(0)
	nIdentifierNeeded = Ref{UInt64}(0)
	pIdentifierBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_implicitport_getidentifier], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nIdentifierBufferSize, nIdentifierNeeded, pIdentifierBuffer)
	_checkError(self.wrapper, self, err)
	pIdentifierBuffer = Array{UInt8}(undef, Int(nIdentifierNeeded[]))
	nIdentifierBufferSize = UInt64(length(pIdentifierBuffer))
	pIdentifierBuffer_ptr = pointer(pIdentifierBuffer)
	GC.@preserve pIdentifierBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitport_getidentifier], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nIdentifierBufferSize, nIdentifierNeeded, pIdentifierBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pIdentifierBuffer_ptr)
end

function SetIdentifier(self::ImplicitPort, Identifier::AbstractString)
	GC.@preserve Identifier begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitport_setidentifier], Int32, (Ptr{Cvoid}, Cstring), self.handle, Identifier)
	end
	_checkError(self.wrapper, self, err)
end

function GetDisplayName(self::ImplicitPort)
	nDisplayNameBufferSize = UInt64(0)
	nDisplayNameNeeded = Ref{UInt64}(0)
	pDisplayNameBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_implicitport_getdisplayname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nDisplayNameBufferSize, nDisplayNameNeeded, pDisplayNameBuffer)
	_checkError(self.wrapper, self, err)
	pDisplayNameBuffer = Array{UInt8}(undef, Int(nDisplayNameNeeded[]))
	nDisplayNameBufferSize = UInt64(length(pDisplayNameBuffer))
	pDisplayNameBuffer_ptr = pointer(pDisplayNameBuffer)
	GC.@preserve pDisplayNameBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitport_getdisplayname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nDisplayNameBufferSize, nDisplayNameNeeded, pDisplayNameBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pDisplayNameBuffer_ptr)
end

function SetDisplayName(self::ImplicitPort, DisplayName::AbstractString)
	GC.@preserve DisplayName begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitport_setdisplayname], Int32, (Ptr{Cvoid}, Cstring), self.handle, DisplayName)
	end
	_checkError(self.wrapper, self, err)
end

function SetType(self::ImplicitPort, ImplicitPortType::eImplicitPortType)
	err = ccall(self.wrapper.funcs[:lib3mf_implicitport_settype], Int32, (Ptr{Cvoid}, eImplicitPortType), self.handle, ImplicitPortType)
	_checkError(self.wrapper, self, err)
end

function GetType(self::ImplicitPort)
	pImplicitPortType = Ref{Int32}(0)
	err = ccall(self.wrapper.funcs[:lib3mf_implicitport_gettype], Int32, (Ptr{Cvoid}, Ref{Int32}), self.handle, pImplicitPortType)
	_checkError(self.wrapper, self, err)
	return eImplicitPortType(pImplicitPortType[])
end

function GetReference(self::ImplicitPort)
	nReferenceBufferSize = UInt64(0)
	nReferenceNeeded = Ref{UInt64}(0)
	pReferenceBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_implicitport_getreference], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nReferenceBufferSize, nReferenceNeeded, pReferenceBuffer)
	_checkError(self.wrapper, self, err)
	pReferenceBuffer = Array{UInt8}(undef, Int(nReferenceNeeded[]))
	nReferenceBufferSize = UInt64(length(pReferenceBuffer))
	pReferenceBuffer_ptr = pointer(pReferenceBuffer)
	GC.@preserve pReferenceBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitport_getreference], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nReferenceBufferSize, nReferenceNeeded, pReferenceBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pReferenceBuffer_ptr)
end

function SetReference(self::ImplicitPort, Reference::AbstractString)
	GC.@preserve Reference begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitport_setreference], Int32, (Ptr{Cvoid}, Cstring), self.handle, Reference)
	end
	_checkError(self.wrapper, self, err)
end

function ClassTypeId(self::ImplicitPort)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function MoveNext(self::Iterator)
	pHasNext = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_iterator_movenext], Int32, (Ptr{Cvoid}, Ref{Cbool}), self.handle, pHasNext)
	_checkError(self.wrapper, self, err)
	return pHasNext[] != 0
end

function MovePrevious(self::Iterator)
	pHasPrevious = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_iterator_moveprevious], Int32, (Ptr{Cvoid}, Ref{Cbool}), self.handle, pHasPrevious)
	_checkError(self.wrapper, self, err)
	return pHasPrevious[] != 0
end

function Count(self::Iterator)
	pCount = Ref{UInt64}()
	err = ccall(self.wrapper.funcs[:lib3mf_iterator_count], Int32, (Ptr{Cvoid}, Ref{UInt64}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function ClassTypeId(self::Iterator)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetCurrent(self::ImplicitPortIterator)
	pPort = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_implicitportiterator_getcurrent], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pPort)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pPort[])
end

function MoveNext(self::ImplicitPortIterator)
	return MoveNext(Iterator(self.handle, self.wrapper))
end

function MovePrevious(self::ImplicitPortIterator)
	return MovePrevious(Iterator(self.handle, self.wrapper))
end

function Count(self::ImplicitPortIterator)
	return Count(Iterator(self.handle, self.wrapper))
end

function ClassTypeId(self::ImplicitPortIterator)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetIdentifier(self::ImplicitNode)
	nIdentifierBufferSize = UInt64(0)
	nIdentifierNeeded = Ref{UInt64}(0)
	pIdentifierBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_implicitnode_getidentifier], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nIdentifierBufferSize, nIdentifierNeeded, pIdentifierBuffer)
	_checkError(self.wrapper, self, err)
	pIdentifierBuffer = Array{UInt8}(undef, Int(nIdentifierNeeded[]))
	nIdentifierBufferSize = UInt64(length(pIdentifierBuffer))
	pIdentifierBuffer_ptr = pointer(pIdentifierBuffer)
	GC.@preserve pIdentifierBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitnode_getidentifier], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nIdentifierBufferSize, nIdentifierNeeded, pIdentifierBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pIdentifierBuffer_ptr)
end

function SetIdentifier(self::ImplicitNode, Identifier::AbstractString)
	GC.@preserve Identifier begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitnode_setidentifier], Int32, (Ptr{Cvoid}, Cstring), self.handle, Identifier)
	end
	_checkError(self.wrapper, self, err)
end

function GetDisplayName(self::ImplicitNode)
	nDisplayNameBufferSize = UInt64(0)
	nDisplayNameNeeded = Ref{UInt64}(0)
	pDisplayNameBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_implicitnode_getdisplayname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nDisplayNameBufferSize, nDisplayNameNeeded, pDisplayNameBuffer)
	_checkError(self.wrapper, self, err)
	pDisplayNameBuffer = Array{UInt8}(undef, Int(nDisplayNameNeeded[]))
	nDisplayNameBufferSize = UInt64(length(pDisplayNameBuffer))
	pDisplayNameBuffer_ptr = pointer(pDisplayNameBuffer)
	GC.@preserve pDisplayNameBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitnode_getdisplayname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nDisplayNameBufferSize, nDisplayNameNeeded, pDisplayNameBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pDisplayNameBuffer_ptr)
end

function SetDisplayName(self::ImplicitNode, DisplayName::AbstractString)
	GC.@preserve DisplayName begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitnode_setdisplayname], Int32, (Ptr{Cvoid}, Cstring), self.handle, DisplayName)
	end
	_checkError(self.wrapper, self, err)
end

function GetTag(self::ImplicitNode)
	nTagBufferSize = UInt64(0)
	nTagNeeded = Ref{UInt64}(0)
	pTagBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_implicitnode_gettag], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nTagBufferSize, nTagNeeded, pTagBuffer)
	_checkError(self.wrapper, self, err)
	pTagBuffer = Array{UInt8}(undef, Int(nTagNeeded[]))
	nTagBufferSize = UInt64(length(pTagBuffer))
	pTagBuffer_ptr = pointer(pTagBuffer)
	GC.@preserve pTagBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitnode_gettag], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nTagBufferSize, nTagNeeded, pTagBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pTagBuffer_ptr)
end

function SetTag(self::ImplicitNode, Tag::AbstractString)
	GC.@preserve Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitnode_settag], Int32, (Ptr{Cvoid}, Cstring), self.handle, Tag)
	end
	_checkError(self.wrapper, self, err)
end

function GetNodeType(self::ImplicitNode)
	pType = Ref{Int32}(0)
	err = ccall(self.wrapper.funcs[:lib3mf_implicitnode_getnodetype], Int32, (Ptr{Cvoid}, Ref{Int32}), self.handle, pType)
	_checkError(self.wrapper, self, err)
	return eImplicitNodeType(pType[])
end

function AddInput(self::ImplicitNode, Identifier::AbstractString, DisplayName::AbstractString)
	pPort = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitnode_addinput], Int32, (Ptr{Cvoid}, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, pPort)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pPort[])
end

function GetInputs(self::ImplicitNode)
	pIterator = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_implicitnode_getinputs], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pIterator)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pIterator[])
end

function AddOutput(self::ImplicitNode, Identifier::AbstractString, DisplayName::AbstractString)
	pPort = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitnode_addoutput], Int32, (Ptr{Cvoid}, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, pPort)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pPort[])
end

function GetOutputs(self::ImplicitNode)
	pIterator = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_implicitnode_getoutputs], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pIterator)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pIterator[])
end

function FindInput(self::ImplicitNode, Identifier::AbstractString)
	pInput = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitnode_findinput], Int32, (Ptr{Cvoid}, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, pInput)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pInput[])
end

function FindOutput(self::ImplicitNode, Identifier::AbstractString)
	pOutput = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitnode_findoutput], Int32, (Ptr{Cvoid}, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, pOutput)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pOutput[])
end

function AreTypesValid(self::ImplicitNode)
	pValid = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_implicitnode_aretypesvalid], Int32, (Ptr{Cvoid}, Ref{Cbool}), self.handle, pValid)
	_checkError(self.wrapper, self, err)
	return pValid[] != 0
end

function ClassTypeId(self::ImplicitNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::OneInputNode)
	pInput = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_oneinputnode_getinputa], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pInput)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pInput[])
end

function GetOutputResult(self::OneInputNode)
	pResult = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_oneinputnode_getoutputresult], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResult)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResult[])
end

function GetIdentifier(self::OneInputNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::OneInputNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::OneInputNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::OneInputNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::OneInputNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::OneInputNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::OneInputNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::OneInputNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::OneInputNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::OneInputNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::OneInputNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::OneInputNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::OneInputNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::OneInputNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::OneInputNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::SinNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::SinNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::SinNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::SinNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::SinNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::SinNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::SinNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::SinNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::SinNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::SinNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::SinNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::SinNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::SinNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::SinNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::SinNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::SinNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::SinNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::CosNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::CosNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::CosNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::CosNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::CosNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::CosNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::CosNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::CosNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::CosNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::CosNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::CosNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::CosNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::CosNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::CosNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::CosNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::CosNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::CosNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::TanNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::TanNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::TanNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::TanNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::TanNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::TanNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::TanNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::TanNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::TanNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::TanNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::TanNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::TanNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::TanNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::TanNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::TanNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::TanNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::TanNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::ArcSinNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::ArcSinNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::ArcSinNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::ArcSinNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::ArcSinNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::ArcSinNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::ArcSinNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::ArcSinNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::ArcSinNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::ArcSinNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::ArcSinNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::ArcSinNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::ArcSinNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::ArcSinNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::ArcSinNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::ArcSinNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::ArcSinNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::ArcCosNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::ArcCosNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::ArcCosNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::ArcCosNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::ArcCosNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::ArcCosNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::ArcCosNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::ArcCosNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::ArcCosNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::ArcCosNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::ArcCosNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::ArcCosNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::ArcCosNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::ArcCosNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::ArcCosNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::ArcCosNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::ArcCosNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::ArcTanNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::ArcTanNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::ArcTanNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::ArcTanNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::ArcTanNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::ArcTanNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::ArcTanNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::ArcTanNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::ArcTanNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::ArcTanNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::ArcTanNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::ArcTanNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::ArcTanNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::ArcTanNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::ArcTanNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::ArcTanNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::ArcTanNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::SinhNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::SinhNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::SinhNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::SinhNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::SinhNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::SinhNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::SinhNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::SinhNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::SinhNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::SinhNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::SinhNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::SinhNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::SinhNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::SinhNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::SinhNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::SinhNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::SinhNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::CoshNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::CoshNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::CoshNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::CoshNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::CoshNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::CoshNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::CoshNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::CoshNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::CoshNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::CoshNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::CoshNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::CoshNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::CoshNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::CoshNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::CoshNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::CoshNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::CoshNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::TanhNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::TanhNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::TanhNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::TanhNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::TanhNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::TanhNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::TanhNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::TanhNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::TanhNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::TanhNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::TanhNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::TanhNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::TanhNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::TanhNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::TanhNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::TanhNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::TanhNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::RoundNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::RoundNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::RoundNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::RoundNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::RoundNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::RoundNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::RoundNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::RoundNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::RoundNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::RoundNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::RoundNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::RoundNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::RoundNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::RoundNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::RoundNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::RoundNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::RoundNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::CeilNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::CeilNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::CeilNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::CeilNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::CeilNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::CeilNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::CeilNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::CeilNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::CeilNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::CeilNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::CeilNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::CeilNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::CeilNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::CeilNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::CeilNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::CeilNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::CeilNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::FloorNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::FloorNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::FloorNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::FloorNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::FloorNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::FloorNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::FloorNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::FloorNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::FloorNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::FloorNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::FloorNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::FloorNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::FloorNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::FloorNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::FloorNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::FloorNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::FloorNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::SignNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::SignNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::SignNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::SignNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::SignNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::SignNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::SignNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::SignNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::SignNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::SignNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::SignNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::SignNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::SignNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::SignNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::SignNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::SignNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::SignNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::FractNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::FractNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::FractNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::FractNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::FractNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::FractNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::FractNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::FractNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::FractNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::FractNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::FractNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::FractNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::FractNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::FractNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::FractNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::FractNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::FractNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::AbsNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::AbsNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::AbsNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::AbsNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::AbsNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::AbsNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::AbsNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::AbsNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::AbsNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::AbsNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::AbsNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::AbsNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::AbsNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::AbsNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::AbsNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::AbsNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::AbsNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::ExpNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::ExpNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::ExpNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::ExpNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::ExpNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::ExpNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::ExpNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::ExpNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::ExpNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::ExpNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::ExpNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::ExpNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::ExpNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::ExpNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::ExpNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::ExpNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::ExpNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::LogNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::LogNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::LogNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::LogNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::LogNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::LogNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::LogNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::LogNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::LogNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::LogNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::LogNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::LogNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::LogNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::LogNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::LogNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::LogNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::LogNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::Log2Node)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::Log2Node)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::Log2Node)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::Log2Node, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::Log2Node)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::Log2Node, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::Log2Node)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::Log2Node, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::Log2Node)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::Log2Node, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::Log2Node)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::Log2Node, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::Log2Node)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::Log2Node, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::Log2Node, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::Log2Node)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::Log2Node)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::Log10Node)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::Log10Node)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::Log10Node)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::Log10Node, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::Log10Node)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::Log10Node, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::Log10Node)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::Log10Node, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::Log10Node)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::Log10Node, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::Log10Node)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::Log10Node, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::Log10Node)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::Log10Node, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::Log10Node, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::Log10Node)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::Log10Node)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::LengthNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::LengthNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::LengthNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::LengthNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::LengthNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::LengthNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::LengthNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::LengthNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::LengthNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::LengthNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::LengthNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::LengthNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::LengthNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::LengthNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::LengthNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::LengthNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::LengthNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::TransposeNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::TransposeNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::TransposeNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::TransposeNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::TransposeNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::TransposeNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::TransposeNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::TransposeNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::TransposeNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::TransposeNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::TransposeNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::TransposeNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::TransposeNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::TransposeNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::TransposeNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::TransposeNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::TransposeNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::InverseNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::InverseNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::InverseNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::InverseNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::InverseNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::InverseNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::InverseNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::InverseNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::InverseNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::InverseNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::InverseNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::InverseNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::InverseNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::InverseNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::InverseNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::InverseNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::InverseNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::SqrtNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::SqrtNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::SqrtNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::SqrtNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::SqrtNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::SqrtNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::SqrtNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::SqrtNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::SqrtNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::SqrtNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::SqrtNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::SqrtNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::SqrtNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::SqrtNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::SqrtNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::SqrtNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::SqrtNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function SetResource(self::ResourceIdNode, Resource::Resource)
	err = ccall(self.wrapper.funcs[:lib3mf_resourceidnode_setresource], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, Resource.handle)
	_checkError(self.wrapper, self, err)
end

function GetResource(self::ResourceIdNode)
	pResource = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_resourceidnode_getresource], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResource)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResource[])
end

function GetOutputValue(self::ResourceIdNode)
	pValue = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_resourceidnode_getoutputvalue], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pValue)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pValue[])
end

function GetIdentifier(self::ResourceIdNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::ResourceIdNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::ResourceIdNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::ResourceIdNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::ResourceIdNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::ResourceIdNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::ResourceIdNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::ResourceIdNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::ResourceIdNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::ResourceIdNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::ResourceIdNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::ResourceIdNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::ResourceIdNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::ResourceIdNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::ResourceIdNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputB(self::TwoInputNode)
	pB = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_twoinputnode_getinputb], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pB)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pB[])
end

function GetInputA(self::TwoInputNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::TwoInputNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::TwoInputNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::TwoInputNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::TwoInputNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::TwoInputNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::TwoInputNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::TwoInputNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::TwoInputNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::TwoInputNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::TwoInputNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::TwoInputNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::TwoInputNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::TwoInputNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::TwoInputNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::TwoInputNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::TwoInputNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputB(self::AdditionNode)
	return GetInputB(TwoInputNode(self.handle, self.wrapper))
end

function GetInputA(self::AdditionNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::AdditionNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::AdditionNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::AdditionNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::AdditionNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::AdditionNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::AdditionNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::AdditionNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::AdditionNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::AdditionNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::AdditionNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::AdditionNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::AdditionNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::AdditionNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::AdditionNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::AdditionNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::AdditionNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputB(self::SubtractionNode)
	return GetInputB(TwoInputNode(self.handle, self.wrapper))
end

function GetInputA(self::SubtractionNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::SubtractionNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::SubtractionNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::SubtractionNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::SubtractionNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::SubtractionNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::SubtractionNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::SubtractionNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::SubtractionNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::SubtractionNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::SubtractionNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::SubtractionNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::SubtractionNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::SubtractionNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::SubtractionNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::SubtractionNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::SubtractionNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputB(self::MultiplicationNode)
	return GetInputB(TwoInputNode(self.handle, self.wrapper))
end

function GetInputA(self::MultiplicationNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::MultiplicationNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::MultiplicationNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::MultiplicationNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::MultiplicationNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::MultiplicationNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::MultiplicationNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::MultiplicationNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::MultiplicationNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::MultiplicationNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::MultiplicationNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::MultiplicationNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::MultiplicationNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::MultiplicationNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::MultiplicationNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::MultiplicationNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::MultiplicationNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputB(self::DivisionNode)
	return GetInputB(TwoInputNode(self.handle, self.wrapper))
end

function GetInputA(self::DivisionNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::DivisionNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::DivisionNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::DivisionNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::DivisionNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::DivisionNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::DivisionNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::DivisionNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::DivisionNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::DivisionNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::DivisionNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::DivisionNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::DivisionNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::DivisionNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::DivisionNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::DivisionNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::DivisionNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputB(self::DotNode)
	return GetInputB(TwoInputNode(self.handle, self.wrapper))
end

function GetInputA(self::DotNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::DotNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::DotNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::DotNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::DotNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::DotNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::DotNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::DotNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::DotNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::DotNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::DotNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::DotNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::DotNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::DotNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::DotNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::DotNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::DotNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputB(self::CrossNode)
	return GetInputB(TwoInputNode(self.handle, self.wrapper))
end

function GetInputA(self::CrossNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::CrossNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::CrossNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::CrossNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::CrossNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::CrossNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::CrossNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::CrossNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::CrossNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::CrossNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::CrossNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::CrossNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::CrossNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::CrossNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::CrossNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::CrossNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::CrossNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputB(self::ArcTan2Node)
	return GetInputB(TwoInputNode(self.handle, self.wrapper))
end

function GetInputA(self::ArcTan2Node)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::ArcTan2Node)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::ArcTan2Node)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::ArcTan2Node, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::ArcTan2Node)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::ArcTan2Node, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::ArcTan2Node)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::ArcTan2Node, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::ArcTan2Node)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::ArcTan2Node, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::ArcTan2Node)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::ArcTan2Node, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::ArcTan2Node)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::ArcTan2Node, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::ArcTan2Node, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::ArcTan2Node)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::ArcTan2Node)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputB(self::MatVecMultiplicationNode)
	return GetInputB(TwoInputNode(self.handle, self.wrapper))
end

function GetInputA(self::MatVecMultiplicationNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::MatVecMultiplicationNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::MatVecMultiplicationNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::MatVecMultiplicationNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::MatVecMultiplicationNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::MatVecMultiplicationNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::MatVecMultiplicationNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::MatVecMultiplicationNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::MatVecMultiplicationNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::MatVecMultiplicationNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::MatVecMultiplicationNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::MatVecMultiplicationNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::MatVecMultiplicationNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::MatVecMultiplicationNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::MatVecMultiplicationNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::MatVecMultiplicationNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::MatVecMultiplicationNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputB(self::MinNode)
	return GetInputB(TwoInputNode(self.handle, self.wrapper))
end

function GetInputA(self::MinNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::MinNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::MinNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::MinNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::MinNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::MinNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::MinNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::MinNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::MinNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::MinNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::MinNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::MinNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::MinNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::MinNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::MinNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::MinNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::MinNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputB(self::MaxNode)
	return GetInputB(TwoInputNode(self.handle, self.wrapper))
end

function GetInputA(self::MaxNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::MaxNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::MaxNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::MaxNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::MaxNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::MaxNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::MaxNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::MaxNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::MaxNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::MaxNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::MaxNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::MaxNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::MaxNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::MaxNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::MaxNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::MaxNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::MaxNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputB(self::FmodNode)
	return GetInputB(TwoInputNode(self.handle, self.wrapper))
end

function GetInputA(self::FmodNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::FmodNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::FmodNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::FmodNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::FmodNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::FmodNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::FmodNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::FmodNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::FmodNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::FmodNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::FmodNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::FmodNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::FmodNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::FmodNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::FmodNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::FmodNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::FmodNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputB(self::ModNode)
	return GetInputB(TwoInputNode(self.handle, self.wrapper))
end

function GetInputA(self::ModNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::ModNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::ModNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::ModNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::ModNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::ModNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::ModNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::ModNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::ModNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::ModNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::ModNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::ModNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::ModNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::ModNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::ModNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::ModNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::ModNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputB(self::PowNode)
	return GetInputB(TwoInputNode(self.handle, self.wrapper))
end

function GetInputA(self::PowNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::PowNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::PowNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::PowNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::PowNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::PowNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::PowNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::PowNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::PowNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::PowNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::PowNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::PowNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::PowNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::PowNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::PowNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::PowNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::PowNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputB(self::SelectNode)
	pB = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_selectnode_getinputb], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pB)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pB[])
end

function GetInputC(self::SelectNode)
	pC = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_selectnode_getinputc], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pC)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pC[])
end

function GetInputD(self::SelectNode)
	pD = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_selectnode_getinputd], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pD)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pD[])
end

function GetInputA(self::SelectNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::SelectNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::SelectNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::SelectNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::SelectNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::SelectNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::SelectNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::SelectNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::SelectNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::SelectNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::SelectNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::SelectNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::SelectNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::SelectNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::SelectNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::SelectNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::SelectNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputMin(self::ClampNode)
	pMin = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_clampnode_getinputmin], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pMin)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pMin[])
end

function GetInputMax(self::ClampNode)
	pMax = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_clampnode_getinputmax], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pMax)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pMax[])
end

function GetInputA(self::ClampNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::ClampNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::ClampNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::ClampNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::ClampNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::ClampNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::ClampNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::ClampNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::ClampNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::ClampNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::ClampNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::ClampNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::ClampNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::ClampNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::ClampNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::ClampNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::ClampNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputX(self::ComposeVectorNode)
	pX = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_composevectornode_getinputx], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pX)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pX[])
end

function GetInputY(self::ComposeVectorNode)
	pY = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_composevectornode_getinputy], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pY)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pY[])
end

function GetInputZ(self::ComposeVectorNode)
	pZ = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_composevectornode_getinputz], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pZ)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pZ[])
end

function GetOutputResult(self::ComposeVectorNode)
	pResult = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_composevectornode_getoutputresult], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResult)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResult[])
end

function GetIdentifier(self::ComposeVectorNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::ComposeVectorNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::ComposeVectorNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::ComposeVectorNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::ComposeVectorNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::ComposeVectorNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::ComposeVectorNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::ComposeVectorNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::ComposeVectorNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::ComposeVectorNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::ComposeVectorNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::ComposeVectorNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::ComposeVectorNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::ComposeVectorNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::ComposeVectorNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::VectorFromScalarNode)
	return GetInputA(OneInputNode(self.handle, self.wrapper))
end

function GetOutputResult(self::VectorFromScalarNode)
	return GetOutputResult(OneInputNode(self.handle, self.wrapper))
end

function GetIdentifier(self::VectorFromScalarNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::VectorFromScalarNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::VectorFromScalarNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::VectorFromScalarNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::VectorFromScalarNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::VectorFromScalarNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::VectorFromScalarNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::VectorFromScalarNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::VectorFromScalarNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::VectorFromScalarNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::VectorFromScalarNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::VectorFromScalarNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::VectorFromScalarNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::VectorFromScalarNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::VectorFromScalarNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::DecomposeVectorNode)
	pA = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_decomposevectornode_getinputa], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pA)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pA[])
end

function GetOutputX(self::DecomposeVectorNode)
	pX = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_decomposevectornode_getoutputx], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pX)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pX[])
end

function GetOutputY(self::DecomposeVectorNode)
	pY = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_decomposevectornode_getoutputy], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pY)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pY[])
end

function GetOutputZ(self::DecomposeVectorNode)
	pZ = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_decomposevectornode_getoutputz], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pZ)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pZ[])
end

function GetIdentifier(self::DecomposeVectorNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::DecomposeVectorNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::DecomposeVectorNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::DecomposeVectorNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::DecomposeVectorNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::DecomposeVectorNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::DecomposeVectorNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::DecomposeVectorNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::DecomposeVectorNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::DecomposeVectorNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::DecomposeVectorNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::DecomposeVectorNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::DecomposeVectorNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::DecomposeVectorNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::DecomposeVectorNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputM00(self::ComposeMatrixNode)
	pM00 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_composematrixnode_getinputm00], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pM00)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pM00[])
end

function GetInputM01(self::ComposeMatrixNode)
	pM01 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_composematrixnode_getinputm01], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pM01)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pM01[])
end

function GetInputM02(self::ComposeMatrixNode)
	pM02 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_composematrixnode_getinputm02], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pM02)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pM02[])
end

function GetInputM03(self::ComposeMatrixNode)
	pM03 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_composematrixnode_getinputm03], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pM03)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pM03[])
end

function GetInputM10(self::ComposeMatrixNode)
	pM10 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_composematrixnode_getinputm10], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pM10)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pM10[])
end

function GetInputM11(self::ComposeMatrixNode)
	pM11 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_composematrixnode_getinputm11], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pM11)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pM11[])
end

function GetInputM12(self::ComposeMatrixNode)
	pM12 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_composematrixnode_getinputm12], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pM12)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pM12[])
end

function GetInputM13(self::ComposeMatrixNode)
	pM13 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_composematrixnode_getinputm13], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pM13)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pM13[])
end

function GetInputM20(self::ComposeMatrixNode)
	pM20 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_composematrixnode_getinputm20], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pM20)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pM20[])
end

function GetInputM21(self::ComposeMatrixNode)
	pM21 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_composematrixnode_getinputm21], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pM21)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pM21[])
end

function GetInputM22(self::ComposeMatrixNode)
	pM22 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_composematrixnode_getinputm22], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pM22)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pM22[])
end

function GetInputM23(self::ComposeMatrixNode)
	pM23 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_composematrixnode_getinputm23], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pM23)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pM23[])
end

function GetInputM30(self::ComposeMatrixNode)
	pM30 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_composematrixnode_getinputm30], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pM30)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pM30[])
end

function GetInputM31(self::ComposeMatrixNode)
	pM31 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_composematrixnode_getinputm31], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pM31)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pM31[])
end

function GetInputM32(self::ComposeMatrixNode)
	pM32 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_composematrixnode_getinputm32], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pM32)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pM32[])
end

function GetInputM33(self::ComposeMatrixNode)
	pM33 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_composematrixnode_getinputm33], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pM33)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pM33[])
end

function GetOutputResult(self::ComposeMatrixNode)
	pResult = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_composematrixnode_getoutputresult], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResult)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResult[])
end

function GetIdentifier(self::ComposeMatrixNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::ComposeMatrixNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::ComposeMatrixNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::ComposeMatrixNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::ComposeMatrixNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::ComposeMatrixNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::ComposeMatrixNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::ComposeMatrixNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::ComposeMatrixNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::ComposeMatrixNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::ComposeMatrixNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::ComposeMatrixNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::ComposeMatrixNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::ComposeMatrixNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::ComposeMatrixNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::MatrixFromRowsNode)
	pRow0 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_matrixfromrowsnode_getinputa], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pRow0)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pRow0[])
end

function GetInputB(self::MatrixFromRowsNode)
	pRow1 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_matrixfromrowsnode_getinputb], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pRow1)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pRow1[])
end

function GetInputC(self::MatrixFromRowsNode)
	pRow2 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_matrixfromrowsnode_getinputc], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pRow2)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pRow2[])
end

function GetInputD(self::MatrixFromRowsNode)
	pRow3 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_matrixfromrowsnode_getinputd], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pRow3)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pRow3[])
end

function GetOutputResult(self::MatrixFromRowsNode)
	pResult = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_matrixfromrowsnode_getoutputresult], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResult)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResult[])
end

function GetIdentifier(self::MatrixFromRowsNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::MatrixFromRowsNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::MatrixFromRowsNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::MatrixFromRowsNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::MatrixFromRowsNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::MatrixFromRowsNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::MatrixFromRowsNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::MatrixFromRowsNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::MatrixFromRowsNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::MatrixFromRowsNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::MatrixFromRowsNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::MatrixFromRowsNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::MatrixFromRowsNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::MatrixFromRowsNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::MatrixFromRowsNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputA(self::MatrixFromColumnsNode)
	pColumn0 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_matrixfromcolumnsnode_getinputa], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pColumn0)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pColumn0[])
end

function GetInputB(self::MatrixFromColumnsNode)
	pColumn1 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_matrixfromcolumnsnode_getinputb], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pColumn1)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pColumn1[])
end

function GetInputC(self::MatrixFromColumnsNode)
	pColumn2 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_matrixfromcolumnsnode_getinputc], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pColumn2)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pColumn2[])
end

function GetInputD(self::MatrixFromColumnsNode)
	pColumn3 = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_matrixfromcolumnsnode_getinputd], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pColumn3)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pColumn3[])
end

function GetOutputResult(self::MatrixFromColumnsNode)
	pResult = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_matrixfromcolumnsnode_getoutputresult], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResult)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResult[])
end

function GetIdentifier(self::MatrixFromColumnsNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::MatrixFromColumnsNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::MatrixFromColumnsNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::MatrixFromColumnsNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::MatrixFromColumnsNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::MatrixFromColumnsNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::MatrixFromColumnsNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::MatrixFromColumnsNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::MatrixFromColumnsNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::MatrixFromColumnsNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::MatrixFromColumnsNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::MatrixFromColumnsNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::MatrixFromColumnsNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::MatrixFromColumnsNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::MatrixFromColumnsNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function SetConstant(self::ConstantNode, Value::Cdouble)
	err = ccall(self.wrapper.funcs[:lib3mf_constantnode_setconstant], Int32, (Ptr{Cvoid}, Cdouble), self.handle, Value)
	_checkError(self.wrapper, self, err)
end

function GetConstant(self::ConstantNode)
	pValue = Ref{Cdouble}()
	err = ccall(self.wrapper.funcs[:lib3mf_constantnode_getconstant], Int32, (Ptr{Cvoid}, Ref{Cdouble}), self.handle, pValue)
	_checkError(self.wrapper, self, err)
	return pValue[]
end

function GetOutputValue(self::ConstantNode)
	pValue = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_constantnode_getoutputvalue], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pValue)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pValue[])
end

function GetIdentifier(self::ConstantNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::ConstantNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::ConstantNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::ConstantNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::ConstantNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::ConstantNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::ConstantNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::ConstantNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::ConstantNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::ConstantNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::ConstantNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::ConstantNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::ConstantNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::ConstantNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::ConstantNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function SetVector(self::ConstVecNode, Value::sVector)
	pValue = Ref{sVector}(Value)
	err = ccall(self.wrapper.funcs[:lib3mf_constvecnode_setvector], Int32, (Ptr{Cvoid}, Ref{sVector}), self.handle, pValue)
	_checkError(self.wrapper, self, err)
end

function GetVector(self::ConstVecNode)
	pValue = Ref{sVector}()
	err = ccall(self.wrapper.funcs[:lib3mf_constvecnode_getvector], Int32, (Ptr{Cvoid}, Ref{sVector}), self.handle, pValue)
	_checkError(self.wrapper, self, err)
	return pValue[]
end

function GetOutputVector(self::ConstVecNode)
	pVector = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_constvecnode_getoutputvector], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pVector)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pVector[])
end

function GetIdentifier(self::ConstVecNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::ConstVecNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::ConstVecNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::ConstVecNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::ConstVecNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::ConstVecNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::ConstVecNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::ConstVecNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::ConstVecNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::ConstVecNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::ConstVecNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::ConstVecNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::ConstVecNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::ConstVecNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::ConstVecNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function SetMatrix(self::ConstMatNode, Value::sMatrix4x4)
	pValue = Ref{sMatrix4x4}(Value)
	err = ccall(self.wrapper.funcs[:lib3mf_constmatnode_setmatrix], Int32, (Ptr{Cvoid}, Ref{sMatrix4x4}), self.handle, pValue)
	_checkError(self.wrapper, self, err)
end

function GetMatrix(self::ConstMatNode)
	pValue = Ref{sMatrix4x4}()
	err = ccall(self.wrapper.funcs[:lib3mf_constmatnode_getmatrix], Int32, (Ptr{Cvoid}, Ref{sMatrix4x4}), self.handle, pValue)
	_checkError(self.wrapper, self, err)
	return pValue[]
end

function GetOutputMatrix(self::ConstMatNode)
	pMatrix = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_constmatnode_getoutputmatrix], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pMatrix)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pMatrix[])
end

function GetIdentifier(self::ConstMatNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::ConstMatNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::ConstMatNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::ConstMatNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::ConstMatNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::ConstMatNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::ConstMatNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::ConstMatNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::ConstMatNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::ConstMatNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::ConstMatNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::ConstMatNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::ConstMatNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::ConstMatNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::ConstMatNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputMesh(self::MeshNode)
	pMesh = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_meshnode_getinputmesh], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pMesh)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pMesh[])
end

function GetInputPos(self::MeshNode)
	pPos = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_meshnode_getinputpos], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pPos)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pPos[])
end

function GetOutputDistance(self::MeshNode)
	pDistance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_meshnode_getoutputdistance], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pDistance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pDistance[])
end

function GetIdentifier(self::MeshNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::MeshNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::MeshNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::MeshNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::MeshNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::MeshNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::MeshNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::MeshNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::MeshNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::MeshNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::MeshNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::MeshNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::MeshNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::MeshNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::MeshNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputMesh(self::UnsignedMeshNode)
	pMesh = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_unsignedmeshnode_getinputmesh], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pMesh)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pMesh[])
end

function GetInputPos(self::UnsignedMeshNode)
	pPos = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_unsignedmeshnode_getinputpos], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pPos)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pPos[])
end

function GetOutputDistance(self::UnsignedMeshNode)
	pDistance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_unsignedmeshnode_getoutputdistance], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pDistance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pDistance[])
end

function GetIdentifier(self::UnsignedMeshNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::UnsignedMeshNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::UnsignedMeshNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::UnsignedMeshNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::UnsignedMeshNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::UnsignedMeshNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::UnsignedMeshNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::UnsignedMeshNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::UnsignedMeshNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::UnsignedMeshNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::UnsignedMeshNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::UnsignedMeshNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::UnsignedMeshNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::UnsignedMeshNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::UnsignedMeshNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputBeamLattice(self::BeamLatticeNode)
	pBeamLattice = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_beamlatticenode_getinputbeamlattice], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pBeamLattice)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pBeamLattice[])
end

function GetInputPos(self::BeamLatticeNode)
	pPos = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_beamlatticenode_getinputpos], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pPos)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pPos[])
end

function GetOutputDistance(self::BeamLatticeNode)
	pDistance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_beamlatticenode_getoutputdistance], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pDistance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pDistance[])
end

function SetAccurateRange(self::BeamLatticeNode, AccurateRange::Cdouble)
	err = ccall(self.wrapper.funcs[:lib3mf_beamlatticenode_setaccuraterange], Int32, (Ptr{Cvoid}, Cdouble), self.handle, AccurateRange)
	_checkError(self.wrapper, self, err)
end

function GetAccurateRange(self::BeamLatticeNode)
	pAccurateRange = Ref{Cdouble}()
	err = ccall(self.wrapper.funcs[:lib3mf_beamlatticenode_getaccuraterange], Int32, (Ptr{Cvoid}, Ref{Cdouble}), self.handle, pAccurateRange)
	_checkError(self.wrapper, self, err)
	return pAccurateRange[]
end

function GetIdentifier(self::BeamLatticeNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::BeamLatticeNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::BeamLatticeNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::BeamLatticeNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::BeamLatticeNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::BeamLatticeNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::BeamLatticeNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::BeamLatticeNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::BeamLatticeNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::BeamLatticeNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::BeamLatticeNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::BeamLatticeNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::BeamLatticeNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::BeamLatticeNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::BeamLatticeNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputFunctionID(self::FunctionGradientNode)
	pFunction = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_functiongradientnode_getinputfunctionid], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pFunction)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pFunction[])
end

function GetInputPos(self::FunctionGradientNode)
	pPos = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_functiongradientnode_getinputpos], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pPos)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pPos[])
end

function GetInputStep(self::FunctionGradientNode)
	pStep = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_functiongradientnode_getinputstep], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pStep)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pStep[])
end

function SetScalarOutputName(self::FunctionGradientNode, ScalarOutputName::AbstractString)
	GC.@preserve ScalarOutputName begin
		err = ccall(self.wrapper.funcs[:lib3mf_functiongradientnode_setscalaroutputname], Int32, (Ptr{Cvoid}, Cstring), self.handle, ScalarOutputName)
	end
	_checkError(self.wrapper, self, err)
end

function GetScalarOutputName(self::FunctionGradientNode)
	nScalarOutputNameBufferSize = UInt64(0)
	nScalarOutputNameNeeded = Ref{UInt64}(0)
	pScalarOutputNameBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_functiongradientnode_getscalaroutputname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nScalarOutputNameBufferSize, nScalarOutputNameNeeded, pScalarOutputNameBuffer)
	_checkError(self.wrapper, self, err)
	pScalarOutputNameBuffer = Array{UInt8}(undef, Int(nScalarOutputNameNeeded[]))
	nScalarOutputNameBufferSize = UInt64(length(pScalarOutputNameBuffer))
	pScalarOutputNameBuffer_ptr = pointer(pScalarOutputNameBuffer)
	GC.@preserve pScalarOutputNameBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_functiongradientnode_getscalaroutputname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nScalarOutputNameBufferSize, nScalarOutputNameNeeded, pScalarOutputNameBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pScalarOutputNameBuffer_ptr)
end

function SetVectorInputName(self::FunctionGradientNode, VectorInputName::AbstractString)
	GC.@preserve VectorInputName begin
		err = ccall(self.wrapper.funcs[:lib3mf_functiongradientnode_setvectorinputname], Int32, (Ptr{Cvoid}, Cstring), self.handle, VectorInputName)
	end
	_checkError(self.wrapper, self, err)
end

function GetVectorInputName(self::FunctionGradientNode)
	nVectorInputNameBufferSize = UInt64(0)
	nVectorInputNameNeeded = Ref{UInt64}(0)
	pVectorInputNameBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_functiongradientnode_getvectorinputname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nVectorInputNameBufferSize, nVectorInputNameNeeded, pVectorInputNameBuffer)
	_checkError(self.wrapper, self, err)
	pVectorInputNameBuffer = Array{UInt8}(undef, Int(nVectorInputNameNeeded[]))
	nVectorInputNameBufferSize = UInt64(length(pVectorInputNameBuffer))
	pVectorInputNameBuffer_ptr = pointer(pVectorInputNameBuffer)
	GC.@preserve pVectorInputNameBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_functiongradientnode_getvectorinputname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nVectorInputNameBufferSize, nVectorInputNameNeeded, pVectorInputNameBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pVectorInputNameBuffer_ptr)
end

function GetOutputNormalizedGradient(self::FunctionGradientNode)
	pNormalizedGradient = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_functiongradientnode_getoutputnormalizedgradient], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pNormalizedGradient)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNormalizedGradient[])
end

function GetOutputGradient(self::FunctionGradientNode)
	pGradient = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_functiongradientnode_getoutputgradient], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pGradient)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pGradient[])
end

function GetOutputMagnitude(self::FunctionGradientNode)
	pMagnitude = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_functiongradientnode_getoutputmagnitude], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pMagnitude)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pMagnitude[])
end

function GetIdentifier(self::FunctionGradientNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::FunctionGradientNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::FunctionGradientNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::FunctionGradientNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::FunctionGradientNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::FunctionGradientNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::FunctionGradientNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::FunctionGradientNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::FunctionGradientNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::FunctionGradientNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::FunctionGradientNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::FunctionGradientNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::FunctionGradientNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::FunctionGradientNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::FunctionGradientNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputFunctionID(self::NormalizeDistanceNode)
	pFunction = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_normalizedistancenode_getinputfunctionid], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pFunction)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pFunction[])
end

function GetInputPos(self::NormalizeDistanceNode)
	pPos = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_normalizedistancenode_getinputpos], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pPos)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pPos[])
end

function GetInputStep(self::NormalizeDistanceNode)
	pStep = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_normalizedistancenode_getinputstep], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pStep)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pStep[])
end

function SetScalarOutputName(self::NormalizeDistanceNode, ScalarOutputName::AbstractString)
	GC.@preserve ScalarOutputName begin
		err = ccall(self.wrapper.funcs[:lib3mf_normalizedistancenode_setscalaroutputname], Int32, (Ptr{Cvoid}, Cstring), self.handle, ScalarOutputName)
	end
	_checkError(self.wrapper, self, err)
end

function GetScalarOutputName(self::NormalizeDistanceNode)
	nScalarOutputNameBufferSize = UInt64(0)
	nScalarOutputNameNeeded = Ref{UInt64}(0)
	pScalarOutputNameBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_normalizedistancenode_getscalaroutputname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nScalarOutputNameBufferSize, nScalarOutputNameNeeded, pScalarOutputNameBuffer)
	_checkError(self.wrapper, self, err)
	pScalarOutputNameBuffer = Array{UInt8}(undef, Int(nScalarOutputNameNeeded[]))
	nScalarOutputNameBufferSize = UInt64(length(pScalarOutputNameBuffer))
	pScalarOutputNameBuffer_ptr = pointer(pScalarOutputNameBuffer)
	GC.@preserve pScalarOutputNameBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_normalizedistancenode_getscalaroutputname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nScalarOutputNameBufferSize, nScalarOutputNameNeeded, pScalarOutputNameBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pScalarOutputNameBuffer_ptr)
end

function SetVectorInputName(self::NormalizeDistanceNode, VectorInputName::AbstractString)
	GC.@preserve VectorInputName begin
		err = ccall(self.wrapper.funcs[:lib3mf_normalizedistancenode_setvectorinputname], Int32, (Ptr{Cvoid}, Cstring), self.handle, VectorInputName)
	end
	_checkError(self.wrapper, self, err)
end

function GetVectorInputName(self::NormalizeDistanceNode)
	nVectorInputNameBufferSize = UInt64(0)
	nVectorInputNameNeeded = Ref{UInt64}(0)
	pVectorInputNameBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_normalizedistancenode_getvectorinputname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nVectorInputNameBufferSize, nVectorInputNameNeeded, pVectorInputNameBuffer)
	_checkError(self.wrapper, self, err)
	pVectorInputNameBuffer = Array{UInt8}(undef, Int(nVectorInputNameNeeded[]))
	nVectorInputNameBufferSize = UInt64(length(pVectorInputNameBuffer))
	pVectorInputNameBuffer_ptr = pointer(pVectorInputNameBuffer)
	GC.@preserve pVectorInputNameBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_normalizedistancenode_getvectorinputname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nVectorInputNameBufferSize, nVectorInputNameNeeded, pVectorInputNameBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pVectorInputNameBuffer_ptr)
end

function GetOutputResult(self::NormalizeDistanceNode)
	pResult = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_normalizedistancenode_getoutputresult], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResult)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResult[])
end

function GetIdentifier(self::NormalizeDistanceNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::NormalizeDistanceNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::NormalizeDistanceNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::NormalizeDistanceNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::NormalizeDistanceNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::NormalizeDistanceNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::NormalizeDistanceNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::NormalizeDistanceNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::NormalizeDistanceNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::NormalizeDistanceNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::NormalizeDistanceNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::NormalizeDistanceNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::NormalizeDistanceNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::NormalizeDistanceNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::NormalizeDistanceNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetInputFunctionID(self::FunctionCallNode)
	pFunction = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_functioncallnode_getinputfunctionid], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pFunction)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pFunction[])
end

function GetIdentifier(self::FunctionCallNode)
	return GetIdentifier(ImplicitNode(self.handle, self.wrapper))
end

function SetIdentifier(self::FunctionCallNode, Identifier::AbstractString)
	return SetIdentifier(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function GetDisplayName(self::FunctionCallNode)
	return GetDisplayName(ImplicitNode(self.handle, self.wrapper))
end

function SetDisplayName(self::FunctionCallNode, DisplayName::AbstractString)
	return SetDisplayName(ImplicitNode(self.handle, self.wrapper), DisplayName)
end

function GetTag(self::FunctionCallNode)
	return GetTag(ImplicitNode(self.handle, self.wrapper))
end

function SetTag(self::FunctionCallNode, Tag::AbstractString)
	return SetTag(ImplicitNode(self.handle, self.wrapper), Tag)
end

function GetNodeType(self::FunctionCallNode)
	return GetNodeType(ImplicitNode(self.handle, self.wrapper))
end

function AddInput(self::FunctionCallNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddInput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetInputs(self::FunctionCallNode)
	return GetInputs(ImplicitNode(self.handle, self.wrapper))
end

function AddOutput(self::FunctionCallNode, Identifier::AbstractString, DisplayName::AbstractString)
	return AddOutput(ImplicitNode(self.handle, self.wrapper), Identifier, DisplayName)
end

function GetOutputs(self::FunctionCallNode)
	return GetOutputs(ImplicitNode(self.handle, self.wrapper))
end

function FindInput(self::FunctionCallNode, Identifier::AbstractString)
	return FindInput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::FunctionCallNode, Identifier::AbstractString)
	return FindOutput(ImplicitNode(self.handle, self.wrapper), Identifier)
end

function AreTypesValid(self::FunctionCallNode)
	return AreTypesValid(ImplicitNode(self.handle, self.wrapper))
end

function ClassTypeId(self::FunctionCallNode)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetCurrent(self::NodeIterator)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_nodeiterator_getcurrent], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pNode)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function MoveNext(self::NodeIterator)
	return MoveNext(Iterator(self.handle, self.wrapper))
end

function MovePrevious(self::NodeIterator)
	return MovePrevious(Iterator(self.handle, self.wrapper))
end

function Count(self::NodeIterator)
	return Count(Iterator(self.handle, self.wrapper))
end

function ClassTypeId(self::NodeIterator)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetDisplayName(self::Function)
	nDisplayNameBufferSize = UInt64(0)
	nDisplayNameNeeded = Ref{UInt64}(0)
	pDisplayNameBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_function_getdisplayname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nDisplayNameBufferSize, nDisplayNameNeeded, pDisplayNameBuffer)
	_checkError(self.wrapper, self, err)
	pDisplayNameBuffer = Array{UInt8}(undef, Int(nDisplayNameNeeded[]))
	nDisplayNameBufferSize = UInt64(length(pDisplayNameBuffer))
	pDisplayNameBuffer_ptr = pointer(pDisplayNameBuffer)
	GC.@preserve pDisplayNameBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_function_getdisplayname], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nDisplayNameBufferSize, nDisplayNameNeeded, pDisplayNameBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pDisplayNameBuffer_ptr)
end

function SetDisplayName(self::Function, DisplayName::AbstractString)
	GC.@preserve DisplayName begin
		err = ccall(self.wrapper.funcs[:lib3mf_function_setdisplayname], Int32, (Ptr{Cvoid}, Cstring), self.handle, DisplayName)
	end
	_checkError(self.wrapper, self, err)
end

function AddInput(self::Function, Identifier::AbstractString, DisplayName::AbstractString, Type::eImplicitPortType)
	pPort = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName begin
		err = ccall(self.wrapper.funcs[:lib3mf_function_addinput], Int32, (Ptr{Cvoid}, Cstring, Cstring, eImplicitPortType, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Type, pPort)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pPort[])
end

function GetInputs(self::Function)
	pIterator = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_function_getinputs], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pIterator)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pIterator[])
end

function RemoveInput(self::Function, Input::ImplicitPort)
	err = ccall(self.wrapper.funcs[:lib3mf_function_removeinput], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, Input.handle)
	_checkError(self.wrapper, self, err)
end

function AddOutput(self::Function, Identifier::AbstractString, DisplayName::AbstractString, Type::eImplicitPortType)
	pPort = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName begin
		err = ccall(self.wrapper.funcs[:lib3mf_function_addoutput], Int32, (Ptr{Cvoid}, Cstring, Cstring, eImplicitPortType, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Type, pPort)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pPort[])
end

function GetOutputs(self::Function)
	pIterator = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_function_getoutputs], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pIterator)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pIterator[])
end

function RemoveOutput(self::Function, Output::ImplicitPort)
	err = ccall(self.wrapper.funcs[:lib3mf_function_removeoutput], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, Output.handle)
	_checkError(self.wrapper, self, err)
end

function FindInput(self::Function, Identifier::AbstractString)
	pInput = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier begin
		err = ccall(self.wrapper.funcs[:lib3mf_function_findinput], Int32, (Ptr{Cvoid}, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, pInput)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pInput[])
end

function FindOutput(self::Function, Identifier::AbstractString)
	pOutput = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier begin
		err = ccall(self.wrapper.funcs[:lib3mf_function_findoutput], Int32, (Ptr{Cvoid}, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, pOutput)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pOutput[])
end

function GetResourceID(self::Function)
	return GetResourceID(Resource(self.handle, self.wrapper))
end

function GetUniqueResourceID(self::Function)
	return GetUniqueResourceID(Resource(self.handle, self.wrapper))
end

function PackagePart(self::Function)
	return PackagePart(Resource(self.handle, self.wrapper))
end

function SetPackagePart(self::Function, PackagePart::PackagePart)
	return SetPackagePart(Resource(self.handle, self.wrapper), PackagePart)
end

function GetModelResourceID(self::Function)
	return GetModelResourceID(Resource(self.handle, self.wrapper))
end

function ClassTypeId(self::Function)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetIdentifier(self::ImplicitFunction)
	nIdentifierBufferSize = UInt64(0)
	nIdentifierNeeded = Ref{UInt64}(0)
	pIdentifierBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_getidentifier], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nIdentifierBufferSize, nIdentifierNeeded, pIdentifierBuffer)
	_checkError(self.wrapper, self, err)
	pIdentifierBuffer = Array{UInt8}(undef, Int(nIdentifierNeeded[]))
	nIdentifierBufferSize = UInt64(length(pIdentifierBuffer))
	pIdentifierBuffer_ptr = pointer(pIdentifierBuffer)
	GC.@preserve pIdentifierBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_getidentifier], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nIdentifierBufferSize, nIdentifierNeeded, pIdentifierBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pIdentifierBuffer_ptr)
end

function SetIdentifier(self::ImplicitFunction, Identifier::AbstractString)
	GC.@preserve Identifier begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_setidentifier], Int32, (Ptr{Cvoid}, Cstring), self.handle, Identifier)
	end
	_checkError(self.wrapper, self, err)
end

function AddNode(self::ImplicitFunction, NodeType::eImplicitNodeType, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addnode], Int32, (Ptr{Cvoid}, eImplicitNodeType, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, NodeType, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddSinNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addsinnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddCosNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addcosnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddTanNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addtannode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddArcSinNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addarcsinnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddArcCosNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addarccosnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddArcTan2Node(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addarctan2node], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddSinhNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addsinhnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddCoshNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addcoshnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddTanhNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addtanhnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddRoundNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addroundnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddCeilNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addceilnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddFloorNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addfloornode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddSignNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addsignnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddFractNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addfractnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddAbsNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addabsnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddExpNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addexpnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddLogNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addlognode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddLog2Node(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addlog2node], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddLog10Node(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addlog10node], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddLengthNode(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addlengthnode], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddTransposeNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addtransposenode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddInverseNode(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addinversenode], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddSqrtNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addsqrtnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddResourceIdNode(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addresourceidnode], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddAdditionNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addadditionnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddSubtractionNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addsubtractionnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddMultiplicationNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addmultiplicationnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddDivisionNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_adddivisionnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddDotNode(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_adddotnode], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddCrossNode(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addcrossnode], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddMatVecMultiplicationNode(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addmatvecmultiplicationnode], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddMinNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addminnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddMaxNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addmaxnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddFmodNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addfmodnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddPowNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addpownode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddSelectNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addselectnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddClampNode(self::ImplicitFunction, Identifier::AbstractString, Configuration::eImplicitNodeConfiguration, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addclampnode], Int32, (Ptr{Cvoid}, Cstring, eImplicitNodeConfiguration, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, Configuration, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddComposeVectorNode(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addcomposevectornode], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddVectorFromScalarNode(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addvectorfromscalarnode], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddDecomposeVectorNode(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_adddecomposevectornode], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddComposeMatrixNode(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addcomposematrixnode], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddMatrixFromRowsNode(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addmatrixfromrowsnode], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddMatrixFromColumnsNode(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addmatrixfromcolumnsnode], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddConstantNode(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addconstantnode], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddConstVecNode(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addconstvecnode], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddConstMatNode(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addconstmatnode], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddMeshNode(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addmeshnode], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddUnsignedMeshNode(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addunsignedmeshnode], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddBeamLatticeNode(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addbeamlatticenode], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddFunctionGradientNode(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addfunctiongradientnode], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddNormalizeDistanceNode(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addnormalizedistancenode], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function AddFunctionCallNode(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Tag::AbstractString)
	pNode = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve Identifier DisplayName Tag begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addfunctioncallnode], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, Identifier, DisplayName, Tag, pNode)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pNode[])
end

function GetNodes(self::ImplicitFunction)
	pIterator = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_getnodes], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pIterator)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pIterator[])
end

function RemoveNode(self::ImplicitFunction, Node::ImplicitNode)
	err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_removenode], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, Node.handle)
	_checkError(self.wrapper, self, err)
end

function AddLink(self::ImplicitFunction, Source::ImplicitPort, Target::ImplicitPort)
	err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addlink], Int32, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), self.handle, Source.handle, Target.handle)
	_checkError(self.wrapper, self, err)
end

function AddLinkByNames(self::ImplicitFunction, Source::AbstractString, Target::AbstractString)
	GC.@preserve Source Target begin
		err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_addlinkbynames], Int32, (Ptr{Cvoid}, Cstring, Cstring), self.handle, Source, Target)
	end
	_checkError(self.wrapper, self, err)
end

function Clear(self::ImplicitFunction)
	err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_clear], Int32, (Ptr{Cvoid},), self.handle)
	_checkError(self.wrapper, self, err)
end

function SortNodesTopologically(self::ImplicitFunction)
	err = ccall(self.wrapper.funcs[:lib3mf_implicitfunction_sortnodestopologically], Int32, (Ptr{Cvoid},), self.handle)
	_checkError(self.wrapper, self, err)
end

function GetDisplayName(self::ImplicitFunction)
	return GetDisplayName(Function(self.handle, self.wrapper))
end

function SetDisplayName(self::ImplicitFunction, DisplayName::AbstractString)
	return SetDisplayName(Function(self.handle, self.wrapper), DisplayName)
end

function AddInput(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Type::eImplicitPortType)
	return AddInput(Function(self.handle, self.wrapper), Identifier, DisplayName, Type)
end

function GetInputs(self::ImplicitFunction)
	return GetInputs(Function(self.handle, self.wrapper))
end

function RemoveInput(self::ImplicitFunction, Input::ImplicitPort)
	return RemoveInput(Function(self.handle, self.wrapper), Input)
end

function AddOutput(self::ImplicitFunction, Identifier::AbstractString, DisplayName::AbstractString, Type::eImplicitPortType)
	return AddOutput(Function(self.handle, self.wrapper), Identifier, DisplayName, Type)
end

function GetOutputs(self::ImplicitFunction)
	return GetOutputs(Function(self.handle, self.wrapper))
end

function RemoveOutput(self::ImplicitFunction, Output::ImplicitPort)
	return RemoveOutput(Function(self.handle, self.wrapper), Output)
end

function FindInput(self::ImplicitFunction, Identifier::AbstractString)
	return FindInput(Function(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::ImplicitFunction, Identifier::AbstractString)
	return FindOutput(Function(self.handle, self.wrapper), Identifier)
end

function GetResourceID(self::ImplicitFunction)
	return GetResourceID(Resource(self.handle, self.wrapper))
end

function GetUniqueResourceID(self::ImplicitFunction)
	return GetUniqueResourceID(Resource(self.handle, self.wrapper))
end

function PackagePart(self::ImplicitFunction)
	return PackagePart(Resource(self.handle, self.wrapper))
end

function SetPackagePart(self::ImplicitFunction, PackagePart::PackagePart)
	return SetPackagePart(Resource(self.handle, self.wrapper), PackagePart)
end

function GetModelResourceID(self::ImplicitFunction)
	return GetModelResourceID(Resource(self.handle, self.wrapper))
end

function ClassTypeId(self::ImplicitFunction)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetImage3D(self::FunctionFromImage3D)
	pImage3D = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_functionfromimage3d_getimage3d], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pImage3D)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pImage3D[])
end

function SetImage3D(self::FunctionFromImage3D, Image3D::Image3D)
	err = ccall(self.wrapper.funcs[:lib3mf_functionfromimage3d_setimage3d], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, Image3D.handle)
	_checkError(self.wrapper, self, err)
end

function SetFilter(self::FunctionFromImage3D, Filter::eTextureFilter)
	err = ccall(self.wrapper.funcs[:lib3mf_functionfromimage3d_setfilter], Int32, (Ptr{Cvoid}, eTextureFilter), self.handle, Filter)
	_checkError(self.wrapper, self, err)
end

function GetFilter(self::FunctionFromImage3D)
	pFilter = Ref{Int32}(0)
	err = ccall(self.wrapper.funcs[:lib3mf_functionfromimage3d_getfilter], Int32, (Ptr{Cvoid}, Ref{Int32}), self.handle, pFilter)
	_checkError(self.wrapper, self, err)
	return eTextureFilter(pFilter[])
end

function SetTileStyles(self::FunctionFromImage3D, TileStyleU::eTextureTileStyle, TileStyleV::eTextureTileStyle, TileStyleW::eTextureTileStyle)
	err = ccall(self.wrapper.funcs[:lib3mf_functionfromimage3d_settilestyles], Int32, (Ptr{Cvoid}, eTextureTileStyle, eTextureTileStyle, eTextureTileStyle), self.handle, TileStyleU, TileStyleV, TileStyleW)
	_checkError(self.wrapper, self, err)
end

function GetTileStyles(self::FunctionFromImage3D)
	pTileStyleU = Ref{Int32}(0)
	pTileStyleV = Ref{Int32}(0)
	pTileStyleW = Ref{Int32}(0)
	err = ccall(self.wrapper.funcs[:lib3mf_functionfromimage3d_gettilestyles], Int32, (Ptr{Cvoid}, Ref{Int32}, Ref{Int32}, Ref{Int32}), self.handle, pTileStyleU, pTileStyleV, pTileStyleW)
	_checkError(self.wrapper, self, err)
	return eTextureTileStyle(pTileStyleU[]), eTextureTileStyle(pTileStyleV[]), eTextureTileStyle(pTileStyleW[])
end

function GetOffset(self::FunctionFromImage3D)
	pOffset = Ref{Cdouble}()
	err = ccall(self.wrapper.funcs[:lib3mf_functionfromimage3d_getoffset], Int32, (Ptr{Cvoid}, Ref{Cdouble}), self.handle, pOffset)
	_checkError(self.wrapper, self, err)
	return pOffset[]
end

function SetOffset(self::FunctionFromImage3D, Offset::Cdouble)
	err = ccall(self.wrapper.funcs[:lib3mf_functionfromimage3d_setoffset], Int32, (Ptr{Cvoid}, Cdouble), self.handle, Offset)
	_checkError(self.wrapper, self, err)
end

function GetScale(self::FunctionFromImage3D)
	pScale = Ref{Cdouble}()
	err = ccall(self.wrapper.funcs[:lib3mf_functionfromimage3d_getscale], Int32, (Ptr{Cvoid}, Ref{Cdouble}), self.handle, pScale)
	_checkError(self.wrapper, self, err)
	return pScale[]
end

function SetScale(self::FunctionFromImage3D, Scale::Cdouble)
	err = ccall(self.wrapper.funcs[:lib3mf_functionfromimage3d_setscale], Int32, (Ptr{Cvoid}, Cdouble), self.handle, Scale)
	_checkError(self.wrapper, self, err)
end

function GetDisplayName(self::FunctionFromImage3D)
	return GetDisplayName(Function(self.handle, self.wrapper))
end

function SetDisplayName(self::FunctionFromImage3D, DisplayName::AbstractString)
	return SetDisplayName(Function(self.handle, self.wrapper), DisplayName)
end

function AddInput(self::FunctionFromImage3D, Identifier::AbstractString, DisplayName::AbstractString, Type::eImplicitPortType)
	return AddInput(Function(self.handle, self.wrapper), Identifier, DisplayName, Type)
end

function GetInputs(self::FunctionFromImage3D)
	return GetInputs(Function(self.handle, self.wrapper))
end

function RemoveInput(self::FunctionFromImage3D, Input::ImplicitPort)
	return RemoveInput(Function(self.handle, self.wrapper), Input)
end

function AddOutput(self::FunctionFromImage3D, Identifier::AbstractString, DisplayName::AbstractString, Type::eImplicitPortType)
	return AddOutput(Function(self.handle, self.wrapper), Identifier, DisplayName, Type)
end

function GetOutputs(self::FunctionFromImage3D)
	return GetOutputs(Function(self.handle, self.wrapper))
end

function RemoveOutput(self::FunctionFromImage3D, Output::ImplicitPort)
	return RemoveOutput(Function(self.handle, self.wrapper), Output)
end

function FindInput(self::FunctionFromImage3D, Identifier::AbstractString)
	return FindInput(Function(self.handle, self.wrapper), Identifier)
end

function FindOutput(self::FunctionFromImage3D, Identifier::AbstractString)
	return FindOutput(Function(self.handle, self.wrapper), Identifier)
end

function GetResourceID(self::FunctionFromImage3D)
	return GetResourceID(Resource(self.handle, self.wrapper))
end

function GetUniqueResourceID(self::FunctionFromImage3D)
	return GetUniqueResourceID(Resource(self.handle, self.wrapper))
end

function PackagePart(self::FunctionFromImage3D)
	return PackagePart(Resource(self.handle, self.wrapper))
end

function SetPackagePart(self::FunctionFromImage3D, PackagePart::PackagePart)
	return SetPackagePart(Resource(self.handle, self.wrapper), PackagePart)
end

function GetModelResourceID(self::FunctionFromImage3D)
	return GetModelResourceID(Resource(self.handle, self.wrapper))
end

function ClassTypeId(self::FunctionFromImage3D)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetObjectResource(self::BuildItem)
	pObjectResource = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_builditem_getobjectresource], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pObjectResource)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pObjectResource[])
end

function GetUUID(self::BuildItem)
	pHasUUID = Ref{Cbool}()
	nUUIDBufferSize = UInt64(0)
	nUUIDNeeded = Ref{UInt64}(0)
	pUUIDBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_builditem_getuuid], Int32, (Ptr{Cvoid}, Ref{Cbool}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, pHasUUID, nUUIDBufferSize, nUUIDNeeded, pUUIDBuffer)
	_checkError(self.wrapper, self, err)
	pUUIDBuffer = Array{UInt8}(undef, Int(nUUIDNeeded[]))
	nUUIDBufferSize = UInt64(length(pUUIDBuffer))
	pUUIDBuffer_ptr = pointer(pUUIDBuffer)
	GC.@preserve pUUIDBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_builditem_getuuid], Int32, (Ptr{Cvoid}, Ref{Cbool}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, pHasUUID, nUUIDBufferSize, nUUIDNeeded, pUUIDBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pHasUUID[] != 0, unsafe_string(pUUIDBuffer_ptr)
end

function SetUUID(self::BuildItem, UUID::AbstractString)
	GC.@preserve UUID begin
		err = ccall(self.wrapper.funcs[:lib3mf_builditem_setuuid], Int32, (Ptr{Cvoid}, Cstring), self.handle, UUID)
	end
	_checkError(self.wrapper, self, err)
end

function GetObjectResourceID(self::BuildItem)
	pUniqueResourceID = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_builditem_getobjectresourceid], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pUniqueResourceID)
	_checkError(self.wrapper, self, err)
	return pUniqueResourceID[]
end

function HasObjectTransform(self::BuildItem)
	pHasTransform = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_builditem_hasobjecttransform], Int32, (Ptr{Cvoid}, Ref{Cbool}), self.handle, pHasTransform)
	_checkError(self.wrapper, self, err)
	return pHasTransform[] != 0
end

function GetObjectTransform(self::BuildItem)
	pTransform = Ref{sTransform}()
	err = ccall(self.wrapper.funcs[:lib3mf_builditem_getobjecttransform], Int32, (Ptr{Cvoid}, Ref{sTransform}), self.handle, pTransform)
	_checkError(self.wrapper, self, err)
	return pTransform[]
end

function SetObjectTransform(self::BuildItem, Transform::sTransform)
	pTransform = Ref{sTransform}(Transform)
	err = ccall(self.wrapper.funcs[:lib3mf_builditem_setobjecttransform], Int32, (Ptr{Cvoid}, Ref{sTransform}), self.handle, pTransform)
	_checkError(self.wrapper, self, err)
end

function GetPartNumber(self::BuildItem)
	nPartNumberBufferSize = UInt64(0)
	nPartNumberNeeded = Ref{UInt64}(0)
	pPartNumberBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_builditem_getpartnumber], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nPartNumberBufferSize, nPartNumberNeeded, pPartNumberBuffer)
	_checkError(self.wrapper, self, err)
	pPartNumberBuffer = Array{UInt8}(undef, Int(nPartNumberNeeded[]))
	nPartNumberBufferSize = UInt64(length(pPartNumberBuffer))
	pPartNumberBuffer_ptr = pointer(pPartNumberBuffer)
	GC.@preserve pPartNumberBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_builditem_getpartnumber], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nPartNumberBufferSize, nPartNumberNeeded, pPartNumberBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pPartNumberBuffer_ptr)
end

function SetPartNumber(self::BuildItem, SetPartnumber::AbstractString)
	GC.@preserve SetPartnumber begin
		err = ccall(self.wrapper.funcs[:lib3mf_builditem_setpartnumber], Int32, (Ptr{Cvoid}, Cstring), self.handle, SetPartnumber)
	end
	_checkError(self.wrapper, self, err)
end

function GetMetaDataGroup(self::BuildItem)
	pMetaDataGroup = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_builditem_getmetadatagroup], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pMetaDataGroup)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pMetaDataGroup[])
end

function GetOutbox(self::BuildItem)
	pOutbox = Ref{sBox}()
	err = ccall(self.wrapper.funcs[:lib3mf_builditem_getoutbox], Int32, (Ptr{Cvoid}, Ref{sBox}), self.handle, pOutbox)
	_checkError(self.wrapper, self, err)
	return pOutbox[]
end

function ClassTypeId(self::BuildItem)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function MoveNext(self::BuildItemIterator)
	pHasNext = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_builditemiterator_movenext], Int32, (Ptr{Cvoid}, Ref{Cbool}), self.handle, pHasNext)
	_checkError(self.wrapper, self, err)
	return pHasNext[] != 0
end

function MovePrevious(self::BuildItemIterator)
	pHasPrevious = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_builditemiterator_moveprevious], Int32, (Ptr{Cvoid}, Ref{Cbool}), self.handle, pHasPrevious)
	_checkError(self.wrapper, self, err)
	return pHasPrevious[] != 0
end

function GetCurrent(self::BuildItemIterator)
	pBuildItem = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_builditemiterator_getcurrent], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pBuildItem)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pBuildItem[])
end

function Clone(self::BuildItemIterator)
	pOutBuildItemIterator = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_builditemiterator_clone], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pOutBuildItemIterator)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pOutBuildItemIterator[])
end

function Count(self::BuildItemIterator)
	pCount = Ref{UInt64}()
	err = ccall(self.wrapper.funcs[:lib3mf_builditemiterator_count], Int32, (Ptr{Cvoid}, Ref{UInt64}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function ClassTypeId(self::BuildItemIterator)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function SetVertices(self::Slice, Vertices::Array{sPosition2D, 1})
	nVerticesCount = UInt64(length(Vertices))
	pVerticesBuffer = length(Vertices) == 0 ? Ptr{sPosition2D}(C_NULL) : pointer(Vertices)
	GC.@preserve Vertices begin
		err = ccall(self.wrapper.funcs[:lib3mf_slice_setvertices], Int32, (Ptr{Cvoid}, UInt64, Ptr{sPosition2D}), self.handle, nVerticesCount, pVerticesBuffer)
	end
	_checkError(self.wrapper, self, err)
end

function GetVertices(self::Slice)
	nVerticesCount = UInt64(0)
	nVerticesNeeded = Ref{UInt64}(0)
	pVerticesBuffer = Ptr{sPosition2D}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_slice_getvertices], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{sPosition2D}), self.handle, nVerticesCount, nVerticesNeeded, pVerticesBuffer)
	_checkError(self.wrapper, self, err)
	pVerticesBuffer = Array{sPosition2D}(undef, Int(nVerticesNeeded[]))
	nVerticesCount = UInt64(length(pVerticesBuffer))
	pVerticesBuffer_ptr = pointer(pVerticesBuffer)
	GC.@preserve pVerticesBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_slice_getvertices], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{sPosition2D}), self.handle, nVerticesCount, nVerticesNeeded, pVerticesBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pVerticesBuffer
end

function GetVertexCount(self::Slice)
	pCount = Ref{UInt64}()
	err = ccall(self.wrapper.funcs[:lib3mf_slice_getvertexcount], Int32, (Ptr{Cvoid}, Ref{UInt64}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function AddPolygon(self::Slice, Indices::Array{UInt32, 1})
	nIndicesCount = UInt64(length(Indices))
	pIndicesBuffer = length(Indices) == 0 ? Ptr{UInt32}(C_NULL) : pointer(Indices)
	pIndex = Ref{UInt64}()
	GC.@preserve Indices begin
		err = ccall(self.wrapper.funcs[:lib3mf_slice_addpolygon], Int32, (Ptr{Cvoid}, UInt64, Ptr{UInt32}, Ref{UInt64}), self.handle, nIndicesCount, pIndicesBuffer, pIndex)
	end
	_checkError(self.wrapper, self, err)
	return pIndex[]
end

function GetPolygonCount(self::Slice)
	pCount = Ref{UInt64}()
	err = ccall(self.wrapper.funcs[:lib3mf_slice_getpolygoncount], Int32, (Ptr{Cvoid}, Ref{UInt64}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function SetPolygonIndices(self::Slice, Index::UInt64, Indices::Array{UInt32, 1})
	nIndicesCount = UInt64(length(Indices))
	pIndicesBuffer = length(Indices) == 0 ? Ptr{UInt32}(C_NULL) : pointer(Indices)
	GC.@preserve Indices begin
		err = ccall(self.wrapper.funcs[:lib3mf_slice_setpolygonindices], Int32, (Ptr{Cvoid}, UInt64, UInt64, Ptr{UInt32}), self.handle, Index, nIndicesCount, pIndicesBuffer)
	end
	_checkError(self.wrapper, self, err)
end

function GetPolygonIndices(self::Slice, Index::UInt64)
	nIndicesCount = UInt64(0)
	nIndicesNeeded = Ref{UInt64}(0)
	pIndicesBuffer = Ptr{UInt32}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_slice_getpolygonindices], Int32, (Ptr{Cvoid}, UInt64, UInt64, Ref{UInt64}, Ptr{UInt32}), self.handle, Index, nIndicesCount, nIndicesNeeded, pIndicesBuffer)
	_checkError(self.wrapper, self, err)
	pIndicesBuffer = Array{UInt32}(undef, Int(nIndicesNeeded[]))
	nIndicesCount = UInt64(length(pIndicesBuffer))
	pIndicesBuffer_ptr = pointer(pIndicesBuffer)
	GC.@preserve pIndicesBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_slice_getpolygonindices], Int32, (Ptr{Cvoid}, UInt64, UInt64, Ref{UInt64}, Ptr{UInt32}), self.handle, Index, nIndicesCount, nIndicesNeeded, pIndicesBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pIndicesBuffer
end

function GetPolygonIndexCount(self::Slice, Index::UInt64)
	pCount = Ref{UInt64}()
	err = ccall(self.wrapper.funcs[:lib3mf_slice_getpolygonindexcount], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}), self.handle, Index, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function GetZTop(self::Slice)
	pZTop = Ref{Cdouble}()
	err = ccall(self.wrapper.funcs[:lib3mf_slice_getztop], Int32, (Ptr{Cvoid}, Ref{Cdouble}), self.handle, pZTop)
	_checkError(self.wrapper, self, err)
	return pZTop[]
end

function ClassTypeId(self::Slice)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetBottomZ(self::SliceStack)
	pZBottom = Ref{Cdouble}()
	err = ccall(self.wrapper.funcs[:lib3mf_slicestack_getbottomz], Int32, (Ptr{Cvoid}, Ref{Cdouble}), self.handle, pZBottom)
	_checkError(self.wrapper, self, err)
	return pZBottom[]
end

function GetSliceCount(self::SliceStack)
	pCount = Ref{UInt64}()
	err = ccall(self.wrapper.funcs[:lib3mf_slicestack_getslicecount], Int32, (Ptr{Cvoid}, Ref{UInt64}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function GetSlice(self::SliceStack, SliceIndex::UInt64)
	pTheSlice = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_slicestack_getslice], Int32, (Ptr{Cvoid}, UInt64, Ref{Ptr{Cvoid}}), self.handle, SliceIndex, pTheSlice)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheSlice[])
end

function AddSlice(self::SliceStack, ZTop::Cdouble)
	pTheSlice = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_slicestack_addslice], Int32, (Ptr{Cvoid}, Cdouble, Ref{Ptr{Cvoid}}), self.handle, ZTop, pTheSlice)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheSlice[])
end

function GetSliceRefCount(self::SliceStack)
	pCount = Ref{UInt64}()
	err = ccall(self.wrapper.funcs[:lib3mf_slicestack_getslicerefcount], Int32, (Ptr{Cvoid}, Ref{UInt64}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function AddSliceStackReference(self::SliceStack, TheSliceStack::SliceStack)
	err = ccall(self.wrapper.funcs[:lib3mf_slicestack_addslicestackreference], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, TheSliceStack.handle)
	_checkError(self.wrapper, self, err)
end

function GetSliceStackReference(self::SliceStack, SliceRefIndex::UInt64)
	pTheSliceStack = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_slicestack_getslicestackreference], Int32, (Ptr{Cvoid}, UInt64, Ref{Ptr{Cvoid}}), self.handle, SliceRefIndex, pTheSliceStack)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheSliceStack[])
end

function CollapseSliceReferences(self::SliceStack)
	err = ccall(self.wrapper.funcs[:lib3mf_slicestack_collapseslicereferences], Int32, (Ptr{Cvoid},), self.handle)
	_checkError(self.wrapper, self, err)
end

function SetOwnPath(self::SliceStack, Path::AbstractString)
	GC.@preserve Path begin
		err = ccall(self.wrapper.funcs[:lib3mf_slicestack_setownpath], Int32, (Ptr{Cvoid}, Cstring), self.handle, Path)
	end
	_checkError(self.wrapper, self, err)
end

function GetOwnPath(self::SliceStack)
	nPathBufferSize = UInt64(0)
	nPathNeeded = Ref{UInt64}(0)
	pPathBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_slicestack_getownpath], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nPathBufferSize, nPathNeeded, pPathBuffer)
	_checkError(self.wrapper, self, err)
	pPathBuffer = Array{UInt8}(undef, Int(nPathNeeded[]))
	nPathBufferSize = UInt64(length(pPathBuffer))
	pPathBuffer_ptr = pointer(pPathBuffer)
	GC.@preserve pPathBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_slicestack_getownpath], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nPathBufferSize, nPathNeeded, pPathBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pPathBuffer_ptr)
end

function GetResourceID(self::SliceStack)
	return GetResourceID(Resource(self.handle, self.wrapper))
end

function GetUniqueResourceID(self::SliceStack)
	return GetUniqueResourceID(Resource(self.handle, self.wrapper))
end

function PackagePart(self::SliceStack)
	return PackagePart(Resource(self.handle, self.wrapper))
end

function SetPackagePart(self::SliceStack, PackagePart::PackagePart)
	return SetPackagePart(Resource(self.handle, self.wrapper), PackagePart)
end

function GetModelResourceID(self::SliceStack)
	return GetModelResourceID(Resource(self.handle, self.wrapper))
end

function ClassTypeId(self::SliceStack)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetConsumerID(self::Consumer)
	nConsumerIDBufferSize = UInt64(0)
	nConsumerIDNeeded = Ref{UInt64}(0)
	pConsumerIDBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_consumer_getconsumerid], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nConsumerIDBufferSize, nConsumerIDNeeded, pConsumerIDBuffer)
	_checkError(self.wrapper, self, err)
	pConsumerIDBuffer = Array{UInt8}(undef, Int(nConsumerIDNeeded[]))
	nConsumerIDBufferSize = UInt64(length(pConsumerIDBuffer))
	pConsumerIDBuffer_ptr = pointer(pConsumerIDBuffer)
	GC.@preserve pConsumerIDBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_consumer_getconsumerid], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nConsumerIDBufferSize, nConsumerIDNeeded, pConsumerIDBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pConsumerIDBuffer_ptr)
end

function GetKeyID(self::Consumer)
	nKeyIDBufferSize = UInt64(0)
	nKeyIDNeeded = Ref{UInt64}(0)
	pKeyIDBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_consumer_getkeyid], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nKeyIDBufferSize, nKeyIDNeeded, pKeyIDBuffer)
	_checkError(self.wrapper, self, err)
	pKeyIDBuffer = Array{UInt8}(undef, Int(nKeyIDNeeded[]))
	nKeyIDBufferSize = UInt64(length(pKeyIDBuffer))
	pKeyIDBuffer_ptr = pointer(pKeyIDBuffer)
	GC.@preserve pKeyIDBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_consumer_getkeyid], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nKeyIDBufferSize, nKeyIDNeeded, pKeyIDBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pKeyIDBuffer_ptr)
end

function GetKeyValue(self::Consumer)
	nKeyValueBufferSize = UInt64(0)
	nKeyValueNeeded = Ref{UInt64}(0)
	pKeyValueBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_consumer_getkeyvalue], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nKeyValueBufferSize, nKeyValueNeeded, pKeyValueBuffer)
	_checkError(self.wrapper, self, err)
	pKeyValueBuffer = Array{UInt8}(undef, Int(nKeyValueNeeded[]))
	nKeyValueBufferSize = UInt64(length(pKeyValueBuffer))
	pKeyValueBuffer_ptr = pointer(pKeyValueBuffer)
	GC.@preserve pKeyValueBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_consumer_getkeyvalue], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nKeyValueBufferSize, nKeyValueNeeded, pKeyValueBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pKeyValueBuffer_ptr)
end

function ClassTypeId(self::Consumer)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetConsumer(self::AccessRight)
	pConsumer = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_accessright_getconsumer], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pConsumer)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pConsumer[])
end

function GetWrappingAlgorithm(self::AccessRight)
	pAlgorithm = Ref{Int32}(0)
	err = ccall(self.wrapper.funcs[:lib3mf_accessright_getwrappingalgorithm], Int32, (Ptr{Cvoid}, Ref{Int32}), self.handle, pAlgorithm)
	_checkError(self.wrapper, self, err)
	return eWrappingAlgorithm(pAlgorithm[])
end

function GetMgfAlgorithm(self::AccessRight)
	pAlgorithm = Ref{Int32}(0)
	err = ccall(self.wrapper.funcs[:lib3mf_accessright_getmgfalgorithm], Int32, (Ptr{Cvoid}, Ref{Int32}), self.handle, pAlgorithm)
	_checkError(self.wrapper, self, err)
	return eMgfAlgorithm(pAlgorithm[])
end

function GetDigestMethod(self::AccessRight)
	pAlgorithm = Ref{Int32}(0)
	err = ccall(self.wrapper.funcs[:lib3mf_accessright_getdigestmethod], Int32, (Ptr{Cvoid}, Ref{Int32}), self.handle, pAlgorithm)
	_checkError(self.wrapper, self, err)
	return eDigestMethod(pAlgorithm[])
end

function ClassTypeId(self::AccessRight)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetEncryptionAlgorithm(self::ContentEncryptionParams)
	pAlgorithm = Ref{Int32}(0)
	err = ccall(self.wrapper.funcs[:lib3mf_contentencryptionparams_getencryptionalgorithm], Int32, (Ptr{Cvoid}, Ref{Int32}), self.handle, pAlgorithm)
	_checkError(self.wrapper, self, err)
	return eEncryptionAlgorithm(pAlgorithm[])
end

function GetKey(self::ContentEncryptionParams)
	nByteDataCount = UInt64(0)
	nByteDataNeeded = Ref{UInt64}(0)
	pByteDataBuffer = Ptr{UInt8}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_contentencryptionparams_getkey], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt8}), self.handle, nByteDataCount, nByteDataNeeded, pByteDataBuffer)
	_checkError(self.wrapper, self, err)
	pByteDataBuffer = Array{UInt8}(undef, Int(nByteDataNeeded[]))
	nByteDataCount = UInt64(length(pByteDataBuffer))
	pByteDataBuffer_ptr = pointer(pByteDataBuffer)
	GC.@preserve pByteDataBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_contentencryptionparams_getkey], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt8}), self.handle, nByteDataCount, nByteDataNeeded, pByteDataBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pByteDataBuffer
end

function GetInitializationVector(self::ContentEncryptionParams)
	nByteDataCount = UInt64(0)
	nByteDataNeeded = Ref{UInt64}(0)
	pByteDataBuffer = Ptr{UInt8}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_contentencryptionparams_getinitializationvector], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt8}), self.handle, nByteDataCount, nByteDataNeeded, pByteDataBuffer)
	_checkError(self.wrapper, self, err)
	pByteDataBuffer = Array{UInt8}(undef, Int(nByteDataNeeded[]))
	nByteDataCount = UInt64(length(pByteDataBuffer))
	pByteDataBuffer_ptr = pointer(pByteDataBuffer)
	GC.@preserve pByteDataBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_contentencryptionparams_getinitializationvector], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt8}), self.handle, nByteDataCount, nByteDataNeeded, pByteDataBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pByteDataBuffer
end

function GetAuthenticationTag(self::ContentEncryptionParams)
	nByteDataCount = UInt64(0)
	nByteDataNeeded = Ref{UInt64}(0)
	pByteDataBuffer = Ptr{UInt8}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_contentencryptionparams_getauthenticationtag], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt8}), self.handle, nByteDataCount, nByteDataNeeded, pByteDataBuffer)
	_checkError(self.wrapper, self, err)
	pByteDataBuffer = Array{UInt8}(undef, Int(nByteDataNeeded[]))
	nByteDataCount = UInt64(length(pByteDataBuffer))
	pByteDataBuffer_ptr = pointer(pByteDataBuffer)
	GC.@preserve pByteDataBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_contentencryptionparams_getauthenticationtag], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt8}), self.handle, nByteDataCount, nByteDataNeeded, pByteDataBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pByteDataBuffer
end

function SetAuthenticationTag(self::ContentEncryptionParams, ByteData::Array{UInt8, 1})
	nByteDataCount = UInt64(length(ByteData))
	pByteDataBuffer = length(ByteData) == 0 ? Ptr{UInt8}(C_NULL) : pointer(ByteData)
	GC.@preserve ByteData begin
		err = ccall(self.wrapper.funcs[:lib3mf_contentencryptionparams_setauthenticationtag], Int32, (Ptr{Cvoid}, UInt64, Ptr{UInt8}), self.handle, nByteDataCount, pByteDataBuffer)
	end
	_checkError(self.wrapper, self, err)
end

function GetAdditionalAuthenticationData(self::ContentEncryptionParams)
	nByteDataCount = UInt64(0)
	nByteDataNeeded = Ref{UInt64}(0)
	pByteDataBuffer = Ptr{UInt8}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_contentencryptionparams_getadditionalauthenticationdata], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt8}), self.handle, nByteDataCount, nByteDataNeeded, pByteDataBuffer)
	_checkError(self.wrapper, self, err)
	pByteDataBuffer = Array{UInt8}(undef, Int(nByteDataNeeded[]))
	nByteDataCount = UInt64(length(pByteDataBuffer))
	pByteDataBuffer_ptr = pointer(pByteDataBuffer)
	GC.@preserve pByteDataBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_contentencryptionparams_getadditionalauthenticationdata], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt8}), self.handle, nByteDataCount, nByteDataNeeded, pByteDataBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pByteDataBuffer
end

function GetDescriptor(self::ContentEncryptionParams)
	pDescriptor = Ref{UInt64}()
	err = ccall(self.wrapper.funcs[:lib3mf_contentencryptionparams_getdescriptor], Int32, (Ptr{Cvoid}, Ref{UInt64}), self.handle, pDescriptor)
	_checkError(self.wrapper, self, err)
	return pDescriptor[]
end

function GetKeyUUID(self::ContentEncryptionParams)
	nUUIDBufferSize = UInt64(0)
	nUUIDNeeded = Ref{UInt64}(0)
	pUUIDBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_contentencryptionparams_getkeyuuid], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nUUIDBufferSize, nUUIDNeeded, pUUIDBuffer)
	_checkError(self.wrapper, self, err)
	pUUIDBuffer = Array{UInt8}(undef, Int(nUUIDNeeded[]))
	nUUIDBufferSize = UInt64(length(pUUIDBuffer))
	pUUIDBuffer_ptr = pointer(pUUIDBuffer)
	GC.@preserve pUUIDBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_contentencryptionparams_getkeyuuid], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nUUIDBufferSize, nUUIDNeeded, pUUIDBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pUUIDBuffer_ptr)
end

function ClassTypeId(self::ContentEncryptionParams)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetPath(self::ResourceData)
	pPath = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_resourcedata_getpath], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pPath)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pPath[])
end

function GetEncryptionAlgorithm(self::ResourceData)
	pEncryptionAlgorithm = Ref{Int32}(0)
	err = ccall(self.wrapper.funcs[:lib3mf_resourcedata_getencryptionalgorithm], Int32, (Ptr{Cvoid}, Ref{Int32}), self.handle, pEncryptionAlgorithm)
	_checkError(self.wrapper, self, err)
	return eEncryptionAlgorithm(pEncryptionAlgorithm[])
end

function GetCompression(self::ResourceData)
	pCompression = Ref{Int32}(0)
	err = ccall(self.wrapper.funcs[:lib3mf_resourcedata_getcompression], Int32, (Ptr{Cvoid}, Ref{Int32}), self.handle, pCompression)
	_checkError(self.wrapper, self, err)
	return eCompression(pCompression[])
end

function GetAdditionalAuthenticationData(self::ResourceData)
	nByteDataCount = UInt64(0)
	nByteDataNeeded = Ref{UInt64}(0)
	pByteDataBuffer = Ptr{UInt8}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_resourcedata_getadditionalauthenticationdata], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt8}), self.handle, nByteDataCount, nByteDataNeeded, pByteDataBuffer)
	_checkError(self.wrapper, self, err)
	pByteDataBuffer = Array{UInt8}(undef, Int(nByteDataNeeded[]))
	nByteDataCount = UInt64(length(pByteDataBuffer))
	pByteDataBuffer_ptr = pointer(pByteDataBuffer)
	GC.@preserve pByteDataBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_resourcedata_getadditionalauthenticationdata], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{UInt8}), self.handle, nByteDataCount, nByteDataNeeded, pByteDataBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pByteDataBuffer
end

function ClassTypeId(self::ResourceData)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function GetKeyUUID(self::ResourceDataGroup)
	nUUIDBufferSize = UInt64(0)
	nUUIDNeeded = Ref{UInt64}(0)
	pUUIDBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_resourcedatagroup_getkeyuuid], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nUUIDBufferSize, nUUIDNeeded, pUUIDBuffer)
	_checkError(self.wrapper, self, err)
	pUUIDBuffer = Array{UInt8}(undef, Int(nUUIDNeeded[]))
	nUUIDBufferSize = UInt64(length(pUUIDBuffer))
	pUUIDBuffer_ptr = pointer(pUUIDBuffer)
	GC.@preserve pUUIDBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_resourcedatagroup_getkeyuuid], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nUUIDBufferSize, nUUIDNeeded, pUUIDBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pUUIDBuffer_ptr)
end

function AddAccessRight(self::ResourceDataGroup, Consumer::Consumer, WrappingAlgorithm::eWrappingAlgorithm, MgfAlgorithm::eMgfAlgorithm, DigestMethod::eDigestMethod)
	pTheAccessRight = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_resourcedatagroup_addaccessright], Int32, (Ptr{Cvoid}, Ptr{Cvoid}, eWrappingAlgorithm, eMgfAlgorithm, eDigestMethod, Ref{Ptr{Cvoid}}), self.handle, Consumer.handle, WrappingAlgorithm, MgfAlgorithm, DigestMethod, pTheAccessRight)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheAccessRight[])
end

function FindAccessRightByConsumer(self::ResourceDataGroup, Consumer::Consumer)
	pTheAccessRight = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_resourcedatagroup_findaccessrightbyconsumer], Int32, (Ptr{Cvoid}, Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, Consumer.handle, pTheAccessRight)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheAccessRight[])
end

function RemoveAccessRight(self::ResourceDataGroup, Consumer::Consumer)
	err = ccall(self.wrapper.funcs[:lib3mf_resourcedatagroup_removeaccessright], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, Consumer.handle)
	_checkError(self.wrapper, self, err)
end

function ClassTypeId(self::ResourceDataGroup)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function AddConsumer(self::KeyStore, ConsumerID::AbstractString, KeyID::AbstractString, KeyValue::AbstractString)
	pConsumer = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve ConsumerID KeyID KeyValue begin
		err = ccall(self.wrapper.funcs[:lib3mf_keystore_addconsumer], Int32, (Ptr{Cvoid}, Cstring, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, ConsumerID, KeyID, KeyValue, pConsumer)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pConsumer[])
end

function GetConsumerCount(self::KeyStore)
	pCount = Ref{UInt64}()
	err = ccall(self.wrapper.funcs[:lib3mf_keystore_getconsumercount], Int32, (Ptr{Cvoid}, Ref{UInt64}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function GetConsumer(self::KeyStore, ConsumerIndex::UInt64)
	pConsumer = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_keystore_getconsumer], Int32, (Ptr{Cvoid}, UInt64, Ref{Ptr{Cvoid}}), self.handle, ConsumerIndex, pConsumer)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pConsumer[])
end

function RemoveConsumer(self::KeyStore, Consumer::Consumer)
	err = ccall(self.wrapper.funcs[:lib3mf_keystore_removeconsumer], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, Consumer.handle)
	_checkError(self.wrapper, self, err)
end

function FindConsumer(self::KeyStore, ConsumerID::AbstractString)
	pConsumer = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve ConsumerID begin
		err = ccall(self.wrapper.funcs[:lib3mf_keystore_findconsumer], Int32, (Ptr{Cvoid}, Cstring, Ref{Ptr{Cvoid}}), self.handle, ConsumerID, pConsumer)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pConsumer[])
end

function GetResourceDataGroupCount(self::KeyStore)
	pCount = Ref{UInt64}()
	err = ccall(self.wrapper.funcs[:lib3mf_keystore_getresourcedatagroupcount], Int32, (Ptr{Cvoid}, Ref{UInt64}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function AddResourceDataGroup(self::KeyStore)
	pResourceDataGroup = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_keystore_addresourcedatagroup], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResourceDataGroup)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResourceDataGroup[])
end

function GetResourceDataGroup(self::KeyStore, ResourceDataIndex::UInt64)
	pResourceDataGroup = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_keystore_getresourcedatagroup], Int32, (Ptr{Cvoid}, UInt64, Ref{Ptr{Cvoid}}), self.handle, ResourceDataIndex, pResourceDataGroup)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResourceDataGroup[])
end

function RemoveResourceDataGroup(self::KeyStore, ResourceDataGroup::ResourceDataGroup)
	err = ccall(self.wrapper.funcs[:lib3mf_keystore_removeresourcedatagroup], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, ResourceDataGroup.handle)
	_checkError(self.wrapper, self, err)
end

function FindResourceDataGroup(self::KeyStore, PartPath::PackagePart)
	pResourceDataGroup = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_keystore_findresourcedatagroup], Int32, (Ptr{Cvoid}, Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, PartPath.handle, pResourceDataGroup)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResourceDataGroup[])
end

function AddResourceData(self::KeyStore, ResourceDataGroup::ResourceDataGroup, PartPath::PackagePart, Algorithm::eEncryptionAlgorithm, Compression::eCompression, AdditionalAuthenticationData::Array{UInt8, 1})
	nAdditionalAuthenticationDataCount = UInt64(length(AdditionalAuthenticationData))
	pAdditionalAuthenticationDataBuffer = length(AdditionalAuthenticationData) == 0 ? Ptr{UInt8}(C_NULL) : pointer(AdditionalAuthenticationData)
	pResourceData = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve AdditionalAuthenticationData begin
		err = ccall(self.wrapper.funcs[:lib3mf_keystore_addresourcedata], Int32, (Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}, eEncryptionAlgorithm, eCompression, UInt64, Ptr{UInt8}, Ref{Ptr{Cvoid}}), self.handle, ResourceDataGroup.handle, PartPath.handle, Algorithm, Compression, nAdditionalAuthenticationDataCount, pAdditionalAuthenticationDataBuffer, pResourceData)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResourceData[])
end

function RemoveResourceData(self::KeyStore, ResourceData::ResourceData)
	err = ccall(self.wrapper.funcs[:lib3mf_keystore_removeresourcedata], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, ResourceData.handle)
	_checkError(self.wrapper, self, err)
end

function FindResourceData(self::KeyStore, ResourcePath::PackagePart)
	pResourceData = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_keystore_findresourcedata], Int32, (Ptr{Cvoid}, Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, ResourcePath.handle, pResourceData)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResourceData[])
end

function GetResourceDataCount(self::KeyStore)
	pCount = Ref{UInt64}()
	err = ccall(self.wrapper.funcs[:lib3mf_keystore_getresourcedatacount], Int32, (Ptr{Cvoid}, Ref{UInt64}), self.handle, pCount)
	_checkError(self.wrapper, self, err)
	return pCount[]
end

function GetResourceData(self::KeyStore, ResourceDataIndex::UInt64)
	pResourceData = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_keystore_getresourcedata], Int32, (Ptr{Cvoid}, UInt64, Ref{Ptr{Cvoid}}), self.handle, ResourceDataIndex, pResourceData)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResourceData[])
end

function GetUUID(self::KeyStore)
	pHasUUID = Ref{Cbool}()
	nUUIDBufferSize = UInt64(0)
	nUUIDNeeded = Ref{UInt64}(0)
	pUUIDBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_keystore_getuuid], Int32, (Ptr{Cvoid}, Ref{Cbool}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, pHasUUID, nUUIDBufferSize, nUUIDNeeded, pUUIDBuffer)
	_checkError(self.wrapper, self, err)
	pUUIDBuffer = Array{UInt8}(undef, Int(nUUIDNeeded[]))
	nUUIDBufferSize = UInt64(length(pUUIDBuffer))
	pUUIDBuffer_ptr = pointer(pUUIDBuffer)
	GC.@preserve pUUIDBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_keystore_getuuid], Int32, (Ptr{Cvoid}, Ref{Cbool}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, pHasUUID, nUUIDBufferSize, nUUIDNeeded, pUUIDBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pHasUUID[] != 0, unsafe_string(pUUIDBuffer_ptr)
end

function SetUUID(self::KeyStore, UUID::AbstractString)
	GC.@preserve UUID begin
		err = ccall(self.wrapper.funcs[:lib3mf_keystore_setuuid], Int32, (Ptr{Cvoid}, Cstring), self.handle, UUID)
	end
	_checkError(self.wrapper, self, err)
end

function ClassTypeId(self::KeyStore)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

function RootModelPart(self::Model)
	pRootModelPart = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_rootmodelpart], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pRootModelPart)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pRootModelPart[])
end

function FindOrCreatePackagePart(self::Model, AbsolutePath::AbstractString)
	pModelPart = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve AbsolutePath begin
		err = ccall(self.wrapper.funcs[:lib3mf_model_findorcreatepackagepart], Int32, (Ptr{Cvoid}, Cstring, Ref{Ptr{Cvoid}}), self.handle, AbsolutePath, pModelPart)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pModelPart[])
end

function SetUnit(self::Model, Unit::eModelUnit)
	err = ccall(self.wrapper.funcs[:lib3mf_model_setunit], Int32, (Ptr{Cvoid}, eModelUnit), self.handle, Unit)
	_checkError(self.wrapper, self, err)
end

function GetUnit(self::Model)
	pUnit = Ref{Int32}(0)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getunit], Int32, (Ptr{Cvoid}, Ref{Int32}), self.handle, pUnit)
	_checkError(self.wrapper, self, err)
	return eModelUnit(pUnit[])
end

function GetLanguage(self::Model)
	nLanguageBufferSize = UInt64(0)
	nLanguageNeeded = Ref{UInt64}(0)
	pLanguageBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getlanguage], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nLanguageBufferSize, nLanguageNeeded, pLanguageBuffer)
	_checkError(self.wrapper, self, err)
	pLanguageBuffer = Array{UInt8}(undef, Int(nLanguageNeeded[]))
	nLanguageBufferSize = UInt64(length(pLanguageBuffer))
	pLanguageBuffer_ptr = pointer(pLanguageBuffer)
	GC.@preserve pLanguageBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_model_getlanguage], Int32, (Ptr{Cvoid}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, nLanguageBufferSize, nLanguageNeeded, pLanguageBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return unsafe_string(pLanguageBuffer_ptr)
end

function SetLanguage(self::Model, Language::AbstractString)
	GC.@preserve Language begin
		err = ccall(self.wrapper.funcs[:lib3mf_model_setlanguage], Int32, (Ptr{Cvoid}, Cstring), self.handle, Language)
	end
	_checkError(self.wrapper, self, err)
end

function QueryWriter(self::Model, WriterClass::AbstractString)
	pWriterInstance = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve WriterClass begin
		err = ccall(self.wrapper.funcs[:lib3mf_model_querywriter], Int32, (Ptr{Cvoid}, Cstring, Ref{Ptr{Cvoid}}), self.handle, WriterClass, pWriterInstance)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pWriterInstance[])
end

function QueryReader(self::Model, ReaderClass::AbstractString)
	pReaderInstance = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve ReaderClass begin
		err = ccall(self.wrapper.funcs[:lib3mf_model_queryreader], Int32, (Ptr{Cvoid}, Cstring, Ref{Ptr{Cvoid}}), self.handle, ReaderClass, pReaderInstance)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pReaderInstance[])
end

function GetResourceByID(self::Model, UniqueResourceID::UInt32)
	pResource = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getresourcebyid], Int32, (Ptr{Cvoid}, UInt32, Ref{Ptr{Cvoid}}), self.handle, UniqueResourceID, pResource)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResource[])
end

function GetTexture2DByID(self::Model, UniqueResourceID::UInt32)
	pTextureInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_gettexture2dbyid], Int32, (Ptr{Cvoid}, UInt32, Ref{Ptr{Cvoid}}), self.handle, UniqueResourceID, pTextureInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTextureInstance[])
end

function GetPropertyTypeByID(self::Model, UniqueResourceID::UInt32)
	pThePropertyType = Ref{Int32}(0)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getpropertytypebyid], Int32, (Ptr{Cvoid}, UInt32, Ref{Int32}), self.handle, UniqueResourceID, pThePropertyType)
	_checkError(self.wrapper, self, err)
	return ePropertyType(pThePropertyType[])
end

function GetBaseMaterialGroupByID(self::Model, UniqueResourceID::UInt32)
	pBaseMaterialGroupInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getbasematerialgroupbyid], Int32, (Ptr{Cvoid}, UInt32, Ref{Ptr{Cvoid}}), self.handle, UniqueResourceID, pBaseMaterialGroupInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pBaseMaterialGroupInstance[])
end

function GetTexture2DGroupByID(self::Model, UniqueResourceID::UInt32)
	pTexture2DGroupInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_gettexture2dgroupbyid], Int32, (Ptr{Cvoid}, UInt32, Ref{Ptr{Cvoid}}), self.handle, UniqueResourceID, pTexture2DGroupInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTexture2DGroupInstance[])
end

function GetCompositeMaterialsByID(self::Model, UniqueResourceID::UInt32)
	pCompositeMaterialsInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getcompositematerialsbyid], Int32, (Ptr{Cvoid}, UInt32, Ref{Ptr{Cvoid}}), self.handle, UniqueResourceID, pCompositeMaterialsInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pCompositeMaterialsInstance[])
end

function GetMultiPropertyGroupByID(self::Model, UniqueResourceID::UInt32)
	pMultiPropertyGroupInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getmultipropertygroupbyid], Int32, (Ptr{Cvoid}, UInt32, Ref{Ptr{Cvoid}}), self.handle, UniqueResourceID, pMultiPropertyGroupInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pMultiPropertyGroupInstance[])
end

function GetMeshObjectByID(self::Model, UniqueResourceID::UInt32)
	pMeshObjectInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getmeshobjectbyid], Int32, (Ptr{Cvoid}, UInt32, Ref{Ptr{Cvoid}}), self.handle, UniqueResourceID, pMeshObjectInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pMeshObjectInstance[])
end

function GetComponentsObjectByID(self::Model, UniqueResourceID::UInt32)
	pComponentsObjectInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getcomponentsobjectbyid], Int32, (Ptr{Cvoid}, UInt32, Ref{Ptr{Cvoid}}), self.handle, UniqueResourceID, pComponentsObjectInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pComponentsObjectInstance[])
end

function GetColorGroupByID(self::Model, UniqueResourceID::UInt32)
	pColorGroupInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getcolorgroupbyid], Int32, (Ptr{Cvoid}, UInt32, Ref{Ptr{Cvoid}}), self.handle, UniqueResourceID, pColorGroupInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pColorGroupInstance[])
end

function GetSliceStackByID(self::Model, UniqueResourceID::UInt32)
	pSliceStacInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getslicestackbyid], Int32, (Ptr{Cvoid}, UInt32, Ref{Ptr{Cvoid}}), self.handle, UniqueResourceID, pSliceStacInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pSliceStacInstance[])
end

function GetLevelSetByID(self::Model, UniqueResourceID::UInt32)
	pLevelSetObjectInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getlevelsetbyid], Int32, (Ptr{Cvoid}, UInt32, Ref{Ptr{Cvoid}}), self.handle, UniqueResourceID, pLevelSetObjectInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pLevelSetObjectInstance[])
end

function GetBuildUUID(self::Model)
	pHasUUID = Ref{Cbool}()
	nUUIDBufferSize = UInt64(0)
	nUUIDNeeded = Ref{UInt64}(0)
	pUUIDBuffer = Ptr{Cchar}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getbuilduuid], Int32, (Ptr{Cvoid}, Ref{Cbool}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, pHasUUID, nUUIDBufferSize, nUUIDNeeded, pUUIDBuffer)
	_checkError(self.wrapper, self, err)
	pUUIDBuffer = Array{UInt8}(undef, Int(nUUIDNeeded[]))
	nUUIDBufferSize = UInt64(length(pUUIDBuffer))
	pUUIDBuffer_ptr = pointer(pUUIDBuffer)
	GC.@preserve pUUIDBuffer begin
		err = ccall(self.wrapper.funcs[:lib3mf_model_getbuilduuid], Int32, (Ptr{Cvoid}, Ref{Cbool}, UInt64, Ref{UInt64}, Ptr{Cchar}), self.handle, pHasUUID, nUUIDBufferSize, nUUIDNeeded, pUUIDBuffer_ptr)
	end
	_checkError(self.wrapper, self, err)
	return pHasUUID[] != 0, unsafe_string(pUUIDBuffer_ptr)
end

function SetBuildUUID(self::Model, UUID::AbstractString)
	GC.@preserve UUID begin
		err = ccall(self.wrapper.funcs[:lib3mf_model_setbuilduuid], Int32, (Ptr{Cvoid}, Cstring), self.handle, UUID)
	end
	_checkError(self.wrapper, self, err)
end

function GetBuildItems(self::Model)
	pBuildItemIterator = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getbuilditems], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pBuildItemIterator)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pBuildItemIterator[])
end

function GetOutbox(self::Model)
	pOutbox = Ref{sBox}()
	err = ccall(self.wrapper.funcs[:lib3mf_model_getoutbox], Int32, (Ptr{Cvoid}, Ref{sBox}), self.handle, pOutbox)
	_checkError(self.wrapper, self, err)
	return pOutbox[]
end

function GetResources(self::Model)
	pResourceIterator = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getresources], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResourceIterator)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResourceIterator[])
end

function GetObjects(self::Model)
	pResourceIterator = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getobjects], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResourceIterator)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResourceIterator[])
end

function GetMeshObjects(self::Model)
	pResourceIterator = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getmeshobjects], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResourceIterator)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResourceIterator[])
end

function GetComponentsObjects(self::Model)
	pResourceIterator = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getcomponentsobjects], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResourceIterator)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResourceIterator[])
end

function GetTexture2Ds(self::Model)
	pResourceIterator = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_gettexture2ds], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResourceIterator)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResourceIterator[])
end

function GetBaseMaterialGroups(self::Model)
	pResourceIterator = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getbasematerialgroups], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResourceIterator)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResourceIterator[])
end

function GetColorGroups(self::Model)
	pResourceIterator = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getcolorgroups], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResourceIterator)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResourceIterator[])
end

function GetTexture2DGroups(self::Model)
	pResourceIterator = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_gettexture2dgroups], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResourceIterator)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResourceIterator[])
end

function GetCompositeMaterials(self::Model)
	pResourceIterator = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getcompositematerials], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResourceIterator)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResourceIterator[])
end

function GetMultiPropertyGroups(self::Model)
	pResourceIterator = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getmultipropertygroups], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResourceIterator)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResourceIterator[])
end

function GetSliceStacks(self::Model)
	pResourceIterator = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getslicestacks], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResourceIterator)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResourceIterator[])
end

function GetImage3Ds(self::Model)
	pResourceIterator = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getimage3ds], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResourceIterator)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResourceIterator[])
end

function MergeToModel(self::Model)
	pMergedModelInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_mergetomodel], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pMergedModelInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pMergedModelInstance[])
end

function MergeFromModel(self::Model, ModelInstance::Model)
	err = ccall(self.wrapper.funcs[:lib3mf_model_mergefrommodel], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, ModelInstance.handle)
	_checkError(self.wrapper, self, err)
end

function AddMeshObject(self::Model)
	pMeshObjectInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_addmeshobject], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pMeshObjectInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pMeshObjectInstance[])
end

function AddComponentsObject(self::Model)
	pComponentsObjectInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_addcomponentsobject], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pComponentsObjectInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pComponentsObjectInstance[])
end

function AddSliceStack(self::Model, ZBottom::Cdouble)
	pSliceStackInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_addslicestack], Int32, (Ptr{Cvoid}, Cdouble, Ref{Ptr{Cvoid}}), self.handle, ZBottom, pSliceStackInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pSliceStackInstance[])
end

function AddTexture2DFromAttachment(self::Model, TextureAttachment::Attachment)
	pTexture2DInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_addtexture2dfromattachment], Int32, (Ptr{Cvoid}, Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, TextureAttachment.handle, pTexture2DInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTexture2DInstance[])
end

function AddBaseMaterialGroup(self::Model)
	pBaseMaterialGroupInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_addbasematerialgroup], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pBaseMaterialGroupInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pBaseMaterialGroupInstance[])
end

function AddColorGroup(self::Model)
	pColorGroupInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_addcolorgroup], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pColorGroupInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pColorGroupInstance[])
end

function AddTexture2DGroup(self::Model, Texture2DInstance::Texture2D)
	pTexture2DGroupInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_addtexture2dgroup], Int32, (Ptr{Cvoid}, Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, Texture2DInstance.handle, pTexture2DGroupInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTexture2DGroupInstance[])
end

function AddCompositeMaterials(self::Model, BaseMaterialGroupInstance::BaseMaterialGroup)
	pCompositeMaterialsInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_addcompositematerials], Int32, (Ptr{Cvoid}, Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, BaseMaterialGroupInstance.handle, pCompositeMaterialsInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pCompositeMaterialsInstance[])
end

function AddMultiPropertyGroup(self::Model)
	pMultiPropertyGroupInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_addmultipropertygroup], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pMultiPropertyGroupInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pMultiPropertyGroupInstance[])
end

function AddImageStack(self::Model, ColumnCount::UInt32, RowCount::UInt32, SheetCount::UInt32)
	pInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_addimagestack], Int32, (Ptr{Cvoid}, UInt32, UInt32, UInt32, Ref{Ptr{Cvoid}}), self.handle, ColumnCount, RowCount, SheetCount, pInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pInstance[])
end

function GetImageStackByID(self::Model, UniqueResourceID::UInt32)
	pImageStackInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getimagestackbyid], Int32, (Ptr{Cvoid}, UInt32, Ref{Ptr{Cvoid}}), self.handle, UniqueResourceID, pImageStackInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pImageStackInstance[])
end

function AddBuildItem(self::Model, Object::Object, Transform::sTransform)
	pTransform = Ref{sTransform}(Transform)
	pBuildItemInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_addbuilditem], Int32, (Ptr{Cvoid}, Ptr{Cvoid}, Ref{sTransform}, Ref{Ptr{Cvoid}}), self.handle, Object.handle, pTransform, pBuildItemInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pBuildItemInstance[])
end

function RemoveBuildItem(self::Model, BuildItemInstance::BuildItem)
	err = ccall(self.wrapper.funcs[:lib3mf_model_removebuilditem], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, BuildItemInstance.handle)
	_checkError(self.wrapper, self, err)
end

function GetMetaDataGroup(self::Model)
	pTheMetaDataGroup = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getmetadatagroup], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pTheMetaDataGroup)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheMetaDataGroup[])
end

function AddAttachment(self::Model, URI::AbstractString, RelationShipType::AbstractString)
	pAttachmentInstance = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve URI RelationShipType begin
		err = ccall(self.wrapper.funcs[:lib3mf_model_addattachment], Int32, (Ptr{Cvoid}, Cstring, Cstring, Ref{Ptr{Cvoid}}), self.handle, URI, RelationShipType, pAttachmentInstance)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pAttachmentInstance[])
end

function RemoveAttachment(self::Model, AttachmentInstance::Attachment)
	err = ccall(self.wrapper.funcs[:lib3mf_model_removeattachment], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, AttachmentInstance.handle)
	_checkError(self.wrapper, self, err)
end

function GetAttachment(self::Model, Index::UInt32)
	pAttachmentInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getattachment], Int32, (Ptr{Cvoid}, UInt32, Ref{Ptr{Cvoid}}), self.handle, Index, pAttachmentInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pAttachmentInstance[])
end

function FindAttachment(self::Model, URI::AbstractString)
	pAttachmentInstance = Ref{Ptr{Cvoid}}(C_NULL)
	GC.@preserve URI begin
		err = ccall(self.wrapper.funcs[:lib3mf_model_findattachment], Int32, (Ptr{Cvoid}, Cstring, Ref{Ptr{Cvoid}}), self.handle, URI, pAttachmentInstance)
	end
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pAttachmentInstance[])
end

function GetAttachmentCount(self::Model)
	pAttachmentCount = Ref{UInt32}()
	err = ccall(self.wrapper.funcs[:lib3mf_model_getattachmentcount], Int32, (Ptr{Cvoid}, Ref{UInt32}), self.handle, pAttachmentCount)
	_checkError(self.wrapper, self, err)
	return pAttachmentCount[]
end

function HasPackageThumbnailAttachment(self::Model)
	pHasThumbnail = Ref{Cbool}()
	err = ccall(self.wrapper.funcs[:lib3mf_model_haspackagethumbnailattachment], Int32, (Ptr{Cvoid}, Ref{Cbool}), self.handle, pHasThumbnail)
	_checkError(self.wrapper, self, err)
	return pHasThumbnail[] != 0
end

function CreatePackageThumbnailAttachment(self::Model)
	pAttachment = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_createpackagethumbnailattachment], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pAttachment)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pAttachment[])
end

function GetPackageThumbnailAttachment(self::Model)
	pAttachment = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getpackagethumbnailattachment], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pAttachment)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pAttachment[])
end

function RemovePackageThumbnailAttachment(self::Model)
	err = ccall(self.wrapper.funcs[:lib3mf_model_removepackagethumbnailattachment], Int32, (Ptr{Cvoid},), self.handle)
	_checkError(self.wrapper, self, err)
end

function AddCustomContentType(self::Model, Extension::AbstractString, ContentType::AbstractString)
	GC.@preserve Extension ContentType begin
		err = ccall(self.wrapper.funcs[:lib3mf_model_addcustomcontenttype], Int32, (Ptr{Cvoid}, Cstring, Cstring), self.handle, Extension, ContentType)
	end
	_checkError(self.wrapper, self, err)
end

function RemoveCustomContentType(self::Model, Extension::AbstractString)
	GC.@preserve Extension begin
		err = ccall(self.wrapper.funcs[:lib3mf_model_removecustomcontenttype], Int32, (Ptr{Cvoid}, Cstring), self.handle, Extension)
	end
	_checkError(self.wrapper, self, err)
end


function GetKeyStore(self::Model)
	pKeyStore = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getkeystore], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pKeyStore)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pKeyStore[])
end

function GetFunctions(self::Model)
	pTheResourceIterator = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getfunctions], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pTheResourceIterator)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pTheResourceIterator[])
end

function AddImplicitFunction(self::Model)
	pFunctionInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_addimplicitfunction], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pFunctionInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pFunctionInstance[])
end

function AddFunctionFromImage3D(self::Model, Image3DInstance::Image3D)
	pFunctionInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_addfunctionfromimage3d], Int32, (Ptr{Cvoid}, Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, Image3DInstance.handle, pFunctionInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pFunctionInstance[])
end

function AddVolumeData(self::Model)
	pVolumeDataInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_addvolumedata], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pVolumeDataInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pVolumeDataInstance[])
end

function AddLevelSet(self::Model)
	pLevelSetInstance = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_addlevelset], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pLevelSetInstance)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pLevelSetInstance[])
end

function GetLevelSets(self::Model)
	pResourceIterator = Ref{Ptr{Cvoid}}(C_NULL)
	err = ccall(self.wrapper.funcs[:lib3mf_model_getlevelsets], Int32, (Ptr{Cvoid}, Ref{Ptr{Cvoid}}), self.handle, pResourceIterator)
	_checkError(self.wrapper, self, err)
	return _polymorphicFactory(self.wrapper, pResourceIterator[])
end

function RemoveResource(self::Model, Resource::Resource)
	err = ccall(self.wrapper.funcs[:lib3mf_model_removeresource], Int32, (Ptr{Cvoid}, Ptr{Cvoid}), self.handle, Resource.handle)
	_checkError(self.wrapper, self, err)
end

function ClassTypeId(self::Model)
	return ClassTypeId(Base(self.handle, self.wrapper))
end

end # module Lib3MF
